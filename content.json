{"meta":{"title":"Uyouii's Blogs","subtitle":"There are many things need to learn.","description":null,"author":"Uyouii","url":"https://uyouii.github.io"},"pages":[{"title":"All Tags","date":"2017-12-12T05:01:04.000Z","updated":"2017-12-12T05:02:08.532Z","comments":true,"path":"tags/index.html","permalink":"https://uyouii.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-12-12T05:04:45.000Z","updated":"2017-12-12T05:05:11.952Z","comments":true,"path":"categories/index.html","permalink":"https://uyouii.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"libevent 服务端客户端 简单实例","slug":"libevent-服务端客户端-简单实例","date":"2017-12-12T03:26:17.000Z","updated":"2017-12-12T06:20:10.431Z","comments":true,"path":"2017/12/12/libevent-服务端客户端-简单实例/","link":"","permalink":"https://uyouii.github.io/2017/12/12/libevent-服务端客户端-简单实例/","excerpt":"","text":"最近了解了下libevent，简单的实现了一个客户端服务端通信的demo，服务端会转发客户端发送的数据包给其他客户端，并测试每秒转发的数据量和数据包的个数。 包格式简单的定义了数据包头的格式，12个字节，包含三个变量，分别是targetID（目的地的id），sourceID（源id）和length（数据的长度，不包含header的长度）。 暂时client的id分配由服务器分配，客户端编号从1开始，id为0代表是服务器发送的原始消息，不是转发的其他客户端发送的数据。 数据发送客户端每隔10ms发送一个数据包给其他客户端，服务器收到数据包后转发给其他客户端。 代码服务端12345678910111213141516171819202122#ifndef _MESSAGE_H_#define _MESSAGE_H_#include&lt;string&gt;using namespace std;typedef struct msg_header &#123; unsigned int targetID; unsigned int sourceID; unsigned int length;&#125; Header;void listener_cb(struct evconnlistener *, evutil_socket_t, struct sockaddr *, int socklen, void *);void conn_writecb(struct bufferevent *, void *);void conn_readcb(struct bufferevent *, void *);void conn_eventcb(struct bufferevent *, short, void *);unsigned int get_client_id(struct bufferevent*);string inttostr(int);void write_buffer(string&amp;, struct bufferevent*, Header&amp;);#endif // !_MESSAGE_H_ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;event2/bufferevent.h&gt; #include &lt;event2/buffer.h&gt; #include &lt;event2/listener.h&gt; #include &lt;event2/util.h&gt; #include &lt;event2/event.h&gt; #include &lt;vector&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include \"message.h\"using namespace std;#define PORT 1234#define BUFFER_SIZE (16 * 1024) #define READ_SIZE (2 * 1024)#define TIME_INTERVAL 5000const char ip_address[] = \"127.0.0.1\";map&lt;unsigned int, bufferevent*&gt; ClientMap; //client id 对应的buffereventint conectNumber = 0;int dataSize = 0;int lastTime = 0;int receiveNumber = 0;int sendNumber = 0;int main(int argc, char **argv) &#123;#ifdef WIN32 WSAData wsaData; WSAStartup(MAKEWORD(2, 0), &amp;wsaData);#endif cout &lt;&lt; \"Server begin running!\" &lt;&lt; endl; struct sockaddr_in sin; memset(&amp;sin, 0, sizeof(sin)); sin.sin_family = AF_INET; sin.sin_addr.S_un.S_addr = inet_addr(ip_address); sin.sin_port = htons(PORT); struct evconnlistener *listener; struct event_base *base = event_base_new(); if (!base) &#123; cout &lt;&lt; \"Could not initialize libevent\" &lt;&lt; endl;; return 1; &#125; //默认情况下，链接监听器接收新套接字后，会将其设置为非阻塞的 listener = evconnlistener_new_bind(base, listener_cb, (void *)base, LEV_OPT_REUSEABLE | LEV_OPT_CLOSE_ON_FREE, -1, (struct sockaddr*)&amp;sin, sizeof(sin)); if (!listener) &#123; cout &lt;&lt; \"Could not create a listener\" &lt;&lt; endl; return 1; &#125; event_base_dispatch(base); evconnlistener_free(listener); event_base_free(base); return 0;&#125;void listener_cb(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *sa, int socklen, void *user_data) &#123; cout &lt;&lt; \"Detect an connection\" &lt;&lt; endl; struct event_base *base = (struct event_base *)user_data; struct bufferevent *bev; //BEV_OPT_CLOSE_ON_FREE close the file descriptor when this bufferevent is freed bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); if (!bev) &#123; cout &lt;&lt; \"Could not create a bufferevent\" &lt;&lt; endl; event_base_loopbreak(base); return; &#125; ClientMap[++conectNumber] = bev; //read write event bufferevent_setcb(bev, conn_readcb, NULL, conn_eventcb, NULL); bufferevent_enable(bev, EV_READ | EV_WRITE); //send a message to client when connect is succeeded string msg = \"connedted\"; Header header; header.sourceID = 0; header.targetID = conectNumber; header.length = msg.size(); write_buffer(msg, bev, header);&#125;void conn_writecb(struct bufferevent *bev, void *user_data) &#123; Sleep(2000); int len = 0; Header header; unsigned int toID = get_client_id(bev); string msg = \"hello client \" + inttostr(toID); header.targetID = toID; header.sourceID = 0; header.length = msg.size(); write_buffer(msg, bev, header);&#125;void conn_readcb(struct bufferevent *bev, void *user_data) &#123; struct evbuffer *input = bufferevent_get_input(bev); size_t sz = evbuffer_get_length(input); if (sz &gt; 0 &amp;&amp; sz &lt; BUFFER_SIZE) &#123; char msg[BUFFER_SIZE] = &#123; '\\0' &#125;; bufferevent_read(bev, msg, sz); unsigned int sourceID = get_client_id(bev); //cout &lt;&lt; \"get data \" &lt;&lt; sz &lt;&lt; \" from client \" &lt;&lt; sourceID &lt;&lt; endl; char *ptr = msg; while (ptr - msg &lt; sz) &#123; receiveNumber++; //cout &lt;&lt; ptr - msg &lt;&lt; endl; ((Header*)ptr)-&gt;sourceID = sourceID; unsigned int len = ((Header*)ptr)-&gt;length; unsigned int targetID = ((Header*)ptr)-&gt;targetID; //坑啊，有时候包传输的时候长度数据坏了= =，访问越界，会报内存访问冲突的错误 if (ptr - msg + len + sizeof(Header) &gt; sz) break; if (ClientMap.find(targetID) != ClientMap.end()) &#123; sendNumber++; bufferevent_write(ClientMap[targetID], ptr, len + sizeof(Header)); //cout &lt;&lt; \"message from client \" &lt;&lt; sourceID &lt;&lt; \" to client \" &lt;&lt; targetID &lt;&lt; endl; &#125; else &#123; //can't find the client, do something &#125; ptr += len + sizeof(Header); &#125; &#125; else &#123; cout &lt;&lt; \"error! size &gt; BUFFER_SIZE!\" &lt;&lt; endl; &#125; //calculate the speed of data and packet dataSize += sz; clock_t nowtime = clock(); if (lastTime == 0) &#123; lastTime = nowtime; &#125; else &#123; cout &lt;&lt; \"data speed: \" &lt;&lt; (double)dataSize / (nowtime - lastTime) * 1000 &lt;&lt; \"bit/s \"; cout &lt;&lt; \"packet speed: receive \" &lt;&lt; (double)receiveNumber / (nowtime - lastTime) * 1000 &lt;&lt; \"/s \"; cout &lt;&lt; \"send \" &lt;&lt; (double)sendNumber / (nowtime - lastTime) * 1000 &lt;&lt; \"/s\" &lt;&lt; endl; if (nowtime - lastTime &gt; TIME_INTERVAL) &#123; dataSize = 0; lastTime = nowtime; receiveNumber = 0; sendNumber = 0; &#125; &#125;&#125;void conn_eventcb(struct bufferevent *bev, short events, void *user_data) &#123; if (events &amp; BEV_EVENT_EOF) &#123; cout &lt;&lt; \"Connection closed\" &lt;&lt; endl; &#125; else if (events &amp; BEV_EVENT_ERROR) &#123; cout &lt;&lt; \"Got an error on the connection: \" &lt;&lt; strerror(errno) &lt;&lt; endl; &#125; bufferevent_free(bev);&#125;unsigned int get_client_id(struct bufferevent* bev) &#123; for (auto p = ClientMap.begin(); p != ClientMap.end(); p++) &#123; if (p-&gt;second == bev) &#123; return p-&gt;first; &#125; &#125; return 0;&#125;void write_buffer(string&amp; msg, struct bufferevent* bev, Header&amp; header) &#123; char send_msg[BUFFER_SIZE] = &#123; 0 &#125;; char* ptr = send_msg; int len = 0; memcpy(ptr, &amp;header, sizeof(Header)); len += sizeof(Header); ptr += sizeof(Header); memcpy(ptr, msg.c_str(), msg.size()); len += msg.size(); bufferevent_write(bev, send_msg, len);&#125;string inttostr(int num) &#123; string result; bool neg = false; if (num &lt; 0) &#123; neg = true; num = -num; &#125; if (num == 0) &#123; result += '0'; &#125; else &#123; while (num &gt; 0) &#123; int rem = num % 10; result = (char)(rem + '0') + result; num /= 10; &#125; &#125; if (neg) &#123; result = '-' + result; &#125; return result;&#125; 客户端123456789101112131415161718192021#ifndef _MESSAGE_H_#define _MESSAGE_H_#include&lt;string&gt;using namespace std;typedef struct msg_header &#123; unsigned int targetID; unsigned int sourceID; unsigned int length;&#125; Header;void conn_writecb(struct bufferevent *, void *);void conn_readcb(struct bufferevent *, void *);void conn_eventcb(struct bufferevent *, short, void *);string inttostr(int);void write_buffer(string&amp;, struct bufferevent*, Header&amp;);void read_buffer(char *,unsigned int);#endif // !_MESSAGE_H_ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;event2/bufferevent.h&gt; #include &lt;event2/buffer.h&gt; #include &lt;event2/listener.h&gt; #include &lt;event2/util.h&gt; #include &lt;event2/event.h&gt; #include &lt;iostream&gt;#include &lt;string&gt;#include \"message.h\"using namespace std;#define PORT 1234#define BUFFER_SIZE (16 * 1024)#define READ_SIZE (2 * 1024)#define SEND_INTERVAL 10const char ip_address[] = \"127.0.0.1\";int main() &#123; cout &lt;&lt; \"Client running\" &lt;&lt; endl;#ifdef WIN32 WSAData wsaData; WSAStartup(MAKEWORD(2, 0), &amp;wsaData);#endif struct sockaddr_in srv; memset(&amp;srv, 0, sizeof(srv)); srv.sin_addr.S_un.S_addr = inet_addr(ip_address); srv.sin_family = AF_INET; srv.sin_port = htons(PORT); struct event_base *base = event_base_new(); if (!base) &#123; cout &lt;&lt; \"Could not initialize libevent\" &lt;&lt; endl; return 1; &#125; struct bufferevent* bev = bufferevent_socket_new(base, -1,BEV_OPT_CLOSE_ON_FREE); bufferevent_setcb(bev, conn_readcb, conn_writecb, conn_eventcb, NULL); //连接，成功返回0，失败返回-1 int flag = bufferevent_socket_connect(bev, (struct sockaddr *)&amp;srv, sizeof(srv)); bufferevent_enable(bev, EV_READ | EV_WRITE); if (-1 == flag) &#123; cout &lt;&lt; \"Connect failed\" &lt;&lt; endl; return 1; &#125; event_base_dispatch(base); event_base_free(base); return 0;&#125;void conn_writecb(struct bufferevent *bev, void *user_data) &#123; Sleep(SEND_INTERVAL); int len = 0; static int num[10] = &#123; 0 &#125;; unsigned int toID = rand() % 5 + 1; Header header; string msg = \"hello client \" + inttostr(toID) + \", it's the \" + inttostr(++num[toID]) + \"message\"; header.targetID = toID; header.length = msg.size(); write_buffer(msg, bev, header);&#125;void conn_readcb(struct bufferevent *bev, void *user_data) &#123; struct evbuffer *input = bufferevent_get_input(bev); size_t sz = evbuffer_get_length(input); //返回evbuffer储存的字节数 if (sz &gt; 0) &#123; char msg[BUFFER_SIZE] = &#123; '\\0' &#125;; unsigned int size = bufferevent_read(bev, msg, sz); read_buffer(msg,size); &#125;&#125;void read_buffer(char *msg,unsigned int size) &#123; char *ptr = msg; cout &lt;&lt; \"receive \" &lt;&lt; size &lt;&lt; \" data from server\" &lt;&lt; endl; char data[READ_SIZE]; while (ptr - msg &lt; size) &#123; memset(data, 0, READ_SIZE); //cout &lt;&lt; ptr - msg &lt;&lt; endl; unsigned int sourceID = ((Header*)ptr)-&gt;sourceID; int length = ((Header*)ptr)-&gt;length; ptr += sizeof(Header); //坑啊，有时候包传输的时候长度数据坏了= =，访问越界，会报内存访问冲突的错误 if (ptr - msg + length &gt; size) break; memcpy(data, ptr, length); cout &lt;&lt; \"message from client \" &lt;&lt; sourceID &lt;&lt; \" : \" &lt;&lt; data &lt;&lt; endl; ptr += length; &#125;&#125;void conn_eventcb(struct bufferevent *bev, short events, void *user_data)&#123; if (events &amp; BEV_EVENT_EOF) &#123; cout &lt;&lt; \"Connection closed\" &lt;&lt; endl; &#125; else if (events &amp; BEV_EVENT_ERROR) &#123; cout &lt;&lt; \"Got an error on the connection: \" &lt;&lt; strerror(errno) &lt;&lt; endl; &#125; else if (events &amp; BEV_EVENT_CONNECTED) &#123; cout &lt;&lt; \"Connect succeed\" &lt;&lt; endl; string msg = \"connect to server\"; Header header; header.targetID = 0; header.length = msg.size(); write_buffer(msg, bev, header); return; &#125; bufferevent_free(bev);&#125;void write_buffer(string&amp; msg, struct bufferevent* bev, Header&amp; header) &#123; char send_msg[BUFFER_SIZE] = &#123; 0 &#125;; char* ptr = send_msg; int len = 0; memcpy(ptr, &amp;header, sizeof(Header)); len += sizeof(Header); ptr += sizeof(Header); memcpy(ptr, msg.c_str(), msg.size()); len += msg.size(); bufferevent_write(bev, send_msg, len);&#125;string inttostr(int num) &#123; string result; bool neg = false; if (num &lt; 0) &#123; neg = true; num = -num; &#125; if (num == 0) &#123; result += '0'; &#125; else &#123; while (num &gt; 0) &#123; int rem = num % 10; result = (char)(rem + '0') + result; num /= 10; &#125; &#125; if (neg) &#123; result = '-' + result; &#125; return result;&#125; 效果图片 服务器测试转发速度 客户端 client1： client2：","categories":[],"tags":[{"name":"libevent","slug":"libevent","permalink":"https://uyouii.github.io/tags/libevent/"},{"name":"c++","slug":"c","permalink":"https://uyouii.github.io/tags/c/"},{"name":"network","slug":"network","permalink":"https://uyouii.github.io/tags/network/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-11-29T07:58:40.106Z","updated":"2017-11-29T07:58:40.106Z","comments":true,"path":"2017/11/29/hello-world/","link":"","permalink":"https://uyouii.github.io/2017/11/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}