{"meta":{"title":"Uyouii's Blogs","subtitle":"There are many things need to learn.","description":null,"author":"Uyouii","url":"https://uyouii.github.io"},"pages":[{"title":"categories","date":"2017-12-12T05:04:45.000Z","updated":"2019-08-02T03:28:18.919Z","comments":true,"path":"categories/index.html","permalink":"https://uyouii.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-08-03T09:40:00.000Z","updated":"2019-08-03T09:40:00.541Z","comments":true,"path":"about/index.html","permalink":"https://uyouii.github.io/about/index.html","excerpt":"","text":""},{"title":"All Tags","date":"2017-12-12T05:01:04.000Z","updated":"2019-08-02T03:28:18.960Z","comments":true,"path":"tags/index.html","permalink":"https://uyouii.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Effective Modern C++ 2 理解auto型别推导","slug":"Effective-Modern-CPP-2-理解auto型别推导","date":"2019-10-27T14:38:12.000Z","updated":"2019-10-27T14:41:38.887Z","comments":true,"path":"2019/10/27/Effective-Modern-CPP-2-理解auto型别推导/","link":"","permalink":"https://uyouii.github.io/2019/10/27/Effective-Modern-CPP-2-理解auto型别推导/","excerpt":"","text":"条款2： 理解auto 型别推导在模板型别推导和auto型别推导可以建立起一一映射，它们之间也确实存在着双向的算法变换。 1234template&lt;typename T&gt;void f(ParamType param);f(expr); // 以某表达式调用f 在f的调用语句中，编译器会利用expr来推导T和ParamType的型别。 当某变量采用auto来声明的时候，auto就扮演了模板中T这个角色，而变量的饰词则扮演的是ParamType的角色。 情况1: ParamType是个指针或者引用，但不是个万能引用 情况2: ParamType是个万能引用 情况3: ParamType既非指针也非引用 12345678910111213141516// 情况1 或 情况3auto x = 27; // 情况3（x既非指针也非引用）const auto cx = x; // 情况3（cx既非指针也非引用）const auto&amp; rx = x; // 情况1（rx是个引用，但不是个万能引用）// 情况2auto&amp;&amp; uref1 = x; // x的型别是int，且是左值 // 所以uref1的型别是int&amp;auto&amp;&amp; uref2 = x; // cx的型别是const int，且是左值 // 所以uref2的型别是const int&amp;auto&amp;&amp; uref3 = 27; // 27的型别是int，且是右值 // 所以uref2的型别是int&amp;&amp; 数组和函数的情况也适用于auto型别的推导 1234567891011const char name[] = \"xxxxxx\" // name的型别是 const char [7] auto arr1 = name; // arr1的型别是const char *auto arr2 = name; // arr1的型别是const char (&amp;)[7]void someFunc(int, double) // someFunc是个函数，型别是void(int, double) auto func1 = someFunc; // fun1的型别是 void(*)(int, double)auto&amp; func2 = someFunc; // func2的型别是void(&amp;)(int, double) auto和模板类型的不同声明一个int并初始化，C++98中有两种语法 12int x1 = 27;int x2(27); C++11为了支持统一初始化(uniform initialization)，增加了下面的语法选项： 12int x3 = &#123;27&#125;;int x4&#123;27&#125;; 如果用auto： 1234auto x1 = 27; // 型别是int，值是27auto x2(27); // 同上auto x3 = &#123;27&#125;; // 型别是 std::initializer_list&lt;int&gt;，值是&#123;27&#125;auto x4&#123;27&#125;; // 同上 后面两个语句，声明了这么一个变量，其型别类型为std::initializer_list，且含有单个值为27的元素。 当用于auto声明变量的初始表达式是大括号起时，推导所得的型别就属于std::initizlizer_list。 对于大括号初始表达式的处理方式，是auto型别推导和模板型别推导的唯一不同之处。当采用auto声明的变量使用大括号初始化表达式进行初始化时，推导所得的型别是std::initializer_list的一个实例型别。 但是如果向对应模板传入一个同样的初始化表达式，型别类型推导将会失败，代码将不同通过编译： 123456auto x = &#123;1,2,3&#125;; // x的型别是 std::initializer_list&lt;int&gt;template&lt;typename T&gt;void f(ParamType param);f(&#123;1,2,3&#125;) //错误，无法推导T的型别 auto和模板类型推导的唯一区别是，auto会假定用大括号起的初始化表达式是一个std::initialize_list，但是模板型别推导不会。 C++14允许使用auto来说明函数返回值需要推导，而且C++14中的lamba表达式也会在形参中用到auto。然而，这些auto的用法是在使用模板型别推导，而非auto型别推导，所以，带有auto返回值的函数如果需要返回一个大括号起的初始化表达式，是通不过编译的。 1234auto createInitList()&#123; return &#123;1,2,3&#125;; // 错误，无法为&#123;1,2,3&#125;完成型别类型推导&#125; 用auto来指定C++14中lambda式的形参型别时，也不能使用大括号起的初始化表达式 12345678910std::vector&lt;int&gt; v;…auto resetV = [&amp;v](const auto&amp; newValue) &#123; v = newValue; &#125;; // C++14…resetV(&#123; 1, 2, 3 &#125;); // error! can't deduce type // for &#123; 1, 2, 3 &#125; 总结 在一般情况下，auto型别推导和模板型别推导时一模一样的，但是auto型别推导会假定用大括号括起的初始化表达式代表一个std::intializer_list，但是模板型别推导不会 在函数返回值或lambda式的形参中使用auto，意思是使用模板型别推导而非auto型别推导。","categories":[{"name":"effective modern CPP","slug":"effective-modern-CPP","permalink":"https://uyouii.github.io/categories/effective-modern-CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://uyouii.github.io/tags/CPP/"},{"name":"effective modern CPP","slug":"effective-modern-CPP","permalink":"https://uyouii.github.io/tags/effective-modern-CPP/"}]},{"title":"Effective Modern C++ 1 理解模板型别推导","slug":"Effective-Modern-CPP-1-理解模板型别推导","date":"2019-10-27T14:37:41.000Z","updated":"2019-10-27T14:41:33.658Z","comments":true,"path":"2019/10/27/Effective-Modern-CPP-1-理解模板型别推导/","link":"","permalink":"https://uyouii.github.io/2019/10/27/Effective-Modern-CPP-1-理解模板型别推导/","excerpt":"","text":"条款1：理解模版型别推导函数模版形如： 12template&lt;typename T&gt;void f(ParamType param); 一次调用形如： 1f(expr); 编译器会通过expre推导两个型别：一个是T的型别，一个是ParamType的型别，这两个型别通常不一样，因为ParamType通常包含了一些饰词，如const或引用符号等限定词。 T的型别推导结果，不仅仅以来expr的型别，还依赖ParamType的形式。具体分三种情况讨论。 情况1: ParamType是个指针或者引用，但不是个万能引用这种情形下，型别推导会这样运作： 若expr具有引用型别，现将引用部分忽略 对expr的型别和ParamType的型别执行模式匹配，来决定T的型别 例如： 123456789101112template&lt;typename T&gt;void f(T&amp; param); // param是个引用声明变量：int x = 27; // x的类型是intconst int cx = x; // cx的类型是const intconst int&amp; rx = x; // rx是x的型别为const int的引用f(x); // T的类型是int，param的类型是int&amp;f(cx); // T的类型是const int，param的类型是const int&amp;f(rx); // T的类型是const int，param的类型是const int&amp; 由于cx和rx的值都被指明为const ，所以T的型别被推到为const int，从而形参的型别就成了const int&amp;。 当人们向引用型别传入const 对象时，他们期望对该对象保持不可修改的属性，即期望该形参成为const的引用型别。 向持有T&amp;型别的模版传入const对象是安全的：该对象的常量性（constness）会成为T的型别推导结果的组成部分。 而引用性（reference-ness）会在型别推导过程中被忽略。 123456789101112template&lt;typename T&gt;void f(const T&amp; param); // param是个引用声明变量：int x = 27; // 同前const int cx = x; // 同前const int&amp; rx = x; // 同前f(x); // T的类型是int，param的类型是const int&amp;f(cx); // T的类型是int，param的类型是const int&amp;f(rx); // T的类型是int，param的类型是const int&amp; rx的引用性在型别推导过程中是被忽略的。 如果param是个指针，而非引用，运作方式上本质上没有不同。 1234567template&lt;typename T&gt;void f(T* param); // param是个指针int x = 27;const int *px = &amp;x; // px是指到x的指针，类型为 const intf(&amp;x); // T的类型是int，param的类型是int*f(px); // T的类型是const int，param的类型是const int* 情况2: ParamType是个万能引用万能引用的声明型别写作：T&amp;&amp; 如果expr是个左值，T和ParamType都会被推导为左值引用。这个结果具有双重奇特之处：首先，这是在模版类型推导中，T被推导为引用型的唯一情形。其次，尽管在声明时使用的是右值引用语法，它的型别推导结果却是左值引用。 如果expre是个右值，则应用“常规”的规则。 12345678910111213141516template&lt;typename T&gt;void f(T&amp;&amp; param); // param是个万能引用声明变量：int x = 27; // 同前const int cx = x; // 同前const int&amp; rx = x; // 同前f(x); // x是个左值，所以T的型别是int&amp;，param的型别也是int&amp;f(cx); // cx是个左值，所以T的型别是const int&amp; // param的型别也是const int&amp;f(rx); // rx是个左值，所以T的型别是const int&amp; // param的型别也是const int&amp;f(27); // 27是个右值，所以T的型别是int // param就成了int&amp;&amp; 万能引用的推导规则不同于左值引用和右值引用形参。当遇到万能引用时，型别推导类型规则会区分实参是左值还是右值。而非万能引用时从来不会作这样的区分的。 情况3: ParamType既非指针也非引用既非指针，也非引用，就是按值传递了。 12template&lt;typename T&gt;void f(T param); // param是按值传递 无论传入的是什么，param都会是它的一个副本，也即是一个全新的对象。 exper具有引用型别，则忽略其引用部分 忽略引用部分之后，若expre是个const对象，也忽略。如果是一个volatile对象，也忽略。 所以 1234567int x = 27; // 同前const int cx = x; // 同前const int&amp; rx = x; // 同前f(x); // T和prama都是intf(cx); // T和prama都是intf(rx); // T和prama都是int cx和rx代表const值，param仍然不具有const型别，这是合理的。 param是个完全独立于cx和rx存在的对象——是cx和rx的一个副本，cx和rx不能修改不能说明param不能修改。expre的常量性和挥发性（volatileness，若有）可以在推导param的型别时忽略。 重点说明的是，const（和volatile）仅会在按值形参处被忽略。若形参是const的引用或者指针，expre的常量性会在型别推导过程中加以保留。 但是这种情况，expr是一个指到const对象的const指针，且expr按值传递给param： 12345template&lt;typename T&gt;void f(T param);const char* const ptr = \"xxxx\";f(ptr); // 传递类型为 const char * const ptr这个指针自己会按值传递，按照按值传递的规则，ptr的常量性会被忽略，param的型别会被推导为const char*。 即ptr的指向对象的常量性会被保留，但是其自身的常量性会在以复制方式创建新指针param时被忽略。 数组实参数组型别有别于指针型别，很多语境下，数组会退化成指到其首元素的指针。 12345const char name[] = \"xxx\";template&lt;typename T&gt;void f(T param);f(name); 由于数组形参声明会按照他们好像是指针形参那样处理，按值传递给函数模版的数组型别会被推导成指针型别。 在模版f调用中，其型别类型T会被推导成const char* 难点来了，尽管函数无法声明真正的数组类型形参，它们却能够将形参声明成数组的引用。如果修改模版f，制定按照引用的方式传递实参。 123template&lt;typename T&gt;void f(T&amp; param);f(name); // 向f传递一个数组 这种情况下，T的型别会推导成实际数组的型别，这个型别包含数组的尺寸。 本例中，T的型别推导类型结果为 const char [4]，而f的形参被推导为 const char (&amp;)[4]。 可以利用数组引用这一能力创造一个模版，用来推导数组含有的元素个数。 123456// 以编译期常量的形式返回数组尺寸template&lt;typename T, std::size_t N&gt;constexpr std::size_t arraySize( T(&amp;)[N]) noexcept&#123; return N;&#125; 将该函数声明为constexpr，能够使得其返回值在编译期间可用。从而就可以指定一个数组时，制定其尺寸和另一个数组相同。 12int keyVals = &#123;1,2,3,4&#125;;int mappedVals[arraySize(keyVals)]; 函数实参数组并非c++唯一可以退化为指针之物。函数型别也同样可以退化为函数指针，针对数组型别的推导的一切导论适用于函数向其指针的退化。 123456789101112void someFunc(int, double);template&lt;typename T&gt;void f1(T param); // param按值传递template&lt;typename T&gt;void f2(T param); // param按引用传递f1(someFunc); // param被推导为函数指针 // 具体类型为 void(*)(int, double)f2(someFunc); // param被推导为函数引用 // 具体类型为 void(&amp;)(int, double) 总结 在模版类型推导过程中，具有引用类型的实参会被当成非引用类型来处理。即其引用性会被忽略 对万能引用形参进行推导时，左值实参会进行特殊处理 对按值传递的形参进行推导时，若实参中带有const 或 volatile饰词，则它们还是会被当作不带const或volatile饰词的型别来处理 在模版型别推导过程中，数组或函数类型的实参会退化成对应的指针，除非它们被用来初始化引用。","categories":[{"name":"effective modern CPP","slug":"effective-modern-CPP","permalink":"https://uyouii.github.io/categories/effective-modern-CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://uyouii.github.io/tags/CPP/"},{"name":"effective modern CPP","slug":"effective-modern-CPP","permalink":"https://uyouii.github.io/tags/effective-modern-CPP/"}]},{"title":"三体","slug":"三体","date":"2019-08-03T10:18:23.000Z","updated":"2019-08-03T10:19:32.435Z","comments":true,"path":"2019/08/03/三体/","link":"","permalink":"https://uyouii.github.io/2019/08/03/三体/","excerpt":"","text":"三体 那是一个荒凉的山谷，雪山从山谷的尽头露出一抹白；山谷的这一端，半截沧桑的枯木占据几乎三分之一的画面。汪淼在想象中把那个萦绕在他脑海里中的身影叠印到画面上。让她位于山谷的深处，看上去很小很小；这时汪淼惊奇地发现，整个画面苏醒过来，仿佛照片中的世界认出了那个身影，放佛这一切本来就是为她而存在。他又依次在想象中将那个身影叠印到另外几幅作品上，有时还将她那双眼睛作为照片上空旷苍穹的背景，那些画面也都苏醒过来，展现出一种汪淼从未想象过的美。以前，汪淼总觉得自己的摄影作品缺少某种灵魂；现在他知道了，缺的是她。 “那你的生活是一种偶然，世界有这么多变换莫测的因素，你的人生却没什么变故。” “射手”假说：有一名神枪手，在一个靶子上每隔十厘米打一个洞。设想这个靶子的平面上生活着一种二维智能生物，它们中的科学家在对自己的宇宙进行观察后，发现了一个伟大的定律：“宇宙每隔10厘米，必然会有一个洞。”它们把这个神枪手一时兴起的随意行为，看成了自己宇宙的铁律。 “农场主假说” 则有一层令人不安的恐怖色彩：一个农场里有一群火鸡，农场主每天中午十一点来给它们喂食。火鸡中的一名科学家观察到这个现象，一直观察了近一年都没有例外，于是它也发现了自己宇宙的伟大定律：“每天上午十一点，就有食物降临。”它在感恩节早晨向火鸡们公布了这个定律，但这天上午十一点食物没有降临，农场主进来把它们都捉去杀了。 地球生命真的是宇宙偶然里的偶然，宇宙是个空荡荡的大宫殿，人类是这宫殿中唯一的一只小蚂蚁。这想法让我的后半辈子有一种很矛盾的心态：有时觉得生命珍贵，一切都重如泰山；有时又觉得人是那么渺小，什么都不值一提。反正日子就在这种奇怪的感觉中一天天过去，不知不觉人就老了…… 城市就是森林，每一个男人都是猎手，每一个女人都是陷阱。 生活需要平滑，但也需要一个方向，不能总是回到起点。","categories":[{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/categories/bookread/"}],"tags":[{"name":"booknote","slug":"booknote","permalink":"https://uyouii.github.io/tags/booknote/"}]},{"title":"明朝那些事儿","slug":"明朝那些事儿","date":"2019-08-03T10:18:05.000Z","updated":"2019-08-03T10:21:23.054Z","comments":true,"path":"2019/08/03/明朝那些事儿/","link":"","permalink":"https://uyouii.github.io/2019/08/03/明朝那些事儿/","excerpt":"","text":"明朝那些事儿 卷1 这是一个伟大的转变，很多人可能穷其一辈子也无法实现。转变的关键在于心。 对于我们来说，心是最柔弱的地方，它特别容易被伤害，爱情的背叛、亲情的失去·友情的丢失，都将是重重的一击。 是的，即使你拥有人人羡慕的容貌、博览群书的才学、挥霍不尽的财富，也不能证明你的强大。因为心的强大，才是真正的强大。 自古以来，建立一个王朝很难，毁灭一个却相对容易的多，所谓“墙倒众人推，破鼓万人捶”，不是没有道理的。 当愤怒和不满超过了限度，当连狗一样生存下去都成为一种奢望的时候，反抗是唯一的道路。反抗是为了生存。 知道可能面对的困难和痛苦，在死亡的恐惧中不断挣扎，而仍然能战胜自己，选择这条道路，才是真正的勇气。 所以我认为中国历史上的农民起义确实是值得肯定的，他们也许不是那么厚道，他们也许有自己各自的打算，但他们确实别无选择。 一个人要显示自己的力量，从来不是靠暴力，挑战这一准则的人必然会被历史从强者的行列中淘汰，历来如此。 迷信是封建时代人们的通病，要想占有天下，必须要占据王气之地。南京就是这么一个地方，紫金山纵横南北，恰似巨龙潜伏，而石头山则临江陡峭，如虎盘踞，这就是南京龙蟠虎踞的来历。 张士诚和陈友谅，这两个人都是当世之豪杰，如果他们分别出现在不同的朝代，应该都能成就大业，可惜，历史注定要让这个时代热闹一点。这是一场淘汰赛，只有坚持到最后的人才能获得胜利。 张士诚，朱元璋对他有一个精准的评价：器小。这个人确实没有大志向，但他的的确确是个好人，还是个大好人。他生来就沉默寡言，待人宽大，免除了浙江一带的赋税，江浙一带的百姓都受了他的恩惠，纷纷为他修建祠堂。但他的过于宽大和无主见也使得他无法成为枭雄，而只能做一个豪杰。 在战役实施中，只有一个时机是最适合的，能抓住这个时机的，即是天才。 —— 拿破仑 越接近对方的水平，就越了解对方的强大，就会越来越畏惧。当他的畏惧达到极点的时候，也就是他能与对手匹敌的时候！ 毫无疑问，陈友谅是一个传统意义上的坏人，但在那个乱世里，他的行为法则却是当时通用的选择。如果要生存下去，这似乎又是必然的选择，他的错误在于将这种法则发展到了极致，直到走火入魔的地步。迷信暴力，不讲基本的信用使他丧失了人心。但他又是一个真正的枭雄，他坏事做尽，却又敢作敢当（后来的朱元璋也没有能够做到），具有极强的军事和政治才能，反抗元王朝的统治，能够自始至终，从来没有向元王朝妥协，坚持到了最后。从这个角度看，他是条好汉。可惜，在这个乱世里，他只是个枭雄，真正的英雄是朱元璋。 一位著名的历史学家说过，农民两千年的起义只是为了一块土地。不是农民就是地主！别无选择！ 性格决定命运 张士诚是一个有着坚强意志的人，他白手起家，成就一方霸业。但他的缺点和他的优点一样突出，作为乱世群雄中的一个，他走着小富即安的心理，却并不明白，再这样的环境中进行的，只能是淘汰赛，胜利者只有一个。但他是值得敬佩，他意志坚强，反抗元的暴虐统治，虽曾投降过，但毕竟只是权宜之计。在死亡面前毫不畏惧，把自己的信念坚持到了最后一刻。不怕死的人是值得尊敬的。 一个人的气节和尊严正是在最困难的时候体现出来的 常遇春的一生，从太平之战自告奋勇，到北出沙漠，所向无敌，他用自己的行动证明了他是真正的军事天才，是真正的第一先锋。他的生命就像灿烂的流星，虽然短暂，却光耀照人。 朱元璋只是历史的执行者，他并不是历史的创造者。即使没有朱元璋，也会有李元璋、王元璋来完成历史的使命，推翻旧的王朝，建立新的帝国。历史是一个好客的主人，但却从不容许客人取代它的位置。历史也从来就不是一个人或者几个人可以支配创造的。所谓时势造英雄，实乃至理名言。真正支配历史的人，不是朱元璋，是稻田里辛勤劳作的老农，是管道上来往的商贾，是朝堂上进言的官员，是孤灯下孤独的学子。他们中大多数人注定默默无闻，都无法在历史上留下他们的名字，但他们才是历史真正的主人。从古至今，从无例外。","categories":[{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/categories/bookread/"}],"tags":[{"name":"booknote","slug":"booknote","permalink":"https://uyouii.github.io/tags/booknote/"}]},{"title":"Game of Thrones","slug":"Game-of-Thrones","date":"2019-08-03T10:17:50.000Z","updated":"2019-08-03T10:24:45.169Z","comments":true,"path":"2019/08/03/Game-of-Thrones/","link":"","permalink":"https://uyouii.github.io/2019/08/03/Game-of-Thrones/","excerpt":"","text":"Game of Thrones If you would take a man’s life, you owe it to him to look into his eyes and hear his final words. And if you cant bear to do that, then perhaps the man does not deserve to die.","categories":[{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/categories/bookread/"}],"tags":[{"name":"booknote","slug":"booknote","permalink":"https://uyouii.github.io/tags/booknote/"}]},{"title":"百年孤独","slug":"百年孤独","date":"2019-08-03T10:17:38.000Z","updated":"2019-08-03T10:21:04.171Z","comments":true,"path":"2019/08/03/百年孤独/","link":"","permalink":"https://uyouii.github.io/2019/08/03/百年孤独/","excerpt":"","text":"百年孤独 死神一直追随者他的脚步，嗅闻他的行踪，但尚未下定决心给他最后一击。 “世上正发生着不可思议的事情，”他对乌尔苏拉说，“就在那边，在河的另一边，各种魔法机器应有尽有，而我们却还像驴子一样生活。” 蕾梅黛丝在下午两点令人昏昏欲睡的空气中，蕾梅黛丝在玫瑰无声的呼吸中，蕾梅黛丝在清晨面包的热其中，蕾梅黛丝无所不在，蕾梅黛丝无视或缺。 你那么憎恨军人，跟他们斗了这么久，琢磨了他们这么久，最终却变得和他们一样。人世间没有任何理想值得以这样的沉沦作为代价。 约略懂得幸福的晚年秘诀不过是与孤独签下不失尊严的协定罢了。 过去都是假的，回忆没有归路，春天总是一去不复返，最疯狂执着的爱情也终究是过往云烟。","categories":[{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/categories/bookread/"}],"tags":[{"name":"booknote","slug":"booknote","permalink":"https://uyouii.github.io/tags/booknote/"}]},{"title":"情人","slug":"情人","date":"2019-08-03T10:17:30.000Z","updated":"2019-08-03T10:21:29.041Z","comments":true,"path":"2019/08/03/情人/","link":"","permalink":"https://uyouii.github.io/2019/08/03/情人/","excerpt":"","text":"情人 一种可以自由地支配时间的快感和一种怎样来支配这段时间的犹豫往往老是搅和在一起。 男人与女人并不是整天厮守在一起才算幸福，男人女人如果没有共同理想，各自没有独立的能力，很难保持男女间的关系至始至终。 不管怎么爱着这个男人，也不想失去自己一个人时的清静，自己 有属于自己的时间，这是最重要的。 但是人会喜欢上一个人也不是瞎说，世界上就是有着这种不合道理的道理，这要靠每个人的良知与道德修养来做出评判。 我可不是你想象的那样漂亮美丽、心地善良的女人呦。我有人们所具有的假面，在你看到的这假面背后，傲慢、猥琐、任性等等的毛病，我是应有尽有的呢。 男人与女人之间就应该有这么一面不能捅破的隔墙，才能使两人之间的关系保持长久的新鲜感。 也许有人会感到这种关系不太近人情。但是格子生活的全部都相互缠在一起，人生特有的趣味便会淡漠无存。 “请与我结婚吧”这句话，对女人来说都是梦寐以求的，不管她喜不喜欢这个男人。这句话，是绝对能将女人的心彻彻底底地打动地。 情人的地位确实不稳定，但同时却代表着美丽的存在。 忘记日常生活的琐碎杂事，相互体贴，相互慰藉。难得的见面，使双方都将自己的美德表现出来。生日呀，两人初恋的日子呀，每一个有意义的日子，两人都一起过，那样的时刻便是最珍贵，最幸福的。 有不少女人是只愿当情人，不愿做妻子的，这种情人的爱情，不是一生一世，而是一时一刻的。这样才更适合自己，能更自由自在，更能展示自己的魅力。为此而忌讳那种结婚名分的女人并不为少。","categories":[{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/categories/bookread/"}],"tags":[{"name":"booknote","slug":"booknote","permalink":"https://uyouii.github.io/tags/booknote/"}]},{"title":"小王子","slug":"小王子","date":"2019-08-03T10:17:20.000Z","updated":"2019-08-03T10:22:38.572Z","comments":true,"path":"2019/08/03/小王子/","link":"","permalink":"https://uyouii.github.io/2019/08/03/小王子/","excerpt":"","text":"小王子 如果有一个人爱上在这亿万颗星星中仅有的一朵花，这人望着星空的时候，就会觉得幸福。 审判自己，比审判别人难得多。你若是能够公正地审判自己，那你就是一个真正地贤士。 在我看来，你只不过是一个小男孩，跟成千上万地男孩毫无两样。我不需要你，你也不需要我。对你来说我只不过是一只狐狸，跟成千上万的狐狸毫无两样。但是，你如果驯养了我，那么我们俩就彼此相互需要。对我来说，你是世界上独一无二的；我在你看来，也是世界上独一无二的…… 只有用心看，才能看的清楚；本质的东西，眼睛是看不见的。 正是因为你为你的玫瑰，花费了时间，才使你的花儿变得那么重要。 对你驯养的东西，你要永远负责。你必须对你的玫瑰花负责…… “沙漠美丽”，小王子说，“是因为在某个地方藏着一口水井……” 无论是房子、星星或沙漠，使它们美丽的东西是看不见的。 这水，不只是一种饮料，它是从披星戴月地长途跋涉、轱辘的歌声、我的双臂的力量产生出来的。这水，像是一份礼物，使心田得到慰藉。在我小的时候，只有圣诞树的光、子夜弥撒的音乐、甜蜜的微笑，这一切才使得我的圣诞礼物光芒四射。 眼睛是什么也看不见的。应该用心灵去找。 你倘若爱上一朵生长在星星上的花，那么，在夜间，你看看天空就会感到愉快。所有的星星都像盛开的鲜花。 “每个人都有星星，“小王子说，”但在不同的人眼里就是不一样。对旅行者，星星是指引路的。对另一些人，星星只是一些小亮光。对学者，星星是探讨的问题。对我的那个商人，星星是黄金。但是，所有的星星都是一声不响的。你有的那些星星，是别人得不到的！“ ”你夜间仰望星空时，由于我就住在其中的一颗星星上，由于我在其中的一颗星上笑，那么，对你来说，所有的星星仿佛都在笑。唯有你，有一些会笑的星星。“","categories":[{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/categories/bookread/"}],"tags":[{"name":"booknote","slug":"booknote","permalink":"https://uyouii.github.io/tags/booknote/"}]},{"title":"无人生还","slug":"无人生还","date":"2019-08-03T10:16:42.000Z","updated":"2019-08-03T10:22:30.594Z","comments":true,"path":"2019/08/03/无人生还/","link":"","permalink":"https://uyouii.github.io/2019/08/03/无人生还/","excerpt":"","text":"无人生还 直到现在我才明白，艺术家永远不会只满足于创造艺术。他渴望自己的艺术得到世人的青睐，是人性使然。","categories":[{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/categories/bookread/"}],"tags":[{"name":"booknote","slug":"booknote","permalink":"https://uyouii.github.io/tags/booknote/"}]},{"title":"解忧杂货店","slug":"解忧杂货店","date":"2019-08-03T10:16:30.000Z","updated":"2019-08-03T10:21:17.408Z","comments":true,"path":"2019/08/03/解忧杂货店/","link":"","permalink":"https://uyouii.github.io/2019/08/03/解忧杂货店/","excerpt":"","text":"解忧杂货店 他们内心都破了个洞，重要的东西正从那个破洞中流失。人的心声是绝对不能无视的。 很多时候，咨询的人心里已经有个答案，来咨询只是想确认自己的决定是对的。所以有些人读过回信后，会再次写信过来，大概就是因为回答的内容和他的想法不一样吧。 如果自己不想积极乐观的生活，不管得到什么样的回答都没有用。 虽然至今为止的道路绝非一片坦途，但想到正因为或者才有机会感受到痛楚，我就成功克服了种种困难。 人与人之间请以断绝，并不需要什么具体的理由。就算表面上有，也很可能只是心已经离开的结果，事后才编造出的借口而已。因为倘若心没有离开，当将会导致关系破裂的师太发生时，理应有人努力去挽救。如果没有，说明其实关系早已破裂。 可是换个角度来看，正因为是一张白纸，才可以随心所欲地描绘地图。一切全在你自己。对你来说，一切都是自由的，在你面前是无限的可能。这可是很棒的事呀。我衷心祈祷你可以相信自己，无悔地燃烧自己的人生。 话语教给我们很多，但善恶还是可以自明。话语想要教给我们，人与人生来就不平等。在人间，尊卑有序是永恒的真理，但你也可以不听。","categories":[{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/categories/bookread/"}],"tags":[{"name":"booknote","slug":"booknote","permalink":"https://uyouii.github.io/tags/booknote/"}]},{"title":"天才在左，疯子在右","slug":"天才在左，疯子在右","date":"2019-08-03T10:16:15.000Z","updated":"2019-08-03T10:22:22.573Z","comments":true,"path":"2019/08/03/天才在左，疯子在右/","link":"","permalink":"https://uyouii.github.io/2019/08/03/天才在左，疯子在右/","excerpt":"","text":"天才在左，疯子在右 人之所以会产生一些妄想或者说是幻觉，主要是因为大脑不听使唤，左脑接受了来自右脑的错误指令，因而产生了歪曲的理解和判断。 缺乏安全感和孤独寂寞的人最容易出现妄想症，他们最初觉得“没人关系我”，后来演变为“有人要害我”。 视觉对于外界光线的感应能偶帮助我们维持生物钟的正常运转。但如果用光线照射我们的双眼，大脑便会由此“上当”，从而加速或者减缓我们的生理时钟的运转。 “马太效应”是社会心理学的经典效应，他向我们证明了强者恒强、弱者越弱的道理。如果一个人获得了成功，那么随之而来，各种好事情都会发生在他的身上。同样，如果一个人很衰，他就会遇到各种各样衰的事情。 心理学家认为，人的幸或者不幸，并不是上帝在天空中决定并安排好的，实际上一个人的运气好坏是由这个人的行为和思想决定的。 幸运的人通常乐观积极，活力四射，这样的心态让他们对未知的恐惧低于阈值，因为更容易接受新的挑战，更容易抓住新的机遇。 而那些不幸的人则相反，他们多半性格孤僻，反应也不够敏捷。他们的情感关注点更多地集中于自己身上，因此很害怕周遭发生的会让自己感受到不舒服的改变。对他们而言，“未知”便是最大的恐惧和不安，处于恐惧中时，他们便会与大好的机会擦肩而过。 自我监控能力强的人显然更容易成为撒谎高手，而这种能力较弱的人，似乎用撒谎来掩饰自己的意识较差。 六度分隔假说，其含义是世界上任意两个欲取得联系的陌生人之间，最多只隔着六个人，便能够达成联系。 越是急于证明自己，就越是证明不了。因为没有人愿意跟着你的思路去思考问题。 车尔尼雪夫斯基说：“在人间有什么会更有诗意，更为迷人，胜于那怀着欢乐的爱，对自己觉得像自己本身一样崇高、纯洁和美妙的一切东西都发生共鸣的纯真的纯真的少年心灵呢？” 童年对一个作家的影响是深入骨髓的，是融贯在灵魂中的，同年是我们的精神故乡，同年所遭受的创伤会让人铭记在心。创伤在灵魂的深处生了根，就好像在土地中播撒了种子般，在岁月流逝中，种子逐渐发芽、长出了树枝，成长为参天大树，然而其根基仍然是当初的种子，是由幼时的创伤繁衍出来的。创伤及由此而形成的思想就由此成为作家作品的内核。 有人曾这样描述弗吉尼亚.伍尔夫：“她的记忆有着隐秘的两面——一面澄清，一面黑暗；一面寒冷，一面温热；一面创造，一面是毁灭；一面铺洒着天堂之光，一面燃烧着地狱之火。","categories":[{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/categories/bookread/"}],"tags":[{"name":"booknote","slug":"booknote","permalink":"https://uyouii.github.io/tags/booknote/"}]},{"title":"人间失格","slug":"人间失格","date":"2019-08-03T10:15:54.000Z","updated":"2019-08-03T10:21:44.528Z","comments":true,"path":"2019/08/03/人间失格/","link":"","permalink":"https://uyouii.github.io/2019/08/03/人间失格/","excerpt":"","text":"人间失格 那是我对人类最后的求爱。我对人类极度恐惧，却无论如何也无法对人类死心。 旁人承受的痛苦的性质和大小，我完全捉摸不透。现实生活中的痛苦，只是吃个饭就能化解的痛苦，或许才是莫大的痛苦。也许，我刚才所说的那十个灾祸在这些痛苦面前不值一提。也许那些我无法理解的痛苦才是凄惨的阿鼻地狱。果真如此嘛？我不知道。但即使如此，那些人依然不想轻生、不会发狂，纵谈政治、毫不绝望、毫不屈服，继续与生活作战。他们不觉得痛苦吗？他们变得自私自利，甚至视其为理所当然，难道他们从未怀疑过自己？若真如此，那真是快活。不是每个人都是如此吧？真的都满足于此吗？我不知道······在夜里酣然入睡，一早醒来就会神清气爽吗？他们做了怎样的梦？走路时想些什么？想着钱的事情？不会仅此而已吧？我似乎听过说“民以食为天”，却从未听过“人为钱而活”。不，也许因人而异吧······我还是搞不懂······思绪渐感困惑之时，我越发惶恐不安，仿佛自己是这个世界上的异类。我与旁人几乎无法交谈，因我不知该谈些什么，也不知该如何谈起。 因此我总是黯然接收外界打击，内心却承受着疯狂的恐惧。 受人责备或怒斥时，或许没有人能保持好心情。但我在人们怒不可遏的脸上，看到了比狮子、鳄鱼、巨龙更加可怕的动物本性。寻常时候，他们似乎会将这一本性刻意隐藏，但一有机会，人类可怕的真面目就会在愤怒中不经意的暴露出来。就像在草地上安稳打盹的牛，冷不防甩尾吗“啪”地打死肚子上地牛虻。每每见到人类露出本性，我都惊悚得汗毛倒竖。而一旦想到，这种本性或许是人活于世的必备资质之一，我简直要对自己绝望了。 对讨厌的事物说不出讨厌，对喜欢的事也总是偷偷摸摸，我总是品着极为苦涩的滋味，困难以名状的恐惧痛苦挣扎。 我一向对“向人诉苦”不抱任何期待。无论是向父母说，还是向警察或者政府说，最终还是会被那些深谙处世之道的人打败，任由他们花言巧语，喋喋不休。 相互欺骗的双方竟然都相安无事，甚至未曾察觉相互欺骗之事————我以为，人类生活中无处不是这样单纯、明了的不信任之举。 对人类极度恐惧的人，反而会比任何人都渴望亲眼见识妖怪的可怕。愈是敏感、愈是胆怯，愈会企盼暴风雨降临的更加猛烈。 对我而言，听女人就自己的身世说上千言万语，也不及一句低喃让我心生共鸣。我是如此期盼听到这句低语，然而我在这世上遇到的女子，竟没有一人向我如此诉说，我深感不可思议。眼前这名女子，虽然没有用言语变现自己的寂寞，但整个身体的轮廓却无声地吐露出巨大地寂寞气息。她的身旁仿佛充斥着约莫一寸见方的气流，走近她身旁，我的身体也被那气流说包裹。这气流与我自身携带的阴郁气流完美的融合，如贴在水底岩石上的枯叶一般，是我得以从恐惧与不安中抽离。 胆小鬼连幸福都会害怕，碰到棉花都会受伤，有时还会被幸福所伤。","categories":[{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/categories/bookread/"}],"tags":[{"name":"booknote","slug":"booknote","permalink":"https://uyouii.github.io/tags/booknote/"}]},{"title":"神们自己","slug":"神们自己","date":"2019-08-03T10:15:44.000Z","updated":"2019-08-03T10:22:15.393Z","comments":true,"path":"2019/08/03/神们自己/","link":"","permalink":"https://uyouii.github.io/2019/08/03/神们自己/","excerpt":"","text":"神们自己 历史往往就是由这些讨厌而且毫无目的的冲动推动的。 有人认为，公众希望环境得以保护，人类的存续得以实现，还认为那些为了这类崇高目标而奋斗的理想主义者会得到公众的爱戴，这种想法都是错的。实际上，公众所期望的只有一件事：他们自己过上安逸舒适的生活。通过二十世纪的环境危机，我们早就看明白了。当人们知道吸烟会导致患癌症的几率上升而最有效的解决办法就是禁烟时，他们却希望能够发明一种不致癌的香烟。当人们知道内燃机会对大气造成污染而最好的办法就是不再使用这类引擎时，他们却希望能够发明不污染空气的引擎。 “他们只需要拒绝相信就行。面对难题，最容易的对策就是拒绝相信它的存在。” 凡是对自己有一点利益就会选择相信。有时候即使毫无可能，人们也会顽冥不化。","categories":[{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/categories/bookread/"}],"tags":[{"name":"booknote","slug":"booknote","permalink":"https://uyouii.github.io/tags/booknote/"}]},{"title":"07 进程环境","slug":"07-进程环境","date":"2019-08-03T10:11:23.000Z","updated":"2019-08-03T10:12:14.692Z","comments":true,"path":"2019/08/03/07-进程环境/","link":"","permalink":"https://uyouii.github.io/2019/08/03/07-进程环境/","excerpt":"","text":"[TOC] 进程环境main函数c程序总是从main函数开始执行。 当内核执行C程序时（使用一个exec函数），在调用mian函数前先调用一个特殊的启动例程。启动例程从内核取得命令行参数和环境变量值。 进程终止有8种方式使进程终止(termination)，其中5种为正常终止，它们是： 从mian返回 调用exit 调用_exit或_Exit 最后一个线程从其启动例程返回 从最后一个线程调用pthread_exit 异常终止有3种方式： 调用abort 接到一个信号 最后一个线程对取消请求做出响应 退出函数12345678#include &lt;stdlib.h&gt;void exit(int status);void _Exit(int status);#include &lt;unistd.h&gt;void _exit(int status); 3个函数用于正常终止一个程序：_exit和_Exit立即进入内核，exit则先执行一些清理处理，然后返回内核。 exit函数总是执行一个标准I/O库的清理关闭操作；对于所有打开流调用fclose函数。这造成输出缓冲中所有的数据都被冲洗（写到文件上）。 3个推出函数都带一个整型参数，称为终止状态（或 退出状态，exit status）。大多数UNIX系统shell都提供检查进程终止状态的方法。如果(a)调用这些函数时不带终止状态，或(b)main执行了一个无返回值的return语句，或(c)main没有声明返回类型为整型，则该进程的终止状态是为定义的。 但是若main的返回类型是整型，并且mian执行到最后一条语句时返回（隐式返回），那么该进程的终止状态是0。 函数atexit按照ISO C的规定，一个进程可以登记至多32个函数，这些函数将由exit自动调用。这些函数为终止处理程序（exit handler），并调用atexit函数来登记这些函数。 如果程序调用exec族中的任一函数，则将清除已安装的所有终止处理程序。 c程序的储存空间布局 典型储存空间安排 c语言一直由一下几个部分组成： 正文段。这是CPU执行机器指令的部分。通常，正文段是可以共享的，所以即使是频繁执行的程序，在储存器中也只需要有一个副本，而且正文段通常是只读的，以防止程序由于意外而修改其指令。 初始化数据段。通常将此段称为数据段，它包含了程序中需明确地赋初值的变量。例如，C程序中任何函数之外的声明: 1int maxcount = 99; 未初始化数据段。通常将此段称为bss段，这一名称来源于早期汇编程序一个操作符，意思是“由符号开始的块”（block started by symbol），在程序开始执行之前，内核讲此段中的数据初始化为0或空指针。函数外的声明： 1long sum[1000]; 使此变量存放在非初始化数据段中。 栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。每次函数调用时，其返回地址以及调用者的环境信息（如某些机器寄存器的值）都存放在栈中。然后，最近被调用的函数在栈上为其自动和临时变量分配储存空间。 堆。通常在堆中进行动态内存分配。 对于32位Intel x86处理器上的linux，正文段从0x04048000单元开始，栈底则在0xC0000000之下开始。堆顶和栈顶之间未用的虚地址空间很大。 未初始化数据段的内容并不存放在磁盘文件中。其原因是，内核在程序开始运行前将它们都设置为0。需要存放在磁盘程序文件中的段只有正文段和初始化数据段。 共享库大多数UNIX系统支持共享库。 共享库时的可执行文件中不再需要包含公共的库函数，而只需在所有进程都可引用的储存区中保存这种库例程的一个副本。 程序第一次执行或者第一次调用某个库函数时，用动态链接方法将程序与共享库函数相链接。 这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时，或者每个共享库函数第一次被调用时。 共享库的另一个有点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑。 储存空间分配ISO C 说明了3个用于储存空间分配的函数。 malloc，分配指定字节数的储存区。此储存区中的初始值不确定。 calloc，为指定数量指定长度的对象分配储存空间。该空间中的每一位(bit)都初始化为0。 realloc，增加或减少以前分配区的长度。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，以便在尾端提供增加的储存区，而新增区域内的初始值则不确定。 函数free释放ptr指向的储存空间。被释放的空间通常被送入可用储存区池，以后再调用上述3个函数时再分配。 这些分配例程通常用sbrk(2)系统调用实现。该系统调用扩充（或缩小）进程的堆。 虽然sbrk可以扩充或者缩小进程的储存空间，但是大多数malloc和free的实现都不减小进程的储存空间。释放的空间可供以后再分配，但将它们保持在malloc池中而不返回给内核。 大多数实现说分配的储存空间比所要求的稍微大一些，额外的空间用来记录管理信息————分配块长度、指向下一个分配块的指针等。","categories":[{"name":"Unix环境高级编程","slug":"Unix环境高级编程","permalink":"https://uyouii.github.io/categories/Unix环境高级编程/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://uyouii.github.io/tags/linux/"},{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/tags/bookread/"},{"name":"Unix环境高级编程","slug":"Unix环境高级编程","permalink":"https://uyouii.github.io/tags/Unix环境高级编程/"}]},{"title":"19 进程通信","slug":"19-进程通信","date":"2019-08-03T10:04:14.000Z","updated":"2019-08-03T10:12:53.203Z","comments":true,"path":"2019/08/03/19-进程通信/","link":"","permalink":"https://uyouii.github.io/2019/08/03/19-进程通信/","excerpt":"","text":"进程通信System V IPCIPC 共享内存共享内存机制允许两个或多个进程通过把公共数据结构放入一个共享内存区(IPC shared memory region)来访问它们。如果进程要访问这种存放在共享内存区的数据结构，就必须在自己的地址空间中增加一个新内存区，它将映射与这个共享内存区相关的页框。这样的页框可以很容易地由内核通过请求调页进行处理。 调用shmget()函数来获得一个共享内存地IPC标识符，如果这个共享内存区不存在，就创建它。 调用shmat()函数把一个共享内存区”附加(attach)”到一个进程上。该函数使用IPC共享内存资源地标识符作为参数，并试图把一个共享内存加入到调用进程的地址空间中。调用进程可以获得这个内存区域的起始线性地址，但是这个地址通常不重要，访问这个共享内存区的每个进程都可以使用自己地址空间中的不同地址。shmat()函数不修改进程的页表。 调用shmdt()函数来”分离“由IPC标识符所指定的共享内存区域，也就是说把响应的共享内存区域从进程的地址空间删除。IPC共享内存资源是持久的，即使现在没有进程在使用它，相应的页也不能被丢弃，但是可以被换出。 IPC共享内存数据结构 shmid_kernel数据结构中的字段 类型 字段 说明 struct kern_ipc_perm shm_perm kern_ipc_perm数据结构 struct file * shm_file 共享段的特殊文件 int id 共享段的位置索引 unsigned long shm_nattch 当前附加的内存区数 unsigned long shm_segsz 内存区字节数 time_t shm_atim 最后访问时间 time_t shm_dtim 最后分离时间 time_t shm_ctim 最后修改时间 pid_t shm_cprid 创建者的PID pid_t shm_lprid 最后访问进程的PID struct user_struct * mlock_user 锁定在共享内存RAM中的用户的user_struct描述符的指针 字段shm_file是存放文件对象的地址。Linux 2.6中IPC共享内存与VFS紧密结合。每个IPC共享内存区与属于shm特殊文件系统的一个普通文件关联。 因为shm文件系统在系统目录中没有安装点，因此，用户不能通过普通的VFS系统调用打开并访问它的文件。但是，只要进程”附加”一个内存段，内核就调用do_mmap()，并在进程的地址空间创建文件的一个新的共享内存映射。因此，属于shm特殊文件系统的文件只有一个文件对象方法mmap，该方法是由shm_mmap()函数实现的。 对于任何共享内存映射，通过address_space对象把页框包含在页高速缓存中，而address_space对象包含在索引节点中而且被索引节点的i_mapping字段引用。万一页框属于IPC共享内存区，address_space对象的方法就存放在全局变量shmem_aops中。 换出IPC共享内存区的页因为IPC共享内存区映射的是在磁盘上没有映像的特殊索引节点，因此其页是可交换的。因此为了回收IPC共享内存区的页，内核必须把它写入交换区。因为IPC共享内存区是持久的——也就是说内存段不附加到进程，也必须保留这些页。因此即使这些页没有进程在使用，内核也不能简单地删除它们。 … IPC共享内存区的请求调页通过shmat()加入进程的页都是哑元页(dummy page)；该函数把一个新内存区加入一个进程地址空间中，但是它不修改进程的页表。IPC共享内存区的页可以被换出。因此，可以通过请求调页机制来处理这些页。 当进程试图访问IPC共享内存区的一个单元，而其基本的页框还没有分配时则发生缺页异常。相应的异常处理程序确定引起的缺页的地址是在进程的地址空间内，且相应的页表项为空；因此，它就调用do_no_page()函数。这个函数又检查是否为了这个内存区定义了nopage方法。然后调用这个方法，并把页表项设置成所返回的地址。 IPC共享内存所使用的内存区通常定义了nopage方法。这是通过shmem_nopage()函数实现的，该函数执行以下操作： 遍历VFS对象的指针链表，并导出IPC共享内存资源的索引节点对象的地址。 从内存区域描述符的vm_start字段和请求的地址计算共享内存内的逻辑页号 检查页是否已经在交换高速缓存中，如果是，则结束并返回描述符的地址 检查页是否在交换高速缓存内且是否最新，如果是，则结束并返回该描述符地址。 检查内嵌在索引节点对象的shmem_inode_info是否存放着逻辑页号对应的换出页标识符。如果是，就调用read_swap_cache_async()执行换入操作，并一直等到数据传送完成，然后结束并返回页描述符的地址。 否则，页不在交换区中；因此就从伙伴系统中分配一个新页框，把它插入到页高速缓存，并返回它的地址。 do_no_page()函数对引起缺页的地址在进程的页表中所对应表项进行设置，以使该函数指向nopage方法返回的页框。","categories":[{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/categories/深入理解Linux内核/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://uyouii.github.io/tags/linux/"},{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/tags/bookread/"},{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/tags/深入理解Linux内核/"}]},{"title":"17 回收页框","slug":"17-回收页框","date":"2019-08-03T10:04:05.000Z","updated":"2019-08-03T10:12:50.401Z","comments":true,"path":"2019/08/03/17-回收页框/","link":"","permalink":"https://uyouii.github.io/2019/08/03/17-回收页框/","excerpt":"","text":"回收页框页框回收算法Linux内核的页框回收算法(page frame reclaiming algorithm, PFRA)采取从用户态进程和内核高速缓存”窃取“页框的办法补充伙伴系统的空闲链表。 选择目标页FPRA按照页框所含内容，可以区分成：不可回收页、可交换页、可同步页和可丢弃页。 页类型 说明 回收操作 不可回收页 空闲页(包含在伙伴系统列表中)保留页(PG_reserved标志置位)内核动态分配页进程内核态堆栈页临时锁定页(PG_locked标志置位)内存锁定页(在线性区中且VM_LOCKED标志置位) 不允许也无需回收 可交换页 用户态地址空间的匿名页tmpfs文件系统的映射页(如IPC共享内存的页) 将页的内容保存在交换区 可同步页 用户态地址空间的映射页存有磁盘文件数据且在页高速缓存中的页块设备缓冲页某些磁盘高速缓存的页(如索引节点高速缓存) 必要时，与磁盘映像同步这些页 可丢弃页 内存高速缓存中的未使用页(如slab分配器高速缓存)目录项高速缓存的未使用页 无需操作","categories":[{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/categories/深入理解Linux内核/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://uyouii.github.io/tags/linux/"},{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/tags/bookread/"},{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/tags/深入理解Linux内核/"}]},{"title":"12 虚拟文件系统","slug":"12-虚拟文件系统","date":"2019-08-03T10:03:55.000Z","updated":"2019-08-03T10:12:47.441Z","comments":true,"path":"2019/08/03/12-虚拟文件系统/","link":"","permalink":"https://uyouii.github.io/2019/08/03/12-虚拟文件系统/","excerpt":"","text":"虚拟文件系统虚拟文件系统（VFS）的作用虚拟文件系统(Virtual Filesystem)也可以称之为虚拟文件系统转换(Virtual Filesystem Switch, VFS)，是一个内核软件层，用来处理于Unix标准文件系统相关的所有系统调用。 VFS支持的文件系统可以划分为三种主要类型： 磁盘文件系统 这些文件系统管理在本地磁盘分区中可用的储存空间或者其他可以起到磁盘作用的设备（比如说一个USB闪存） 网络文件系统 这些文件系统允许轻易地访问属于其他网络计算机的文件系统所包含的文件。 特殊文件系统 这些文件系统部管理本地或者远程磁盘空间。/proc文件系统是特殊文件系统的一个典型范例。 Unix目录建立了一颗根目录为”/“的树。根目录包含在文件系统(root filesystem)中，在Linux中这个跟文件系统通常是Ext2或Ext3类型。其他所有文件系统都可以被”安装“在根文件系统的子目录中。 基于磁盘的文件系统通常放在硬件设备中，如硬盘、软盘或者CD-ROM。 通用文件模型VFS所隐含的主要思想在于引入一个通用的文件模型(common file model)，这个模型能够表示所有支持的文件系统。不过，要实现每个具体的文件系统，必须将其物立组织结构转换为虚拟文件系统的通用文件模型。 从本质上说，Linux内核不能对一个特定的函数进行硬编码来执行诸如read()或ioctl()这样的操作，而是对每个操作都必须使用一个指针，指向要访问的具体文件系统的适当函数。 通用文件模型由下列对象组成： 超级块对象(superblock object) 存放已安装文件系统的有关信息。对基于磁盘的文件系统，这类对象通常对于存放在磁盘上的文件系统控制块(filesystem control block) 索引节点对象(inode object) 存放关于具体文件的一般信息。对于基于磁盘的文件系统，这类对象通常对应于存放在磁盘上的文件控制块(file control block)。每个索引节点对象都有一个索引节点号，这个节点号唯一地标识文件系统中的文件。 文件对象(file object) 存放打开文件与进程之间进行交互的有关信息。这类信息仅当进程访问文件期间存在内核内存中。 目录项对象(dentry object) 存放目录项（也就是文件的特定名称）与对应文件进行链接的有关信息。每个磁盘文件系统都以自己特有的方式将改类信息存放在磁盘上。 进程与VFS对象之间的交互 例如：三个不同的进程已经打开同一个文件，其中两个进程使用同一个硬链接。在这种情况下，每个进程都使用自己的文件对象，但只需要两个目录项对象，每个硬链接对应一个目录项对象。这两个目录项对象指向同一个索引节点文件，该索引节点对象标识超级块对象，以及随后的普通磁盘文件。 最近最常使用的目录项被存放在所谓目录项高速缓存 (dentry cache)的磁盘高速缓存中，以加速从文件路径名到最后一个路径分量的索引节点的转换过程。 一般来说，磁盘高速缓存(disk cache)属于软件机制，它允许内核将原本存在磁盘上的某些信息保存在RAM中，以便这些数据得的进一步访问能快速进行，而不必慢速访问磁盘本身。 磁盘高速缓存不同于硬件高速缓存或内存高速缓存，后两者都与磁盘或者其他设备无关。硬件高速缓存是一个快速静态RAM，它加快了直接对慢速动态RAM的请求。内存高速缓存是一种软件机制，引入它是为了绕过内核内存分配器。 除了目录项高速缓存和索引节点高速缓存之外，Linux还使用其他磁盘高速缓存。其中最重要的一种就是页高速缓存。 VFS数据结构超级块对象所有超级块对象都以双向循环链表的形式链接在一起。","categories":[{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/categories/深入理解Linux内核/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://uyouii.github.io/tags/linux/"},{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/tags/bookread/"},{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/tags/深入理解Linux内核/"}]},{"title":"09 进程地址空间","slug":"09-进程地址空间","date":"2019-08-03T10:03:45.000Z","updated":"2019-08-03T10:12:44.375Z","comments":true,"path":"2019/08/03/09-进程地址空间/","link":"","permalink":"https://uyouii.github.io/2019/08/03/09-进程地址空间/","excerpt":"","text":"进程地址空间内核中的函数总是以相当直接了当的方式获得动态内存，这是通过调用以下几种函数中的一个达到的：__get_free_pages()或者alloc_pages()从分区页框分配器中获得页框，kmem_cache_alloc()或kmalloc()使用slab分配器为专用或通用对象分配块，而vmalloc()或vmalloc_32()获得一块非连续的内存区。如果所请求的内存区得以满足，这些函数都返回一个页描述符地址或线性地址（即所分配动态内存区的起始地址）。 使用这些简单方法基于以下两个原因： 内核是操作系统中优先级最高的成分。如果某个内核函数请求动态内存，那么，必定有正当的理由发出那个请求，因此，没有道理试图推迟这个请求。 内核信任自己。所有的内核函数都被假定是没有错误的，因此内核函数不必插入针对编程错误的任何保护措施。 当给用户态分配内存时，情况完全不同： 进程对动态内存的请求被认为是不紧迫的。一般来说，内核总是尽量推迟给用户态进程分配动态内存。 由于用户进程是不可信任的，因此，内核必须能随时准备捕获用户态进程引起的所有寻址错误。 内核使用了一种新的资源实现了对进程动态内存的推迟分配。当用户态进程请求动态内存时，并没有获得请求的页框，而仅仅获得对一个新的线性区间的使用权，而这一线性地址空间成为进程地址空间的一部分。这一区间叫做“线性区”(memory region) 进程的地址空间进程的地址空间（address space）由允许进程使用的全部线性地址组成。 内核通过所谓线性区资源来表示线性地址空间，线性区是由起始线性地址、长度和一些访问权限来描述的。为了效率起见，其实地址和线性区的长度都必须是4096的倍数，以便每个线性区所识别的数据完全填满分配给它的页框。 获得新线性区的一些典型情况： 当用户在控制台输入一条命令时，shell进程创建一个新的进程去执行这个命令。结果是一个全新的地址空间分配给了新进程。 正在运行的进程有可能决定装入一个完全不同的程序。在这种情况下，进程标识符仍然保持不变，可是在装入这个程序以前所使用的线性区却被释放，并有一组新的线性区分配给这个进程。 正在运行的进程可能对一个文件（或它的一部分）执行“内存映射”。在这种情况下，内核给这个进程分配一个新的线性区来映射这个文件。 进程可能持续向它的用户态堆栈增加数据，直到映射这个堆栈的线性区用完为止。在这种情况下，内核也许会决定扩展这个线性区的大小。 进程可能创建一个IPC共享线性区来与其他合作进程共享数据。在这种情况下，内核给这个进程分配一个新的线性区以实现这个方案。 进程可能通过调用类似malloc()这样的函数扩展自己的动态区(堆)。结果是，内核可能决定扩展给这个堆分配的线性区。 系统调用 说明 brk() 改变进程堆的大小 execve() 装入一个新的可执行文件，从而改变进程的地址空间 _exit() 结束当前进程并撤销它的地址空间 fork() 创建一个新的进程，并为它创建新的地址空间 mmap(), mmap2() 为文件创建一个内存映射，从而扩大进程的地址空间 mremap() 扩大或缩小线性区 remap_file_pages() 为文件创建非线性区映射 munmap() 撤销对文件的内存映射，从而缩小进程的地址空间 shmat() 创建一个共享线性区 shmdt() 撤销一个共享线性区 内存描述符与进程地址空间的全部信息都包含在一个叫做内存描述符(memory descriptor)的数据结构中，这个结构类型为mm_struct，进程描述符的mm字段就指向这个数据结构。 所有的内存描述符存放在一个双向链表中。 内核线程的内存描述符内核线程仅运行在内核态，因此，它们永远不会访问低于TASK_SIZE（等于PAGE_OFFSET，通常为0xc0000000）的地址。与普通进程相反，内核线程不用线性区，因此，内存描述符的很多字段对内核线程都是没有意义的。 因为大于 TASK_SIZE线性地址的相应页表项都应该总是相同的，因此，一个内核线程到底使用了什么样的页表集根本就没有什么关系。为了避免无用的TLB和高速缓存的刷新，内核线程使用一组最近运行的普通进程的页表。结果，在每个进程描述符中包含了两种内存描述符指针： mm和active_mm。 … 线性区Linux通过类型为vm_area_struct的对象实现线性区。 进程所拥有的线性区从来不重叠，并且内核尽力把新分配的线性区与紧邻的现有线性区进行合并。如果两个相邻区的访问权限相匹配，就能把它们合并到一起。 增加或删除一个线性区地址空间 线性区数据结构进程所拥有的所有线性区是通过一个简单的链表链接在一起的。出现在链表中的线性区是按内存地址的升序排列的；不过，每两个线性区可以由未用的内存地址隔开。 每个vm_area_struct元素的vm_next字段指向链表的下一个元素。内核通过进程的内存描述符的mmp字段来查找线性区，其中mmap字段指向链表中的第一个线性区描述符。 内存描述符的map_count字段存放进程所拥有的线性区数目。 与进程地址相关的描述符 Linux2.6把内存描述符同时放在红黑树中。 为了存放进程的线性区，Linux既使用了链表，也使用了红黑树。这两种数据结构包含指向同一线性区描述符的指针，当插入或删除一个线性区描述符时，内核通过红黑树搜索前后元素，并用搜索结果快速更新链表而不用扫描链表。 一般来说，红黑树用来确定含有指定地址的线性区，而链表通常在扫描整个线性区集合时来使用。 分配线性区地址空间do_mmap()函数为当前进程创建并初始化一个新的线性区。分配成功之后，可以把这个新的饿线性区与进程已有的其他线性区进行合并。 do_mmap()函数使用下面的参数： file和offest：如果新的线性区把一个文件映射到内存，则使用文件描述符指针file和文件偏移量offset。 addr：这个线性地址指定从何处开始查找一个空闲的区间。 len：线性地址区间的长度 prot：这个参数指定这个线性区所包含页的访问权限。 flag：这个参数指定线性区的其他标志。 MAP_SHARED和MAP_PRIVATE：前一个标志指定线性区中的页可以被几个进程共享；后一个标志作用相反。这两个标志都与vm_area_struct描述符中的VM_SHARED标志有关。 MAP_FIXED：区间的起始地址必须是由参数addr所指定的。 MAP_ANONYMOUS：没有文件与这个线性区相关联 MAP_NORESERVE：函数不必预先检查空闲页框的数目 MAP_POPULATE：函数应该为线性区建立的映射提前分配需要的页框。该标志仅对映射文件的线性区和IPC共享的线性区有意义。 MAP_NONBLOCK：只有在MAP_POPULATE标志置位时才有意义：提前分配页框时，函数肯定不会阻塞。 do_mmap()函数对offset的值进行检查，然后执行do_mmap_pgoff()函数。这里仅对匿名线性区的实现进行讨论： 检查参数是否正确，主要检查以下条件 线性区地址区间的长度为0或者包含的地址大于TASK_SIZE 进程已经映射了过多的线性区，因此mm内存描述符的map_count字段的值超过了允许的范围 flag参数指定的新线性区地址区间的页必须被锁在RAM中，但不允许进程创建上锁的线性区，或者进程加锁页的总数超过了保存在进程描述符signal-&gt;rlim[RLIMIT_MENLOCK].rlim_cur字段中的阈值。 如果以上情况中的任何一个成立，则do_mmap_pgoff()函数终止并返回一个负值。如果线性区的地址空间长度为0，则函数不执行任何操作就返回。 调用get_unmapped_area()获得新线性区的线性地址区间 通过把存放在prot和flags参数中的值进行组合来计算新线性区描述符的标志。 调用find_vma_prepare()确定处于新区间之前的线性区对象的位置，以为在红黑树中线性区的位置。 1234567for(;;) &#123; vma = find_vma_perpare(mm, addr, &amp;prev, &amp;rb_link, &amp;rb_parent); if(!vma || vma-&gt;vm_struct &gt;= addr + len) break; if(do_mummap(mm, addr, len)) return -ENOMEM;&#125; find_vma_prepare()函数也检查是否还存在与新区间重叠的线性区。如果返回一个非空的地址，这个地址指向一个线性区，而该区的起始位置位于新区间结束地址之前的时候。这种情况下，do_mmap_pgoff()调用do_munmap()删除新区间，然后重复这个步骤。 检查插入新的线性区是否引起进程地址空间的大小（mm-&gt;total_vm &lt; PAGE_SHIFT) + len）超过存放在进程描述符signal-&gt;flim[RLIMIT_AS].rlim_cur字段中的阈值。如果是，就返回出错码-ENOMEM。 如果在flags参数中没有设置MAP_NORESERVE标志，新的线性区包含私有可写页，并且没有足够的空闲页框，则返回出错码-ENOMEM；这最后一个检查是由security_vm_enough_memory()函数实现的。 如果新区间是私有的（没有设置VM_SHARED），且映射的不是磁盘上的一个文件，那么，调用vma_merge()检查前一个线性区是否可以以这样的方式进行扩展来包含新区间。要求前一个线性区必须与在vm_flags局部变量中存放标志的那些线性区具有完全相同的标志。如果前一个线性区可以扩展，那么，vma_merge()页试图把它与随后的线性区进行合并。一旦扩展前一个线性区成功，则跳转到第12步。 调用slab分配函数kmem_cheche_alloc()为新线性区分配一个vm_area_struct数据结构。 初始化新的线性区对象。 如果MAP_SHARED标志被设置（以及新的线性区不映射磁盘上的文件），则该线性区是一个共享匿名区；调用shmem_zero_setup()对它进行初始化。共享匿名区主要用于进程间通信。 调用vma_link()把新线性区插入到线性区链表和红黑树中。 增加存放在内存描述符total_vm字段中的进程地址空间大小。 如果设置了VM_LOCKED标志，就调用make_pages_present()连续分配线性区的所有页，并把它们锁在RAM中。 最后，函数通过返回新线性区的线性地址而终止。 释放线性区地址空间内核使用do_mummap()函数从当前进程的地址空间中删除一个线性地址区间。参数为：进程内存描述符的地址mm，地址区间的起始地址strat和它的长度len。要删除的区间并不总是对应一个线性区，它或许是一个线性区的一部分，或许跨越两个或多个线性区。 do_munmap()函数该函数经过两个主要的阶段。第一阶段，扫描进程所拥有的线性区链表，并把包含在进程地址空间的线性地址空间中的所有线性区从链表中解除链接。第二阶段，更新进程的页表，并把第一阶段找到并标识出的线性区删除。函数利用稍后要说明的split_vma()和unmap_region()函数。do_munmap()执行下面的步骤： 对参数值进行一些初步检查：如果线性地址区间所含的地址大于TASK_SIZE，如果start不是4096的倍数，或者线性区地址区间的长度为0，则函数返回一个错误代码-EINVAL。 确定要删除的线性区地址区间之后的第一个线性区mpnt的位置(mpnt-&gt;end &gt; start)，如果有这样的线性区： 1mpnt = find_vma_prev(mm, start, &amp;prev); 如果没有这样的线性区，也没有与线性区间重叠的线性区，就什么都不做： 123end = start + len;if(!mpnt || mpnt-&gt;vm_start &gt;= end) return 0; 如果线性区的起始地址在线性区mpnt内，就调用split_vma()把线性区mpnt划分为两个较小的区；一个区在线性区间外部，而另一个在区间内部。 12345if(start &gt; mpnt-&gt;vm_start) &#123; if(split_vma(mm, mpnt, start, 0)) return -ENOMEM; prev = mpnt;&#125; 更新局部变量prev，以前它存储的是指向线性区mpnt前面一个线性区的指针，现在要让它指向mpnt，即指向线性地址区间外部的那个新线性区。prev仍然指向要删除的第一个线性区前面的那个线性区。 如果线性区地址区间的结束地址在一个线性区内部，就再次调用split_vma()把最后重叠的那个线性区划分成两个较小的区：一个区在线性区地址区间的内部，而另一个在区间外部。 12345last = find_vma(mm, end);if(last &amp;&amp; end &gt; last-&gt;vm_start) &#123; if(split_vma(mm, last, start, end , 1)) return -ENOMEM;&#125; 更新mpnt的值，使它指向线性地址区间的第一个线性区。如果prev为NULL，即没有上述线性区，就从mm-&gt;mmap获得第一个线性区的地址： 1mpnt = prev ? prve-&gt;vm-&gt;next : mm-&gt;mmap; 调用detach_vmas_to_be_unmaped()从进程的线性地址空间中删除位于线性地址区间中的线性区。要删除的线性区的描述符放在一个排好序的链表中，局部变量mpnt指向该链表的头。 获得mm-&gt;page_table_lock自旋锁 调用unmap_region()清除与线性地址区间对应的页表项并释放相应的页框。 释放mm-&gt;page_table_lock自旋锁 释放在第7步建立链表时收集的线性区描述符，对在链表中的所有线性区调用unmap_vma()函数，它本质上执行下述步骤: 更新mm-&gt;total_vm和mm-&gt;locked_vm字段 执行内存描述符的mm-&gt;unmap_area方法。 调用线性区的close方法（如果定义了的话） 如果线性区是匿名的，则函数把它从mm-&gt;anon_vma所指向的匿名线性链表中删除。 调用kmem_cache_free()释放线性区描述符 返回0（成功） 缺页异常处理程序Linux的缺页(Page Fault)异常处理程序必须区分两种情况： 由编程引起的异常 由引用属于进程地址空间但还尚未分配物理页框的页引起的异常 缺页异常处理程序的总体方案 do_page_fault()函数接收以下输入参数： pt_regs结构的地址regs，改结构包含当异常发生时的微处理器寄存器的值 3位的error_code，当异常发生时由控制单元压入栈中。这些位有以下含义 如果第0位被清0，则异常由访问一个不存在的页所引起；否则，如果第0位被设置，则异常由无效的访问权限所引起 如果第1位被清0，则异常由读访问或者执行访问所引起；如果该位置被设置，则异常由写访问所引起 如果第2位被清0，则异常发生在处理器处于内核态时；否则，异常发生在处理器处于用户态时。 缺页处理程序流程图 do_page_fault()首先检查引起缺页的线性地址是否属于第4个GB: 123456info.si_code = SEGV_MAPERP;if(address &gt;= TASK_SIZE) &#123; if(!error_code &amp; 5) goto vmlloc_fault; goto bad_area_nosemaphore;&#125; 如果发生了由于内核试图访问不存在的页框引起的异常，就跳转去执行vmlloc_fault标记处的代码，该部分代码处理可能由于在内核态访问非连续内存区而引起的缺页。否则就去跳转执行bad_area_nosemaphore标记处的代码。","categories":[{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/categories/深入理解Linux内核/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://uyouii.github.io/tags/linux/"},{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/tags/bookread/"},{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/tags/深入理解Linux内核/"}]},{"title":"08 内存管理","slug":"08-内存管理","date":"2019-08-03T10:03:34.000Z","updated":"2019-08-03T10:12:41.148Z","comments":true,"path":"2019/08/03/08-内存管理/","link":"","permalink":"https://uyouii.github.io/2019/08/03/08-内存管理/","excerpt":"","text":"内存管理RAM的某些部分永久地分配给内核，并用来存放内核代码以及静态内核数据结构。 RAM的其余部分称为动态内存(dynamic memory) 页框管理页描述符内核需要记录每个页框当前的状态。 例如：内核需要区分哪些页框包含的是属于进程的页，哪些页框包含的是内核代码或内核数据。内核还必须能够却东动态内存中的页是否空闲。在以下情况下页框是不空闲的：包含用户态进程的数据、某个软件高速缓存的数据、动态内存分配的内核数据结构、设备驱动程序缓冲的数据、内核模块的代码等等。 页框的状态信息保存在一个类型为page的也描述符中。所有的页描述符存放在mem_map数组中。因为每个描述符长度为32字节，所以mem_map所需要的空间略小于整个RAM的1%。 页描述符字段 类型 名字 说明 unsigned long flags 一组标志。也对页框所在的管理区进行编号 atomic_t _count 页框的引用计数器 atomic_t _mapcount 页框中页表项数目（如果没有则为-1） unsigned long private 可用于正在使用页的内核成分（例如，在缓冲页的情况下它是一个缓冲头指针）。如果页是空闲的，则该字段由伙伴系统使用。 struct address_space * mapping 当页被插入页高速缓存中时使用，或者当页属于匿名区时使用 unsigned long index 作为不同含义被几种内核成分使用。例如，它在页磁盘映像或者匿名区中标识存放在页框中的数据的位置，或者它存放一个换出页标识符 struct list_head lru 包含页的最近最少使用(LRU)双向链表的指针 _count：页的引用计数器。如果该字段为-1，则相应页框空闲，并可分配给任一进程或内核本身；如果该字段的值大于0或等于0，则说明页框被分配给了一个或多个进程，或用于存放一些内核数据结构。page_count()函数返回_count加1后的值，也就是该页的使用者的数目。 flags：包含多达32个用来描述页框状态的标志。 描述页框状态的标志 标志名 含义 PG_locked 页被锁定。例如，在磁盘I/O操作中涉及的页 PG_error 在传输页时发生I/O错误 PG_referenced 刚刚访问过的页 PG_uptodate 在完成读操作后置位，除非发生磁盘I/O错误 PG_dirty 页已经被修改 PG_lru 页在活动或非活动页链表中 PG_active 页在活动页链表中 PG_slab 包含在slab中的页框 PG_highmem 页框属于ZONE_HIGHMEM管理区 PG_checked 由一些文件系统（如Ext2和Ext3）使用的标志 PG_arch_1 在80x86体系结构上没有使用 PG_reserved 页框留给内核代码或没有使用 PG_private 页描述符的private字段存放了有意义的数据 PG_writeback 正在使用writepage方法将页写到磁盘上 PG_nosave 系统挂起/唤醒时使用 PG_compound 通过扩展分页机制处理页框 PG_swapcache 页属于交换高速缓存 PG_mappedtodisk 页框中的所有数据对应于磁盘上分配的块 PG_reclaim 为回收内存对页已经做了写入磁盘的标记 PG_nosave_free 系统挂起/恢复时使用 非一致内存访问(NUMA)Linux 2.6支持非一致内存访问(Non-Uniform Memory Access, NUMA)模型，在这种模型中，给定CPU对不同的内存单元的访问时间可能不一样。 系统的物理内存被划分为几个节点(node)。在一个单独的节点内，任一给定CPU访问页面所需的时间都是相同的。然而，对不同CPU，这个时间就可能不同。 内存管理区linux把内存节点的物理内存划分为3个管理区(zone)： ZONE_DMA：包含低于16MB的内存页框 ZONE_NORMAL：包含高于16MB且低于896MB的内存页框 ZONE_HIGHMEM：包含从896MB开始高于896MB的内存页框 ZONE_DMA和ZONE_NORMAL区包含内存的”常规”页框，通常把它们线性映射到线性地址空间的第4个GB，内核就可以直接进行访问。相反，ZONE_HIGHMEM区包含的内存页就不能由内核直接访问，尽管它们也线性地映射到了线性地址空间的第4个GB。在64位体系结构上ZONE_HIGHMEM区总是空的。 保留的页框池可以用两种不同的方法来满足内存分配请求，如果有足够的空闲内存可使用，请求就会被立刻满足。否则，必须回收一些内存，并且将发出请求的内核控制路径阻塞，直到有内存被释放。 但是，当请求内存时，一些内核控制路径不能被阻塞——例如，这种情况发生在处理中断或在执行临界区的代码时。在这种情况下，一条内核控制路径应当产生原子内核分配请求 。原子请求从不被阻塞，如果没有足够的空闲页，则仅仅是分配失败而已。 内核为原子内存分配器请求保留了一个页框池，只有在内存不足时才使用。 保留内存的数量(以KB为单位)存放在min_free_kbytes变量中。初始值在内核初始化时被设置，并取决于直接映射到内核线性地址空间的第4个GB的物理内存的数量——也就是说，取决于包含在ZONE_DMA和ZONE_NORMAL内存管理区内的页框数目:$$保留池的大小 = \\sqrt{16 \\times 直接映射内存} $$但是，min_free_kbytes的初始值不能小于128也不能大于65536。 分区页框分配器分区页框分配器(zoned page frame allocator)的内核子系统，处理对连续页框组的内存分配请求。 分区页框分配器的组成 其中，管理区分配器部分接受动态内存的分配与释放的请求。在请求分配的情况下，该部分搜索一个能满足所请求的一组连续页框内存的管理区。在每个管理区内，页框被名为”伙伴系统”的部分来处理。为达到更好的系统性能，小部分页框保留在高速缓存中用于快速地满足单个页框地分配请求。 高端内存页框地内核映射与直接映射地物理内存地末端、高端内存地始端所应对地线性地址存放在high_memory变量中，它被设置为896MB。896MB边界以上地页框并不映射在内核线性地址空间的第4个GB，因此，内核不能直接访问它们。也就意味着，返回所分配页框线性地址的页分配器函数不适用于高端内存，即不适用于ZONE_HIGHMEM内存管理区内的页框。 64位硬件平台上不存在这个问题，因为可使用的线性地址空间远大于能安装的RAM大小，简言之，这些体系结构的ZONE_HIGHMEM管理区总是空的。 伙伴系统算法内存分配算法必须解决外部碎片问题(external fragmentation)。 从本质上说，避免外部随眠的方法有两种： 利用分页单元把一组分连续的空闲页框映射到连续的线性地址空间 开发一种适当的技术来记录现存的空闲连续页框块的情况，以尽量避免位满足对小块的请求而分割大的空闲块。 基于下面的原因，内核采取第二种方法： 在某些情况下，连续的页框确实是必要的，因为连续的线性地址不足以满足请求。 即使连续页框的分配并不是很重要，但它在保持内核页表不变的方面所起的作用也是不容忽视的。（频繁地修改页表势必导致平均访问内存次数增加，因为这会使CPU频繁地刷新转换后援缓冲器(TLB)的内容。 内核通过4MB的页可以访问大块连续物理内存。这样减少了TLB的失效率，因此提高了内存的平均速度。 Linux采用著名的伙伴系统(buddy system)算法来解决外部碎片的问题。把所有空闲页框分组位11块链表，每个块链表分别包含大小为1,2,4,8,16,32,64,128,256,512,1024个连续的页框。对1024个页框的最大请求对应着4MB大小的连续RAM块。 内核试图把大小为b的一对空闲伙伴合并为要给大小为2b的单都块。满足以下条件的两个块称为伙伴： 两个块具有相同的大小，记作b。 它们的物理地址是连续的。 第一块的第一个页框的物理地址是$2 \\times b \\times 2^{12}$的倍数 该算法是迭代的，如果它成功合并所释放的块，它会试图合并2b的块，以再次试图形成更大的块。 每CPU页框高速缓存内核经常请求和释放单个页框。为了提升系统性能，每个内存管理区定义了一个”每CPU”页框高速缓存。所有”每CPU”高速缓存包含一些预先分配的页框，它们被用于满足本地CPU发出的单一内存请求。 实际上，这里为每个内存管理区和每个CPU提供了两个高速缓存：一个热高速缓存，它存放的页框中所包含的内容很可能就在CPU硬件高速缓存中；还有一个冷高速缓存。 如果内核或用户态进程在刚分配到页框后就立即向页框写，那么从热高速缓存中获取页框就对系统性能有利。实际上，每次对页框储存单元的访问都会导致从另一个页框中给硬件高速缓存“窃取”一行——当然，除非硬件高速缓存包含有一行：它映射刚被访问的“热”页框单元。 反过来，如果页框将要被DMA操作填充，那么从冷高速缓存中获取页框是方便的。在这种情况下，不会涉及CPU，并且硬件高速缓存的行不会被修改。冷高速缓存获得页框为其他类型的内存分配保存了热页框储备。 实现每CPU页框高速缓存的主要数据结构存放在内存管理区描述符的pageset字段中的一个per_cpu_pageset数据数据结构。该数组包含为每个CPU提供的一个元素；这个元素依次由两个per_cpu_pageset描述符组成，一个留给热高速缓存而另一个留给冷高速缓存。 per_cpu_pages描述符的字段 类型 名称 描述 int count 高速缓存中的页框个数 int low 下界，表示高速缓存需要补充 int high 上界，表示高速缓存用尽 int batch 在高速缓存中将要添加或删去的页框个数 struct list_head list 高速缓存中包含的页框描述符链表 内核使用两个位标志来监视热高速缓存和冷高速缓存大小： 如果页框个数低于下界low，内核通过从伙伴系统中分配batch个单一页框来补充对应的高速缓存 如果页框个数高于上界high，内核从高速缓存释放batch个页框到伙伴系统中。 值batch、low和high本质上取决于内存管理区中包含的页框个数。 内存区管理伙伴算法系统采用页框作为基本内存区，这适合对于大块内存的请求。 为了存放很少的字节而分配一整个页框这显然是一种浪费，取而代之的正确方法就是引入一种新的数据结构来描述在同一页框中如何分配小内存区。但是也引出了一个新的问题，即所谓的内部碎片(internal fragmentation)。内部碎片的产生主要是由于请求内存大小与分配给它的大小不匹配造成的。 slab分配器算法基于以下前提： 所存放的数据结构的类型可以影响内存区的分配方式。slab分配器概念扩充了这种思想，并把内存区看作对象(object)。为了避免重复初始化对象，slab分配器并不丢弃已经分配的对象，而是释放它们但把它们保存在内存中。当以后又要请求新的对象时，就可以从内存获取而不用重新初始化。 内核函数倾向于反复请求同一类型的内存区。例如，只要内核创建一个新进程，它就要为一些固定大小的表[如进程描述符、打开文件对象等]分配内存区。当进程结束时，包含这些表的内存区还可以被重新使用。因为进程的创建和撤销非常频繁，在没有slab分配器时，内核把时间浪费在反复分配和回收哪些包含在同一内存区的页框上；slab分配器把那些页框保存在高速缓存中并很快地重新使用它们。 对内存区地请求可以根据它们发生地频率来分类。对于预期频繁请求一个特定大小地内存区而言，可以通过创建一组具有适当大小地专用对象来高效地处理，由此以避免内部碎片的产生。另一种情况，对于很少遇到的内存区的大小，可以通过基于一系列几何分布大小（如早期linux版本使用的2的幂次方大小）的对象的分配模式来处理，即使这种方法会导致内部碎片的产生。 在引入对象的大小不是几何分布的情况下，也就是说，数据结构的起始物理地址不是2的幂次，这可以借助处理器硬件高速缓存而导致较好的性能。 硬件高速缓存的高性能又是尽可能地限制对伙伴系统分配器调用的另一个理由，因为对伙伴系统函数的每次调用都”弄脏”硬件高速缓存，所以增加了对内存的平均访问时间。内核函数对硬件高速缓存的影响就是所谓的函数“足迹(footprint)”，其定义为函数结束时重写高速缓存的百分比。显而易见，大的“足迹”导致内核函数刚执行之后较慢的代码执行，因为硬件高速缓存此时填满了无用的信息。 slab分配器把对象分组放进高速缓存。每个高速缓存都是同种类型对象的一种“储备”。 包含高速缓存的主内存区被划分为多个slab，每个slab由一个或多个连续的页框组成，这些页框中既包含已分配的对象，也包含空闲的对象。 slab分配器组成 高速缓存描述符每个高速缓存描述符由kmem_cache_t(等价于struct kmem_cache_s类型)类型的数据结构来描述的。 …… slab 描述符高速缓存中的每个slab都有自己的类型为slab的描述符。 slab 描述符字段 类型 名称 说明 struct list_head list slab描述符的三个双向循环链表中的一个(在高速缓存描述符的kmem_list3结构中的slabs_full、slabs_partial或slabs_free链表)使用的指针 unsigned long colouroff slab中第一个对象的偏移 void * s_mem slab中的第一个对象(或者已被分配，或者空闲)的地址 unsigned int inuse 当前正在使用的（分空闲）slab中的对象个数 kmem_bufctl_t free slab中下一个空闲对象的下标，如果没有剩下空闲对象则为BUFCTL_END slab描述符可能存放在两个地方： 外部slab描述符 ：存放在slab外部，位于cache_sizes指向的一个不适合ISA DMA的普通高速缓存中。 内部slab描述符：存放在slab内部，位于分配给slab的第一个页框的起始位置。 当对象小于512MB时，或者当内部碎片为slab描述符和对象描述符在slab中留下足够的空间时，slab分配器选择第二种方案。如果slab描述符存放在slab外部，那么高速缓存描述符的flags字段中的CFLGS_OFF_SLAB标志置为1；否则它被置为0。 高速缓存描述符与slab描述符之间的关系 给高速缓存分配slab一个新创建的高速缓存没有包含任何slab。只有当以下两个条件都为真时，才给高速缓存分配slab： 已发出一个分配新对象的请求 高速缓存不包含任何空闲对象 从高速缓存撤销slab在两种条件下才能撤销slab： slab高速缓存中有太多空闲的对象 被周期性调用的定时器函数确定是否有完全未使用的slab能被释放 对齐内存中的对象slab分配器所管理的对象可以在内存中进行对齐，也就是说，存放它们的内存单元的起始物理地址是一个给定常量的倍数，通常是2的倍数。这个常量就是对齐因子（alignment factor)。 slab分配器所允许的最大对其因子是4096，即页框大小。 通常情况下，如果内存单元的物理地址是字大小（即计算机的内部内存总线的宽度）对齐的，那么，微机对内存单元的存取会非常快。 slab着色同一硬件高速缓存行可以映射RAM中很多不同的块。相同大小的对象倾向于存放在高速缓存内相同的偏移量处。 在不同slab内具有相同偏移量的对象最终很可能映射在同一高速缓存行中。 高速缓存的硬件可能因此而花费内存周期在同一高速缓存行与RAM内存单元之间来来往往传送两个对象，而其他的高速缓存行并未充分使用。 slab通过一种叫做slab着色（slab coloring）的策略，尽量降低高速缓存这种不愉快的行为。 内存池内存池（memery pool）是linux 2.6的一个新特性。基本上将，一个内存池允许一个内核成分，如块设备子系统，仅在内存不足的紧急情况下分配一些动态内存来使用。 与保留的页框池不同，保留的页框池只用于满足中断处理程序或内部临界区发出的原子内存分配请求。 内存池则是动态内存的储备，只能被特定的内核成分（内存池的拥有者）使用。拥有着通常不使用储备，但是，如果动态内存变得极其稀有以至于普通内存分配请求都将失败的话，那么作为最后的解决手段，内核成分就能调用特定的内存池函数提取得到储备所需的内存。 一个内存池通常叠加在slab分配器之上——也就是说，它被用来保存slab对象的储备。 内存池通常可以被用来分配任何一种类型的动态内存，从整个页框到使用kmalloc()分配的小内存区。 非连续内存区管理把内存区映射到一组连续的页框是最好的选择，这样会充分利用高速缓存并获得较低的平均访问时间。如果对内存区的请求不是很频繁，通过连续的线性地址访问非连续的页框这样一种分配模式就会很有意义。这种模式的主要优点是避免了外部碎片，而缺点是必须打乱内核页表。 。。。","categories":[{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/categories/深入理解Linux内核/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://uyouii.github.io/tags/linux/"},{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/tags/bookread/"},{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/tags/深入理解Linux内核/"}]},{"title":"07 进程调度","slug":"07-进程调度","date":"2019-08-03T10:03:25.000Z","updated":"2019-08-03T10:12:35.818Z","comments":true,"path":"2019/08/03/07-进程调度/","link":"","permalink":"https://uyouii.github.io/2019/08/03/07-进程调度/","excerpt":"","text":"调度策略进程分类方法 传统上把进程分类为“I/O受限(I/O-bound)“或”CPU受限(CPU-bound)“。前者频繁的使用I/O设备，并花费很多时间等待I/O操作完成；后者则需要大量的CPU时间的数值计算应用程序。 另一种分类方法把进程区分为三类： 交互式进程(interactive process): 这些进程经常与用户进行交互，因此，需要花费很多时间等待键盘和鼠标操作。当接受了输入后，进程必须很快被唤醒，否则用户将发现系统反应迟钝。典型的交互式程序是命令shell、文本编辑器及图形应用程序。 批处理程序(batch process): 这些进程不必与用户交互，因此经常在后台运行。这样的进程不必很快地响应，因此常受到调度程序地影响。典型地批处理进程是程序设计语言地编译程序、数据库搜索引擎及科学计算。 实时进程(real-time process): 这些进程有很强地调度需要。这样的进程决不会被低优先级的进程阻塞，它们应该有一个短的响应时间，更重要的是，响应时间的变化应该很小。典型的实时程序有视频和音频应用程序、机器人控制程序及从物理传感器上收集数据的程序。 进程的抢占Linux的进程是抢占式的。如果进程进入TASK_RUNNING状态，内核检查它的动态优先级是否大于当前正在运行的进程的优先级。如果是，current的执行被中断，并调用调度程序选择另一个进程运行（通常是刚变为可运行的进程）。 当然，进程在它的时间片到期时也可以被抢占。此时，当前进程thread_info结构中的TIF_NEED_RESCHED标志被设置，以便时钟中断处理程序终止时调度程序被调用。 注：被强占的进程没有被挂起，因为它还处于TASK_RUNNING状态，只不过不再使用CPU。 一个时间片必须持续多长？如果平均时间片太短，有进程切换引起的系统额外开销就会变得非常高。 如果平均时间片太长，进程看起来就不再是并发执行。 对时间片大小的选择始终是一种折衷。Linux采取单凭经验的方法，即选择尽可能长、同时能保持良好响应时间的时间片。 调度算法调度程序总能成功地找到要执行地进程。总是至少有一个可运行进程，即swapper进程，它地PID等于0，而且它只有再CPU不能执行其他进程时才执行。 每个Linux进程总是按照下面地调度类型被调度： SCHED_FIFO 先进先出地实时进程。当调度程序把CPU分配给进程地时候，它把改进程描述符保留在运行队列链表地当前位置。如果没有其他可运行的更高优先级实时进程，进程就继续使用CPU，想用多久就用多久，计师还有其他具有相同优先级的实时进程处于可运行状态。 SCHED_RR 时间片轮转的实时进程。当调度程序把CPU分配给进程的时候，它把该进程的描述符放在运行队列链表的末尾。这种策略保证对所有具有相同优先级的SCHED_RR实时进程公平的分配CPU时间。 SCHED_NORMAL 普通的分时进程 调度算法根据进程是普通进程还是实时进程有很大不同。 普通进程的调度实时进程的调度","categories":[{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/categories/深入理解Linux内核/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://uyouii.github.io/tags/linux/"},{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/tags/bookread/"},{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/tags/深入理解Linux内核/"}]},{"title":"03 进程","slug":"03-进程","date":"2019-08-03T10:03:13.000Z","updated":"2019-08-03T10:12:31.553Z","comments":true,"path":"2019/08/03/03-进程/","link":"","permalink":"https://uyouii.github.io/2019/08/03/03-进程/","excerpt":"","text":"进程进程、轻量级进程和线程从内核观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的实体。 Linux使用轻量级进程(lightweight process)对多线程应用程序提供更好的支持。两个轻量级进程基本上可以共享一些资源，诸如地址空间、打开的文件等等。 进程描述符进程描述符(process descriptor)——进程描述符都是task_struct类型结构，它的字段包含了与一个进程相关的所有信息。 linux 进程描述符 进程状态进程描述符中的state字段描述了进程当前所处的状态。它由一组标志组成，其中每个标志描述一种可能的进程状态。在当前的Linux版本中，这些状态是互斥的，因此，严格意义上说，只能设置一种状态；其余的标志将被清除。 可运行状态(TASK_RUNNING) 进程要么在CPU上执行，要么装备执行 可中断的等待状态(TASK_INTERRUPTIBLE) 进程被挂起（睡眠），直到某个条件变为真。产生一个硬件中断，释放进程正等待的系统资源，或传递一个信号都是可以唤醒进程的条件（把进程的状态放回到TASK_RUNNING）。 不可中断的等待状态(TASK_UNINTERRUPTIBLE) 与可中断的等待状态类似，但有一个例外，把信号传递到睡眠进程不能改变它的状态。这种状态很少用到，但在一些特殊的情况下（进程必须等待，直到一个不能被中断的事件发生），这种状态是很有用的。 例如，当进程打开一个设备文件，其相应的设备驱动程序开始探测相应的硬件设备时会用到这种状态。探测完成以前，设备驱动程序不能被中断，否则，硬件设备会处于不可预知的状态。 暂停状态(TASK_STOPPED) 进程的执行被暂停。当进程接收到SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU信号后，进入暂停状态。 跟踪状态(TASK_TRACED) 进程的执行已由debugger程序暂停。当一个进程被另一个进程监控时，任何信号都可以把这个进程置于TASK_TRACED状态。 还有两个进程状态既可以存放在进程描述符的state字段中，也可以存放在exit_state字段中。从这两个字段名称可以看出，只有当进程的执行被终止时，进程的状态才会改变为这两种状态中的一种。 僵死状态(EXIT_ZOMBIE) 进程的执行被终止，但是，父进程还没有发布wait4()或waitpid()系统调用来返回有关死亡进程的信息。发布wait()类系统调用前，内核不能丢弃包含在死进程描述符中的数据，因为父进程可能还需要它。 僵死撤销状态(EXIT_DEAD) 最终状态：由于父进程刚发出wait4()或waitpid()系统调用，因而进程由系统删除。为了防止其他执行线程在同一个进程上也执行wait()类系统调用(这是一种竞争状态)，而把进程的状态由僵死(EXIT_ZOMBIE)状态改为僵死撤销状态(EXIT_DEAD)。 标识一个进程能够独立调度的每个执行上下文都必须拥有它自己的进程描述符。 进程和进程描述符有非常严格的一一对应关系，使得32位的进程描述符地址可以很容易的标识进程。进程描述符指针指向这些地址，内核对进程的大部分引用是通过进程描述符指针进行的。 类Unix操作系统允许用户使用一个叫进程描述符processID(或PID)的数来标识进程，PID存放在进程描述符的pid字段中。 PID的值有一个上限，默认情况下，最大的PID号时32767(PID_MAX_DEFAULT - 1)；系统管理员可以通过往/proc/sys/kernel/pid_max这个文件中写入一个更小的值来减小PID的上限值。在64位的体系结构中，系统管理员可以把PID的上限扩大到4194303。 由于循环使用PID编号，内核必须通过管理一个pidmap_array位图来表示当前已分配的PID号和闲置的PID号。因为一个页框包含32768个位，所以在32位体系结构中pidmap_array位图存放在一个单独的页中。然而在64位体系结构中，需要为PID位图增加更多的页。系统会一直保存这些页不被释放。 Unix希望同一组的线程有共同的PID。例如，可以把信号发送给指定PID的一组线程，这个信号会作用于该组中的所有线程。 Linux遵照这个标准引入了线程组的表示。一个线程组的所有线程使用和该线程组的领头线程(thread group leader)相同的PID，也就是该组中的第一个轻量级进程的PID，它被存入进程描述符的tgid字段中。getpid()系统调用返回当前进程的tgid值而不是pid值，因此，一个多线程应用的所有线程共享相同的PID。 进程描述符处理进程是动态实体，内核必须能够同时处理很多进程，并把进程描述符存放在动态内存中。 对每个进程来说，Linux都把两个不同的数据结构紧凑地存放在一个单独为进程分配的储存区域：一个是与进程描述符相关的小数据结构thread_info，叫做线程描述符。另一个是内核态的进程堆栈。这块储存区域的大小通常为8192个字节(两个页框)。考虑到效率的因素，内核让这8K空间占据连续的两个页框并让第一个页框的起始地址是2^13的倍数。 内核态的进程访问处于内核数据段的栈，这个栈不同于用户态的进程所用的栈。因为内核控制器路径使用很少的栈，因此只需要几千字节的内核态堆栈。所以，对于内核栈和thread_info结构来说，8KB足够了。 thread_info 结构和进程内核存放在两个连续的页框中 esp寄存器是CPU栈指针，用来存放栈顶单元的地址。从用户态切换到内核态以后，进程的内核栈总是空的，因此，esp寄存器指向这个栈的顶端。 c语言使用下列的联合结构方便的表示一个进程的线程描述符和内核栈: 1234union thread_union &#123; struct thread_info thread_info; unsigned long stack[2048]; /* 对4K的栈数组下标是1024 */&#125;; 标识当前进程thread_info结构与内核态堆栈之间紧密结合提供的主要好处是：内核可以很容易从esp寄存器的值获取当前在CPU运行进程的thread_info结构的地址。如果thread_union结构长度是8K，内核则屏蔽掉esp的低13位有效位就可以获得thread_info结构的基地址；而如果thread_union结构长度是4K，内核则需要屏蔽掉esp的低12位有效地址。 进程最常用的是进程描述符地址而不是thread_info结构的地址，通过thread_info的task指针可以很容易的获取到进程描述符。 进程链表每个task_struct结构都包含一个list_head类型的tasks字段，这个类型的prev和next字段分别指向前面和后面的task_struct元素。 TASK_RUNNING状态的进程链表当内核寻找一个新进程在CPU运行时，必须只考虑可运行进程(即处在TASK_RUNNING状态的进程) 提高调度程序运行速度的诀窍是建立多个可运行进程链表，每种进程优先权对应一个不同的链表。每个task_struct描述符包含一个list_head类型的字段run_list。如果进程的优先权等于k，run_list字段把该进程链入优先权为k的可运行进程的链表中。 进程间关系 进程描述符中表示进程亲属关系的字段描述 字段名 说明 real_parent 指向创建了P的进程的描述符，如果P的父进程不再存在，就指向进程1(init)的描述符（因此，如果用户运行一个后台进程而且推出了shell，后台进程就会成为init的子进程） parent 指向P的当前父进程（这种进程的子进程终止时，必须向父进程发信号）。它的值通常与real_parent一致，但偶尔也可以不同，例如，当另一个进程发出监控P的ptrace()系统调用请求时 children 链表的头部，链表中的所有元素都是P创建的子进程 sibling 指向兄弟进程链表的下一个元素或前一个元素的指针，这些兄弟进程的父进程都是P pidhash表及链表由于需要跟踪进程间的关系，PID散列表中使用的数据结构非常复杂。 PID散列表的数据结构是四个pid结构的数组，它在进程描述符的pids字段中。 pid结构的字段 123456struct pid&#123; int nr; // pid的数值 struct hlist_node pid_chain; // 链接散列表的下一个和前一个元素 struct list_head pid_list; // 每个pid的进程链表头&#125;; PID散列表 如何组织进程","categories":[{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/categories/深入理解Linux内核/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://uyouii.github.io/tags/linux/"},{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/tags/bookread/"},{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/tags/深入理解Linux内核/"}]},{"title":"02 内存寻址","slug":"02-内存寻址","date":"2019-08-03T10:03:05.000Z","updated":"2019-08-03T10:12:28.651Z","comments":true,"path":"2019/08/03/02-内存寻址/","link":"","permalink":"https://uyouii.github.io/2019/08/03/02-内存寻址/","excerpt":"","text":"内存寻址内存地址硬件中的分段Linux中的分段硬件中的分页硬件高速缓存为了缩小CPU和RAM之间的速度不匹配，引入了硬件高速缓存内存(hardware cache memory) 硬件高速缓存基于著名的局部性原理(locality principle)，该原理既适用程序结构也适用于数据结构。这表明由于程序的循环结构及相关数组可以组织成线性数组，最近最常用的相邻地址在最近的将来又被用到的可能性极大。 高速缓存单元插在分页单元和主内存之间。它包含一个硬件高速缓存内存(hardware cache memory)和一个高速缓存控制器(cache controller)。高速缓存内存中存放内存真正的行。高速缓存控制器存放一个表项数组，每个表项对应高速缓存内存中的一个行。每个表项有一个标签(tag)和描述高速缓存行状态的几个标志(flag)。 这种物理内存地址通常分为3组：最高几位对应标签，中间几位对应高速缓存控制器的字集索引，最低几位对应行内的偏移量。 处理器硬件高速缓存 当访问一个RAM储存单元时，CPU从物理地址中提取出子集的索引号并把子集中所有行的标签与物理地址的高几位比较。如果发现某一行的标签与这个物理地址的高位相同，则CPU命中一个高速缓存(cache hit)；否则，高速缓存没有命中(cache miss)。 当命中一个高速缓存时，高速缓存控制器执行不同的操作。 对于读操作，控制器从高速缓存行中选择数据并送到CPU寄存器；不需要访问RAM因而节约了CPU时间，因此，高速缓存系统起到了应有的作用。 对于写操作，控制器可能采用以下两个基本策略之一： 通写(write-through)：控制器总是既写RAM也写高速缓存行 回写(write-back)：回写的方式只更新高速缓存行，不改变RAM内容，提供了更快的功效。只有当CPU执行一条要求刷新高速缓存表项的指令时，或者当一个FLUSH硬件信号产生时（通常在高速缓存不命中之后），高速缓存控制器才把高速缓存行写回到RAM中。 当高速缓存没有命中时，高速缓存行被写回到内存中，如果有必要的话，把正确的行从RAM中取出放到高速缓存行的表项中。 Linux中的分页","categories":[{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/categories/深入理解Linux内核/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://uyouii.github.io/tags/linux/"},{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/tags/bookread/"},{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/tags/深入理解Linux内核/"}]},{"title":"01 操作系统基本概念","slug":"01-操作系统基本概念","date":"2019-08-03T10:00:09.000Z","updated":"2019-08-03T10:12:25.565Z","comments":true,"path":"2019/08/03/01-操作系统基本概念/","link":"","permalink":"https://uyouii.github.io/2019/08/03/01-操作系统基本概念/","excerpt":"","text":"操作系统基本概念操作系统完成的两个主要目标： 与硬件部分交互，为包含在硬件平台上的所有底层可编程部分提供服务 为运行在计算机系统上的应用程序（即所谓应用程序）提供执行环境 现代操作系统依靠特殊的硬件特性禁止用户程序直接与底层硬件部分进行交互，或者禁止直接访问任意的物理地址。硬件为CPU引入了至少两种不同的执行模式：用户程序的非特权模式和内核的特权模式。Univ把它们分别称为用户态(User Mode)和内核态(Kernel Mode)。 多用户系统多用户系统(multiuser system)就是一台能并发和独立地执行分别属于两个或多个用户的若干应用程序的计算机。 ”并发“(concurrently)以为着几个应用程序能同时处于活动状态并竞争各种资源，如CPU、内存、硬盘等等。 “独立”(independently)意味着每个应用程序能执行自己的任务，而无需考虑其他用户的应用程序在干些什么。 多用户操作系统必须包含以下几个特点： 核实用户身份认证的机制 防止有错误的用户程序妨碍其他应用程序在系统中运行的保护机制 防止有恶意的用户程序干涉或窥视其他用户的活动的保护机制 限制分配给每个用户的资源数的记账机制 用户和组在多用户系统中，每个用户在机器上都有私有空间。 所有的用户由一个唯一的数字来标识，这个数字叫用户标识符（UserID，UID） 为了和其他用户有选择的共享资料，每个用户是一个或多个用户组的一名成员，组由唯一的用户组标识符（user group ID）标识。每个文件也恰好与一个组相对应。 Unix 文件系统概述文件类型Unix文件可以是下列类型之一： 普通文件（regular file） 目录 符号链接 面向块的设备文件（block-oriented device file） 面向字符的设备文件（character-oriented device file） 管道（pipe）和命名管道（named piped）（也叫FIFO） 套接字（socket） 文件描述符与索引节点Unix对文件的内容和描述文件的信息给出了清除的区分。除了设备文件和特殊文件系统文件外，每个文件都由字符序列组成。文件内容不包含任何控制信息。 文件系统处理文件所需要的信息包含在一个名为索引节点（inode）的数据结构中。每个文件都有自己的索引节点，文件系统用索引节点来标识文件。 文件系统至少提供在POSIX标准中指定的如下属性： 文件类型 与文件相关的硬链接的个数 以字节为单位的文件长度 设备标识符（即包含文件的设备标识符） 在文件系统中标识文件的索引节点号 文件拥有者的UID 文件的用户组ID 几个时间戳，表示索引节点状态改变的时间、最后访问时间及最后修改时间 访问权限和文件模式 Unix内核概述进程/内核模式当一个程序在用户态下执行时，它不能直接访问内核数据结构或者内核的程序。然而，当应用程序在内核态下运行时，这些限制不再有效。 内核本身不是一个进程，而是进程的管理者。 进程/内核模式假定：请求内核服务的进程使用所谓系统调用(system call)的特殊编程机制。每个系统调用都设置了一组识别进程请求的参数，然后执行与硬件相关的CPU指令完成从用户到内核态的转换。 激活内核例程的几种方式： 进程调用系统调用 正在执行进程的CPU发出一个异常(exception)信号，内核代表产生异常的进程处理异常。 外围设备向CPU发出一个中断(interrupt)信号以通知一个事件的发声，例如一个要求注意的请求、一个状态的变化或一个I/O操作已经完成等。每个中断信号都是由内核中的中断处理程序(interrupt handler)来处理的。因为外围设备与CPU是异步操作，因此，中断在不可预知的时间发生。 内核线程被执行。 进程实现每个进程由一个进程描述符(process descriptor)表示，这个描述符包含有关进程当前状态的信息。 当内核暂停一个进程的执行时，就把几个相关处理器寄存器的内容保存在进程描述符中。这些寄存器包括： 程序计数器(PC)和栈指针(SP)寄存器 通用寄存器 浮点寄存器 包含CPU状态信息的处理器控制寄存器(处理器状态字，Processor Status Word) 用来跟踪进程对RAM访问的内存管理寄存器 当内核恢复执行一个进程时，它用进程描述符中适合的字段来装载CPU寄存器。因为程序计数器中所存的值指向下一条将要执行的指令，所以进程从它停止的地方恢复执行。 Unix内核可以区分很多等待状态，这些等待状态通常由进程描述符队列实现。 进程地址空间每个进程运行在它的私有地址空间。在用户态下运行的进程涉及到私有栈、数据区和代码区。当在内核态运行时，进程访问内核的数据区和代码区，但使用另外的私有栈。 尽管看起来每个进程访问一个私有地址空间，但有时进程之间也共享这部分地址空间。在一些情况下，这种共享由进程显式提出；在另一些情况下，由内核自动完成共享以节约内存。进程间能共享部分地址空间，以实现一种进程间通信，这就是由System V引入并已经被Linux支持地”共享内存”技术。 Linux支持mmap()系统调用，该系统调用允许存放在块设备上的文件或者信息的一部分映射到进程的部分地址空间。内存映射为正常的读写传送数据提供了另一种选择。如果同一个文件由几个进程共享，那么共享它的每个进程地址空间都包含它的内存映射。","categories":[{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/categories/深入理解Linux内核/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://uyouii.github.io/tags/linux/"},{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/tags/bookread/"},{"name":"深入理解Linux内核","slug":"深入理解Linux内核","permalink":"https://uyouii.github.io/tags/深入理解Linux内核/"}]},{"title":"Chapter3 The Graphics Processing Unit","slug":"Chapter3-The-Graphics-Processing-Unit","date":"2018-11-12T13:49:28.000Z","updated":"2019-08-02T03:28:18.911Z","comments":true,"path":"2018/11/12/Chapter3-The-Graphics-Processing-Unit/","link":"","permalink":"https://uyouii.github.io/2018/11/12/Chapter3-The-Graphics-Processing-Unit/","excerpt":"","text":"The display is the computer ​ —— Jen-Hsun Huang Data-Parallel ArchitecturesMuch of a GPU’s chip area is dedicated to a large set of processors, called shader cores, often numbering in the thousands. The GPU is a stream processor, in which ordered sets of similar data are processed in turn. Becauseof this similarity the GPU can process these data in a massively parallel fashion. The GPU is optimized for throughput, deﬁned as the maximum rate at which data can be processed. However, this rapid processing has a cost. With less chip area dedicated to cache memory and control logic, latency for each shader core is generally considerably higher than what a CPU processor encounters. GPUs separate the instruction execution logic from the data. Called single instruction, multiple data (SIMD). The advantage of SIMD is that considerably less silicon (and power) needs to be dedicated to processing data and switching, compared to using an individual logic and dispatch unit to run each program. Warpin modern GPU terms, each pixel shader invocation for a fragment is called a thread. This type of thread is unlike a CPU thread. It consists of a bit of memory for the input values to the shader, along with any register space needed for the shader’s execution. Threads that use the same shader program are bundled into groups, called warps by NVIDIA and wavefronts by AMD. A warp/wavefront is scheduled for execution by some number GPU shader cores, anywhere from 8 to 64, using SIMD-processing. OccupancyThe shader program’s structure is an important characteristic that inﬂuences eﬃciency. A major factor is the amount of register use for each thread. The more registers needed by the shader program associated with each thread, the fewer threads, and thus the fewer warps, can be resident in the GPU. A shortage of warps can mean that a stall cannot be mitigated by swapping. Warps that are resident are said to be “in ﬂight,” and this number is called the occupancy. High occupancy means that there are many warps available for processing, so that idle processors are less likely. Low occupancy will often lead to poor performance. The frequency of memory fetches also aﬀects how much latency hiding is needed. Another factor aﬀecting overall eﬃciency is dynamic branching, caused by “if” statements and loops. if some threads, or even one thread, take the alternate path, then the warp must execute both branches, throwing away the results not needed by each particular thread. This problem is called thread divergence, where a few threads may need to execute a loop iteration or perform an “if” path that the other threads in the warp do not, leaving them idle during this time. Simpliﬁed shader execution example. A triangle’s fragments, called threads, are gathered into warps. Each warp is shown as four threads but have 32 threads in reality. The shader program to be executed is ﬁve instructions long. The set of four GPU shader processors executes these instructions for the ﬁrst warp until a stall condition is detected on the “txr” command, which needs time to fetch its data. The second warp is swapped in and the shader program’s ﬁrst three instructions are applied to it, until a stall is again detected. After the third warp is swapped in and stalls, execution continues by swapping in the ﬁrst warp and continuing execution. If its “txr” command’s data are not yet returned at this point, execution truly stalls until these data are available. Each warp ﬁnishes in turn. GPU Pipeline Overview GPU implementation of the rendering pipeline. The stages are color coded according to the degree of user control over their operation. Green stages are fully programmable. Dashed lines show optional stages. Yellow stages are conﬁgurable but not programmable, e.g., various blend modes can be set for the merge stage. Blue stages are completely ﬁxed in their function. The vertex shader is a fully programmable stage that is used to implement the geometry processing stage. The geometry shader is a fully programmable stage that operates on the vertices of a primitive (point, line, or triangle). It can be used to perform per-primitive shading operations, to destroy primitives, or to create new ones. The tessellation stage and geometry shader are both optional, and not all GPUs support them, especially on mobile devices. The clipping, triangle setup, and triangle traversal stages are implemented by ﬁxed-function hardware. Screen mapping is aﬀected by window and viewport settings, internally forming a simple scale and repositioning. The pixel shader stage is fully programmable. Although the merger stage is not programmable, it is highly conﬁgurable and can be set to perform a wide variety of operations. It implements the “merging” functional stage, in charge of modifying the color, z-buﬀer, blend, stencil, and any other output-related buﬀers. pixel shader execution together with the merger stage form the conceptual pixel processing stage. The Programmable Shader Stageshader languages: HLSL: DirectX’s High-Level Shading Language GLSL: OpenGL Shading Language DirectX’s HLSL can be compiled to virtual machine bytecode, also called the intermediate language (IL or DXIL), to provide hardware independence. A draw call invokes the graphics API to draw a group of primitives, so causing the graphics pipeline to execute and run its shaders. Each programmable shader stage has two types of inputs: uniform inputs, with values that remain constant throughout a draw call (but can be changed between draw calls) varying inputs, data that come from the triangle’s vertices or from rasterization. Shader Virtual Machine RegisterThe underlying virtual machine provides special registers for the diﬀerent types of inputs and outputs. The number of available constant registers for uniforms is much larger than those registers available for varying inputs or outputs. This happens because: the varying inputs and outputs need to be stored separately for each vertex or pixel, so there is a natural limit as to how many are needed. The uniform inputs are stored once and reused across all the vertices or pixels in the draw call. The virtual machine also has general-purpose temporary registers, which are used for scratch space. All types of registers can be array-indexed using integer values in temporary registers. Uniﬁed virtual machine architecture and register layout, under Shader Model 4.0. The maximum available number is indicated next to each resource. Three numbers separated by slashes refer to the limits for vertex, geometry, and pixel shaders (from left to right). flow controlInstructions related to ﬂow control are used to implement high-level language constructs such as “if” and “case” statements, as well as various types of loops. Shaders support two types of ﬂow control: Static ﬂow control branches are based on the values of uniform inputs. This means that the ﬂow of the code is constant over the draw call. Dynamic ﬂow control is based on the values of varying inputs, meaning that each fragment can execute the code diﬀerently. The primary beneﬁt of static ﬂow control is to allow the same shader to be used in a variety of diﬀerent situations (e.g., a varying numbers of lights). There is no thread divergence, since all invocations take the same code path. Dynamic flow control is much more powerful than static ﬂow control but can cost performance, especially if the code ﬂow changes erratically between shader invocations. The Vertex ShaderA triangle mesh is represented by a set of vertices, each associated with a speciﬁc position on the model surface. Besides position, there are other optional properties associated with each vertex, such as a color or texture coordinates. Surface normals are deﬁned at mesh vertices as well. The vertex shader provides a way to modify, create, or ignore values associated with each triangle’s vertex, such as its color, normal, texture coordinates, and position. Normally the vertex shader program transforms vertices from model space to homogeneous clip space . At a minimum, a vertex shader must always output this location. Since each vertex is treated independently, any number of shader processors on the GPU can be applied in parallel to the incoming stream of vertices. Shader Effects vertex blending for animating joints(动画关节的定点混合) silhouette rendering（轮廓渲染） Object generation, by creating a mesh only once and having it be deformed by the vertex shader. Animating character’s bodies and faces using skinning and morphing（蒙皮） techniques. Procedural deformations（程序变形）, such as the movement of ﬂags, cloth, or water Particle creation, by sending degenerate (no area) meshes down the pipeline and having these be given an area as needed. Lens distortion（镜头扭曲）, heat haze（热雾）, water ripples（水波纹）, page curls（页面卷曲）, and other eﬀects, by using the entire framebuﬀer’s contents as a texture on a screen-aligned mesh undergoing procedural deformation. Applying terrain height ﬁelds by using vertex texture fetch The Tessellation Stage (曲面细分阶段)The tessellation stage allows us to render curved surfaces. The GPU’s task is to take each surface description and turn it into a representative set of triangles. This stage is an optional GPU feature . Advantages: Memory Savings Keep the bus between CPU and GPU from becoming the bottleneck for an animated character or object whose shape is changing each frame surface can be rendered efficiently by having an appropriate number of triangles generated for the given view. This ability to control the level of detail can also allow an application to control its performance The tessellation stage always consists of three elements: hull shader: in OpenGL is the tessellation control shader tesssellator: in OpenGL is primitive genearator domain shader: in OpenGL is the tessellation evaluation shader The tessellation stage. The hull shader takes in a patch deﬁned by control points. It sends the tessellation factors (TFs 曲面细分因子) and type to the ﬁxed-function tessellator. The control point set is transformed as desired by the hull shader and sent on to the domain shader, along with TFs and related patch constants. The tessellator creates the set of vertices along with their barycentric coordinates. These are then processed by the domain shader, producing the triangle mesh (control points shown for reference). Hull ShaderThe input to the hull shader is a special patch primitive. This consists of several control points deﬁning a subdivision surface（细分曲面）, B´ezier patch, or other type of curved element. Hull Shader has two functions: First, it tells the tessellator how many triangles should be generated, and in what conﬁguration. Second, it performs processing on each of the control points. Also, optionally, the hull shader can modify the incoming patch description, adding or removing control points as desired. The hull shader outputs its set of control points, along with the tessellation control data, to the domainshader. TessellatorThe tessellator is a fixed-function stage in the pipeline, only used with tessellation shaders. It has the task of adding several new vertices for the domain shader to process. The hull shader sends the tessellator information about what type of tessellation surface is desired: triangle, quadrilateral, or isoline.( Isolines are sets of line strips, sometimes used for hair rendering.) The other important values sent by the hull shader are the tessellation factors (tessellation levels in OpenGL). These are of two types: inner and outer edge. The two inner factors determine how much tessellation occurs inside the triangle or quadrilateral. The outer factors determine how much each exterior edge is split Domain ShaderThe control points for the curved surface from the hull shader are used by each invocation of the domain shader to compute the output values for each vertex. The domain shader has a data ﬂow pattern like that of a vertex shader, with each input vertex from the tessellator being processed and generating a corresponding output vertex. The triangles formed are then passed on down the pipeline. The domain shader takes the barycentric coordinates（重心坐标） generated for each point and uses these in the patch’s evaluation equation to generate the position, normal（法线）, texture coordinates（纹理坐标）, and other vertex information desired. The Geometry ShaderNote that no output at all can be generated by the geometry shader. The geometry shader is designed for modifying incoming data or making a limited number of copies. The geometry shader is guaranteed to output results from primitives in the same order that they are input. This aﬀects performance, because if several shader cores run in parallel, results must be saved and ordered. The Pixel ShaderThis piece of a triangle partially or fully overlapping the pixel is called a fragment. In OpenGL the pixel shader is known as the fragment shader, which is perhaps a better name. In programming terms, the vertex shader program’s outputs, interpolated across the triangle (or line), eﬀectively become the pixel shader program’s inputs. With inputs in hand, typically the pixel shader computes and outputs a fragment’s color. It can also possibly produce an opacity value and optionally modify its z-depth. A pixel shader also has the unique ability to discard an incoming fragment, i.e., generate no output. MRT multiple render targetsInstead of sending results of a pixel shader’s program to just the color and z-buﬀer, multiple sets of values could be generated for each fragment and saved to diﬀerent buﬀers, each called a render target. A single rendering pass could generate a color image in one target, object identiﬁers in another, and world-space distances in a third. This ability has also given rise to a diﬀerent type of rendering pipeline, called deferred shading, where visibility and shading are done in separate passes. The ﬁrst pass storesdata about an object’s location and material at each pixel. Successive passes can then eﬃciently apply illumination and other eﬀects. limitationThe pixel shader’s limitation is that it can normally write to a render target at only the fragment location handed to it, and cannot read current results from neighboring pixels. That is, when a pixel shader program executes, it cannot send its output directly to neighboring pixels, nor can it access others’ recent changes. Rather, it computes results that aﬀect only its own pixel. But an output image created in one pass can have any of its data accessed by a pixel shader in a later pass. ExceptionThere are exceptions to the rule that a pixel shader cannot know or aﬀect neighboring pixels’ results. One is that the pixel shader can immediately access information for adjacent fragments (albeit indirectly) during the computation of gradient or derivative information. The Merging StageThe merging stage is where the depths and colors of the individual fragments (generated in the pixel shader) are combined with the framebuﬀer. The merging stage occupies the middle ground between ﬁxed-function stages, such as triangle setup, and the fully programmable shader stages. Although it is not programmable, its operation is highly conﬁgurable. On most traditional pipeline diagrams, this stage is where stencil-buﬀer and z-buﬀer operations occur. If the fragment is visible, another operation that takes place in this stage is color blending. For opaque surfaces there is no real blending involved, as the fragment’s color simply replaces the previously stored color. Actual blending of the fragment and stored color is commonly used for transparency and compositing operations The fragment is culled if hidden. This functionality is called early-z. The Compute Shader","categories":[{"name":"Real Time Rendering","slug":"Real-Time-Rendering","permalink":"https://uyouii.github.io/categories/Real-Time-Rendering/"}],"tags":[{"name":"graphics","slug":"graphics","permalink":"https://uyouii.github.io/tags/graphics/"},{"name":"real time rendering","slug":"real-time-rendering","permalink":"https://uyouii.github.io/tags/real-time-rendering/"}]},{"title":"100种爱你的表达方式","slug":"100种爱你的表达方式","date":"2018-11-11T08:41:56.000Z","updated":"2019-08-03T10:07:07.688Z","comments":true,"path":"2018/11/11/100种爱你的表达方式/","link":"","permalink":"https://uyouii.github.io/2018/11/11/100种爱你的表达方式/","excerpt":"","text":"I’ve been doing a lot of thinking and the thing is, I love you. 我思考了很久，结论是，我爱你 you are the epitome of everything I’ve ever looked for in another human being 你拥有我梦寐以求的一切美好品质 Love is … is too weak a word for the way I feel. I lurv you, I loave you, I luff you 用爱这个词来形容我的感受太苍白了,我耐你，我中意你，我稀罕你啊！ I sort of feel like I’m on drugs when I’m with you. Not that I do drugs, unless you do drugs, in which case I do drugs all the time. 和你在一起的感觉就像是在嗑药，不是我说真的嗑药啊，除非你嗑药, 那样的话我就一直嗑药。 There’s only one place in the world I call home, and it’s because you’re there 这世上只有一个我能称之为家的地方，那就是你在的地方。 I’d feel better sitting outside your apartment on the curb than any other place I can think of or imagine. 坐在你门口的路边感觉很好，我再想不出其他更好的地方了。 I’m not waking up another morning without being able to look at you next to me. 我不想清晨醒来的时候没有你在身边。 I would rather share one lifetime with you than face all the ages of this world alone. 我宁愿和你共度凡人短暂的一生也不愿一个人看尽这世界的沧海桑田。 Can’t you see what I’m trying to tell you, I love you! 你难道还看不出来我对你的心意吗？我爱你！ No other love but you. 除你之外别无所爱 Like a sickness and its cure together 就像病与药方一样难分。 I love you. Ditto 我爱你。 + 1 I should have told you every day from the moment I met you 我应该从遇见你的那一刻起每天对你说一遍 You complete me 你让我的人生完整了 I love you Chicken 我爱你小妞 I love you Honey Bunny 我爱你甜甜宝贝儿 I think that’s the only thing I’ve ever been really sure of in my entire life 这是我人生中唯一确信不疑的事 You are the woman that I want 你是我想要的女人 How many more times to I have to say it? One more time would be nice 我还要再说多少遍？再说一遍就好 You have bewitched me, body and soul。 你让我着了魔，从肉体到灵魂 Whatever I am, I’m yours 不论我是什么，我是你的 I am so in love with you 我是如此爱你 You’re the only one for me 你是我的唯一 I’m not a smart man, but I know what love is 我不聪明，但是我知道爱是什么 Love means never having to say you’re sorry 爱就是永远不用说抱歉 Love is a many-splendored thing. Love lifts us up where we belong. All you need is love! 爱是如此壮丽辉煌，爱会把我们带到我们所属的地方，爱就是你所需的一切 Some people search all their life for this and never find it. 多少人终其一生求而不得 You think this happens everyday? 你觉得这是等闲寻常事？ I love you dream woman! 我爱你女神 What do I have to do to prove it to you? 我要做什么才能向你证明？ You what the moon? 要我摘天上的月亮给你？ You want me to renounce my throne? 要我放弃王位？ The wooing, the spooning, I am all in! 各种求爱、表白，我都愿意做 Because when you find the one, you never give up 因为当你遇见那个人时，你永不放手 All I ever wanted, was you 我一直以来想要的，就是你 I’ve loved you more than any woman’s ever loved a rabbit 我爱你胜过对任何女人对兔子的爱 I love you more than anyone has ever loved 我爱你胜过任何曾经爱过的人 I love you more than my life 我爱你胜过我的生命 I love you more than band music and cookie-making 我爱你胜过爱乐队和烤饼干 I want to be with you 我想跟你在一起 I made up my mind you were the only woman for me 我想好了，你就是我的唯一 I’ve loved you since the first day I met you, and I’ll never stop 遇见你的第一天起我就爱上了你，而且永不停息 I’ll love you always 我会永远爱你 Until your heart stops beating 直到你的心脏停止跳动 Til the stars turn cold 直到星辰不再发光 I’ve never felt that before 我之前从未有过这样的感觉 I love you. Can’t believe how many times I’m saying it 我爱你，不敢相信我竟说了这么多遍 Because I came alive when I met you 因为遇见你，我又活了过来 And there’s only one person that makes me feel like I can fly 你是唯一让我觉得我可以飞翔的人 So I will wait forever for you, okay? I will wait the rest of my life. 我会永远等你的好不好？我会用我的余生来等待 I want all of you, forever, you and me, every day我想完完整整地拥有你 I always have 我一直都是 I always will 我一直都会 I came here tonight because when you realize you want to spend the rest of your life with somebody, you want the rest of the life to start as soon as possible. 我今晚来这里是因为，当你意识到自己想要与一个人共度余生地时候，你会希望你的余生尽快开始。 Just shut up, you had me at “hello” 别说了，你的一句“你好”我就已经沦陷了","categories":[{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/categories/bookread/"}],"tags":[{"name":"booknote","slug":"booknote","permalink":"https://uyouii.github.io/tags/booknote/"}]},{"title":"The Graphics Rendering Pipeline","slug":"The-Graphics-Rendering-Pipeline","date":"2018-11-05T15:51:23.000Z","updated":"2019-08-02T03:28:18.915Z","comments":true,"path":"2018/11/05/The-Graphics-Rendering-Pipeline/","link":"","permalink":"https://uyouii.github.io/2018/11/05/The-Graphics-Rendering-Pipeline/","excerpt":"","text":"coarse division of the real-time rendering pipeline into four main stages: application [CPU] geometry processing [GPU] rasterization [GPU] pixel processing [GPU] The Application Stage collision detection is commonly implemented in this stage. the application stage is also the place to take care of input from other sources, such as the keyboard, the mouse, or a head-mounted display Acceleration algorithms, such as particular culling algorithms are also implemented here, along with whatever else the rest of the pipeline cannot handle. Geometry ProcessingThe geometry processing stage on the GPU is responsible for most of the per-triangle and per-vertex operations. It is further divided into the following functional stages: vertex shading projection clipping screen mapping Vertex Shading two main tasks: compute the position for a vertex evaluate whatever the programmer may like to have as vertex output data Traditionally much of the shade of an object was computed by applying lights to each vertex’s location and normal and storing only the resulting color at the vertex. These colors were then interpolated across the triangle. For this reason, this programmable vertex processing unit was named the vertex shader. shading: the operation of determining the effect of a light on a material. Projection orthographic projection perspective projection Although these matrices transform one volume into another, they are called projections because after display, the z-coordinate is not stored in the image generated but is stored in a z-buﬀer. In this way, the models are projected from three to two dimensions. Clipping A primitive that lies fully inside the view volume will be passed on to the next stage as is. Primitives entirely outside the view volume are not passed on further, since they are not rendered. It is the primitives that are partially inside the view volume that require clipping. Screen MappingThe x- and y-coordinates of each primitive are transformed to form screen coordinates. Screen coordinates together with the z-coordinates are also called window coordinates. RasterizationRasterization process is split up into two functional substages: triangle setup (primitive assembly) In this stage the diﬀerentials, edge equations, and other data for the triangle are computed. triangle traversal Finding which samples or pixels are inside a triangle is often called triangle traversal Pixel Processing Pixel processing is the stage where per-pixel or per-sample computations and operations are performed on pixels or samples that are inside a primitive. The pixel stage is divided into : pixel shading merging Pixel ShadingAny per-pixel shading computations are performed here, using the interpolated shading data as input. The end result is one or more colors to be passed on to the next stage. texturing is employed here. MergingA z-buﬀer is the same size and shape as the color buﬀer, and for each pixel it stores the z-value to the currently closest primitive. This means that when a primitive is being rendered to a certain pixel, the z-value on that primitiveat that pixel is being computed and compared to the contents of the z-buﬀer at the same pixel. If the new z-value is smaller than the z-value in the z-buﬀer, then the primitive that is being rendered is closer to the camera than the primitive that was previously closest to the camera at that pixel. If the computed z-value is greater than the z-value in the z-buﬀer, then the color buﬀer and the z-buﬀer are left untouched. However, the z-buﬀer stores only a single depth at each point on the screen, so it cannot be used for partially transparent primitives. These must be rendered after all opaque primitives, and in back-to-frontorder, or using a separate order-independent algorithm (Section 5.5). Transparency is one of the major weaknesses of the basic z-buﬀer. The alpha channel is associated with the color buﬀer and stores a related opacity value for each pixel. The stencil buﬀer is an oﬀscreen buﬀer used to record the locations of the rendered primitiveIt typically contains 8 bits per pixel. Primitives can be rendered into the stencil buﬀer using various functions, and the buﬀer’s contents can then be used to control rendering into the color buﬀer and z-buﬀer. To avoid allowing the human viewer to see the primitives as they are being rasterized and sent to the screen, double buﬀering is used. This means that the rendering of a scene takes place oﬀ screen, in a back buﬀer. Once the scene has been rendered in the back buﬀer, the contents of the back buﬀer are swapped with the contents of the front buﬀer that was previously displayed on the screen. The swapping often occurs during vertical retrace, a time when it is safe to do so.","categories":[{"name":"Real Time Rendering","slug":"Real-Time-Rendering","permalink":"https://uyouii.github.io/categories/Real-Time-Rendering/"}],"tags":[{"name":"graphics","slug":"graphics","permalink":"https://uyouii.github.io/tags/graphics/"},{"name":"real time rendering","slug":"real-time-rendering","permalink":"https://uyouii.github.io/tags/real-time-rendering/"}]},{"title":"读书摘要","slug":"读书摘要","date":"2018-07-05T08:36:39.000Z","updated":"2019-08-02T03:28:18.919Z","comments":true,"path":"2018/07/05/读书摘要/","link":"","permalink":"https://uyouii.github.io/2018/07/05/读书摘要/","excerpt":"","text":"神们自己 历史往往就是由这些讨厌而且毫无目的的冲动推动的。 有人认为，公众希望环境得以保护，人类的存续得以实现，还认为那些为了这类崇高目标而奋斗的理想主义者会得到公众的爱戴，这种想法都是错的。实际上，公众所期望的只有一件事：他们自己过上安逸舒适的生活。通过二十世纪的环境危机，我们早就看明白了。当人们知道吸烟会导致患癌症的几率上升而最有效的解决办法就是禁烟时，他们却希望能够发明一种不致癌的香烟。当人们知道内燃机会对大气造成污染而最好的办法就是不再使用这类引擎时，他们却希望能够发明不污染空气的引擎。 “他们只需要拒绝相信就行。面对难题，最容易的对策就是拒绝相信它的存在。” 凡是对自己有一点利益就会选择相信。有时候即使毫无可能，人们也会顽冥不化。 人间失格 那是我对人类最后的求爱。我对人类极度恐惧，却无论如何也无法对人类死心。 旁人承受的痛苦的性质和大小，我完全捉摸不透。现实生活中的痛苦，只是吃个饭就能化解的痛苦，或许才是莫大的痛苦。也许，我刚才所说的那十个灾祸在这些痛苦面前不值一提。也许那些我无法理解的痛苦才是凄惨的阿鼻地狱。果真如此嘛？我不知道。但即使如此，那些人依然不想轻生、不会发狂，纵谈政治、毫不绝望、毫不屈服，继续与生活作战。他们不觉得痛苦吗？他们变得自私自利，甚至视其为理所当然，难道他们从未怀疑过自己？若真如此，那真是快活。不是每个人都是如此吧？真的都满足于此吗？我不知道······在夜里酣然入睡，一早醒来就会神清气爽吗？他们做了怎样的梦？走路时想些什么？想着钱的事情？不会仅此而已吧？我似乎听过说“民以食为天”，却从未听过“人为钱而活”。不，也许因人而异吧······我还是搞不懂······思绪渐感困惑之时，我越发惶恐不安，仿佛自己是这个世界上的异类。我与旁人几乎无法交谈，因我不知该谈些什么，也不知该如何谈起。 因此我总是黯然接收外界打击，内心却承受着疯狂的恐惧。 受人责备或怒斥时，或许没有人能保持好心情。但我在人们怒不可遏的脸上，看到了比狮子、鳄鱼、巨龙更加可怕的动物本性。寻常时候，他们似乎会将这一本性刻意隐藏，但一有机会，人类可怕的真面目就会在愤怒中不经意的暴露出来。就像在草地上安稳打盹的牛，冷不防甩尾吗“啪”地打死肚子上地牛虻。每每见到人类露出本性，我都惊悚得汗毛倒竖。而一旦想到，这种本性或许是人活于世的必备资质之一，我简直要对自己绝望了。 对讨厌的事物说不出讨厌，对喜欢的事也总是偷偷摸摸，我总是品着极为苦涩的滋味，困难以名状的恐惧痛苦挣扎。 我一向对“向人诉苦”不抱任何期待。无论是向父母说，还是向警察或者政府说，最终还是会被那些深谙处世之道的人打败，任由他们花言巧语，喋喋不休。 相互欺骗的双方竟然都相安无事，甚至未曾察觉相互欺骗之事————我以为，人类生活中无处不是这样单纯、明了的不信任之举。 对人类极度恐惧的人，反而会比任何人都渴望亲眼见识妖怪的可怕。愈是敏感、愈是胆怯，愈会企盼暴风雨降临的更加猛烈。 对我而言，听女人就自己的身世说上千言万语，也不及一句低喃让我心生共鸣。我是如此期盼听到这句低语，然而我在这世上遇到的女子，竟没有一人向我如此诉说，我深感不可思议。眼前这名女子，虽然没有用言语变现自己的寂寞，但整个身体的轮廓却无声地吐露出巨大地寂寞气息。她的身旁仿佛充斥着约莫一寸见方的气流，走近她身旁，我的身体也被那气流说包裹。这气流与我自身携带的阴郁气流完美的融合，如贴在水底岩石上的枯叶一般，是我得以从恐惧与不安中抽离。 胆小鬼连幸福都会害怕，碰到棉花都会受伤，有时还会被幸福所伤。 天才在左，疯子在右 人之所以会产生一些妄想或者说是幻觉，主要是因为大脑不听使唤，左脑接受了来自右脑的错误指令，因而产生了歪曲的理解和判断。 缺乏安全感和孤独寂寞的人最容易出现妄想症，他们最初觉得“没人关系我”，后来演变为“有人要害我”。 视觉对于外界光线的感应能偶帮助我们维持生物钟的正常运转。但如果用光线照射我们的双眼，大脑便会由此“上当”，从而加速或者减缓我们的生理时钟的运转。 “马太效应”是社会心理学的经典效应，他向我们证明了强者恒强、弱者越弱的道理。如果一个人获得了成功，那么随之而来，各种好事情都会发生在他的身上。同样，如果一个人很衰，他就会遇到各种各样衰的事情。 心理学家认为，人的幸或者不幸，并不是上帝在天空中决定并安排好的，实际上一个人的运气好坏是由这个人的行为和思想决定的。 幸运的人通常乐观积极，活力四射，这样的心态让他们对未知的恐惧低于阈值，因为更容易接受新的挑战，更容易抓住新的机遇。而那些不幸的人则相反，他们多半性格孤僻，反应也不够敏捷。他们的情感关注点更多地集中于自己身上，因此很害怕周遭发生的会让自己感受到不舒服的改变。对他们而言，“未知”便是最大的恐惧和不安，处于恐惧中时，他们便会与大好的机会擦肩而过。 自我监控能力强的人显然更容易成为撒谎高手，而这种能力较弱的人，似乎用撒谎来掩饰自己的意识较差。 六度分隔假说，其含义是世界上任意两个欲取得联系的陌生人之间，最多只隔着六个人，便能够达成联系。 越是急于证明自己，就越是证明不了。因为没有人愿意跟着你的思路去思考问题。 车尔尼雪夫斯基说：“在人间有什么会更有诗意，更为迷人，胜于那怀着欢乐的爱，对自己觉得像自己本身一样崇高、纯洁和美妙的一切东西都发生共鸣的纯真的纯真的少年心灵呢？” 童年对一个作家的影响是深入骨髓的，是融贯在灵魂中的，同年是我们的精神故乡，同年所遭受的创伤会让人铭记在心。创伤在灵魂的深处生了根，就好像在土地中播撒了种子般，在岁月流逝中，种子逐渐发芽、长出了树枝，成长为参天大树，然而其根基仍然是当初的种子，是由幼时的创伤繁衍出来的。创伤及由此而形成的思想就由此成为作家作品的内核。 有人曾这样描述弗吉尼亚.伍尔夫：“她的记忆有着隐秘的两面——一面澄清，一面黑暗；一面寒冷，一面温热；一面创造，一面是毁灭；一面铺洒着天堂之光，一面燃烧着地狱之火。 解忧杂货店 他们内心都破了个洞，重要的东西正从那个破洞中流失。人的心声是绝对不能无视的。 很多时候，咨询的人心里已经有个答案，来咨询只是想确认自己的决定是对的。所以有些人读过回信后，会再次写信过来，大概就是因为回答的内容和他的想法不一样吧。 如果自己不想积极乐观的生活，不管得到什么样的回答都没有用。 虽然至今为止的道路绝非一片坦途，但想到正因为或者才有机会感受到痛楚，我就成功克服了种种困难。 人与人之间请以断绝，并不需要什么具体的理由。就算表面上有，也很可能只是心已经离开的结果，事后才编造出的借口而已。因为倘若心没有离开，当将会导致关系破裂的师太发生时，理应有人努力去挽救。如果没有，说明其实关系早已破裂。 可是换个角度来看，正因为是一张白纸，才可以随心所欲地描绘地图。一切全在你自己。对你来说，一切都是自由的，在你面前是无限的可能。这可是很棒的事呀。我衷心祈祷你可以相信自己，无悔地燃烧自己的人生。 话语教给我们很多，但善恶还是可以自明。话语想要教给我们，人与人生来就不平等。在人间，尊卑有序是永恒的真理，但你也可以不听。 无人生还 直到现在我才明白，艺术家永远不会只满足于创造艺术。他渴望自己的艺术得到世人的青睐，是人性使然。 小王子 如果有一个人爱上在这亿万颗星星中仅有的一朵花，这人望着星空的时候，就会觉得幸福。 审判自己，比审判别人难得多。你若是能够公正地审判自己，那你就是一个真正地贤士。 在我看来，你只不过是一个小男孩，跟成千上万地男孩毫无两样。我不需要你，你也不需要我。对你来说我只不过是一只狐狸，跟成千上万的狐狸毫无两样。但是，你如果驯养了我，那么我们俩就彼此相互需要。对我来说，你是世界上独一无二的；我在你看来，也是世界上独一无二的…… 只有用心看，才能看的清楚；本质的东西，眼睛是看不见的。 正是因为你为你的玫瑰，花费了时间，才使你的花儿变得那么重要。 对你驯养的东西，你要永远负责。你必须对你的玫瑰花负责…… “沙漠美丽”，小王子说，“是因为在某个地方藏着一口水井……” 无论是房子、星星或沙漠，使它们美丽的东西是看不见的。 这水，不只是一种饮料，它是从披星戴月地长途跋涉、轱辘的歌声、我的双臂的力量产生出来的。这水，像是一份礼物，使心田得到慰藉。在我小的时候，只有圣诞树的光、子夜弥撒的音乐、甜蜜的微笑，这一切才使得我的圣诞礼物光芒四射。 眼睛是什么也看不见的。应该用心灵去找。 你倘若爱上一朵生长在星星上的花，那么，在夜间，你看看天空就会感到愉快。所有的星星都像盛开的鲜花。 “每个人都有星星，“小王子说，”但在不同的人眼里就是不一样。对旅行者，星星是指引路的。对另一些人，星星只是一些小亮光。对学者，星星是探讨的问题。对我的那个商人，星星是黄金。但是，所有的星星都是一声不响的。你有的那些星星，是别人得不到的！“ ”你夜间仰望星空时，由于我就住在其中的一颗星星上，由于我在其中的一颗星上笑，那么，对你来说，所有的星星仿佛都在笑。唯有你，有一些会笑的星星。“ 情人 一种可以自由地支配时间的快感和一种怎样来支配这段时间的犹豫往往老是搅和在一起。 男人与女人并不是整天厮守在一起才算幸福，男人女人如果没有共同理想，各自没有独立的能力，很难保持男女间的关系至始至终。 不管怎么爱着这个男人，也不想失去自己一个人时的清静，自己 有属于自己的时间，这是最重要的。 但是人会喜欢上一个人也不是瞎说，世界上就是有着这种不合道理的道理，这要靠每个人的良知与道德修养来做出评判。 我可不是你想象的那样漂亮美丽、心地善良的女人呦。我有人们所具有的假面，在你看到的这假面背后，傲慢、猥琐、任性等等的毛病，我是应有尽有的呢。 男人与女人之间就应该有这么一面不能捅破的隔墙，才能使两人之间的关系保持长久的新鲜感。 也许有人会感到这种关系不太近人情。但是格子生活的全部都相互缠在一起，人生特有的趣味便会淡漠无存。 “请与我结婚吧”这句话，对女人来说都是梦寐以求的，不管她喜不喜欢这个男人。这句话，是绝对能将女人的心彻彻底底地打动地。 情人的地位确实不稳定，但同时却代表着美丽的存在。 忘记日常生活的琐碎杂事，相互体贴，相互慰藉。难得的见面，使双方都将自己的美德表现出来。生日呀，两人初恋的日子呀，每一个有意义的日子，两人都一起过，那样的时刻便是最珍贵，最幸福的。 有不少女人是只愿当情人，不愿做妻子的，这种情人的爱情，不是一生一世，而是一时一刻的。这样才更适合自己，能更自由自在，更能展示自己的魅力。为此而忌讳那种结婚名分的女人并不为少。 百年孤独 死神一直追随者他的脚步，嗅闻他的行踪，但尚未下定决心给他最后一击。 “世上正发生着不可思议的事情，”他对乌尔苏拉说，“就在那边，在河的另一边，各种魔法机器应有尽有，而我们却还像驴子一样生活。” 蕾梅黛丝在下午两点令人昏昏欲睡的空气中，蕾梅黛丝在玫瑰无声的呼吸中，蕾梅黛丝在清晨面包的热其中，蕾梅黛丝无所不在，蕾梅黛丝无视或缺。 你那么憎恨军人，跟他们斗了这么久，琢磨了他们这么久，最终却变得和他们一样。人世间没有任何理想值得以这样的沉沦作为代价。 约略懂得幸福的晚年秘诀不过是与孤独签下不失尊严的协定罢了。 过去都是假的，回忆没有归路，春天总是一去不复返，最疯狂执着的爱情也终究是过往云烟。","categories":[{"name":"bookread","slug":"bookread","permalink":"https://uyouii.github.io/categories/bookread/"}],"tags":[{"name":"booknote","slug":"booknote","permalink":"https://uyouii.github.io/tags/booknote/"}]},{"title":"python为什么是伪多线程","slug":"python为什么是伪多线程","date":"2018-07-05T08:35:01.000Z","updated":"2019-08-02T03:28:18.917Z","comments":true,"path":"2018/07/05/python为什么是伪多线程/","link":"","permalink":"https://uyouii.github.io/2018/07/05/python为什么是伪多线程/","excerpt":"","text":"python为什么是为多线程Python由于有全锁局的存在（同一时间只能有一个线程执行），并不能利用多核优势。所以，如果你的多线程进程是CPU密集型的，那多线程并不能带来效率上的提升，相反还可能会因为线程的频繁切换，导致效率下降；如果是IO密集型，多线程进程可以利用IO阻塞等待时的空闲时间执行其他线程，提升效率。 来源： https://www.zhihu.com/question/22191088/answer/20576021 GIL 全局解释器锁GIL：Global Interpreter Lock Python代码的执行是由Python虚拟机（又名解释器主循环）控制的。Python在设计时是这样考虑的，在主循环中同时只能有一个控制线程在执行，尽管Python解释器可以同时运行多个线程，但是在任意给定时刻只有一个线程会被解释器执行。 对Python虚拟机的访问是由全局解释器锁（GIL）控制的。这个锁就是用来保证同时只能有一个线程运行的。在多线程环境中，Python虚拟机将按照下面所述的方式执行： 设置GIL 切换进一个线程去运行 执行下面操作之一 指定数量的字节码指令 线程主动让出控制权（可以调用time.sleep(0)来完成） 把线程设置回睡眠状态（切换出线程） 解锁GIL 重复上述步骤 当调用外部代码（即，任意C/C++扩展的内置函数）时，GIL会保持锁定，直至函数执行结束（因为在这期间没有Python字节码计数）。","categories":[{"name":"learning python","slug":"learning-python","permalink":"https://uyouii.github.io/categories/learning-python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://uyouii.github.io/tags/python/"},{"name":"thread","slug":"thread","permalink":"https://uyouii.github.io/tags/thread/"}]},{"title":"ENet 源码分析","slug":"ENet 源码分析","date":"2018-05-14T09:23:00.000Z","updated":"2019-08-02T03:28:18.912Z","comments":true,"path":"2018/05/14/ENet 源码分析/","link":"","permalink":"https://uyouii.github.io/2018/05/14/ENet 源码分析/","excerpt":"","text":"ENet官方文档地址 首先看一下ENet官方给出的ENet的特性(Feature)。 ENet 特性ENet是一个具有TCP和UDP各自优点的基于UDP封装的一个网络库。 UDP缺少排序，连接管理，带宽管理，包大小限制等。TCP不能同时打开多个套接字故缺少多流的通信，并且由于其缓冲特性，其包管理机制过于复杂。 ENet则致力于将TCP和UDP的优点结合实现一个统一的网络协议库。 连接管理 (Connection Management)ENet提供了一个简单的与外部主机通信的接口。连接的生命周期通过频繁的ping外部主机动态监管，同时通过主机与外部机器的包的往返时间和丢包情况来监管网络状况。 排序 (Sequencing)ENet提供了多个的合理排序的网络包流而不是一个单一的比特流从而简化了不同类型数据的传输。 ENet通过为每个发送的网络包编号来实现对包的排序。这些序号会随着包的发送而增长。ENet保证序列号低的包优先发送，从而确保了所有的网络包都按次序发送。 对于不可靠的网络包，如果具有高序号的网络包已经到达，ENet则会简单的丢弃那些低序号的网络包。这样就保证了网络包到达后就可以立即被接收，从而减少了网络延时。对于可靠的网络包，如果一个高序号的包已经到达，但是之前的包确没有到达，ENet会推迟高序号包的接受直到其之前相应序号的网络包均已到达。 通道 (Channels)既然ENet会推迟可靠网络包的提交来确保网络包的序号，但是无论到达的包是可靠的还是不可靠的，如果之前的网络包是可靠的包，他们都要被推迟提交，这样做可能会造成一些不需要严格保证次序的包同样被推迟提交，从而造成额外的延时。 为了解决上述问题并减少对包的次序的限制，ENet为一个连接提供了多个交流的通道(channel)。每个通道下的网络包可以独立排序，所以一个通道下的包的传送状态不会影响其他通道下的包的传送。 可靠性 (Reliability)ENet为传送的包提供了可靠性选择，并确保外部主机会确认收到所有的可靠的网络包。如果外部主机在特定时间内没有确认收到网络包，ENet会尝试在合理的次数内重传这个网络包。 重传超时的时间会根据失败次数的增加变得更加宽松便于应对网络临时的混乱和拥塞。 拆分和重组 (Fragmentation and Reassembly)ENet在发送包的时候不会考虑包的大小。大的网络包会被分成若干个大小合适的网络包，并在外部机器上重组为发送前的网络包便于远程机器接收。整个过程对于开发者来说都是透明的。 聚合 (Aggregation)ENet包括了大部分协议指令，包括acknowledgement，packet transfer，确保连接的可用性，减少丢包的机会及其可能造成的延时等。 适应性 (Adaptability)ENet为可靠包提供了一个动态适应的数据窗口以确保连接不会大量的网络包淹没掉。它也提供了一个静态的带宽分配机制以确保机器在发送和接受包时不会超过这个机器承载的范围。更近一步，ENet提供了一个动态的阀门来响应网络连接时带来的偏差，通过限制发送发送包的数量来应对各种类型的网络拥塞问题。 ENet数据结构ENetHostENetHost即ENet的客户端。 1234567891011121314151617181920212223242526272829303132333435363738typedef struct _ENetHost&#123; ENetSocket socket; ENetAddress address; enet_uint32 incomingBandwidth; enet_uint32 outgoingBandwidth; enet_uint32 bandwidthThrottleEpoch; enet_uint32 mtu; enet_uint32 randomSeed; int recalculateBandwidthLimits; ENetPeer * peers; size_t peerCount; size_t channelLimit; enet_uint32 serviceTime; ENetList dispatchQueue; int continueSending; size_t packetSize; enet_uint16 headerFlags; ENetProtocol commands [ENET_PROTOCOL_MAXIMUM_PACKET_COMMANDS]; size_t commandCount; ENetBuffer buffers [ENET_BUFFER_MAXIMUM]; size_t bufferCount; ENetChecksumCallback checksum; ENetCompressor compressor; enet_uint8 packetData [2][ENET_PROTOCOL_MAXIMUM_MTU]; ENetAddress receivedAddress; enet_uint8 * receivedData; size_t receivedDataLength; enet_uint32 totalSentData; enet_uint32 totalSentPackets; enet_uint32 totalReceivedData; ENetInterceptCallback intercept; size_t connectedPeers; size_t bandwidthLimitedPeers; size_t duplicatePeers; size_t maximumPacketSize; size_t maximumWaitingData; &#125; ENetHost; 内部变量 作用 socket 用于数据传输和连接的UDP套接字句柄 address host的socket地址 incomingBandwidth host接收数据的带宽，即download bandwidth outgoingBandwidth host上传数据的带宽，即upstream bandwidth bandwidthThrottleEpoch 记录host流量控制的时间戳，如果流量控制的时间间隔超过bandwidthThrottleEpoch，则进行流量控制。host流量控制时间间隔设置为1000ms。 mtu 即最大传输单元，当需要发送的单个packet的大小超过该值时会进行分片操作 randomSeed 用于生成connectID的随机数种子 recalculateBandwidthLimits 用于记录是否需要重新计算带宽的标记变量，当有peer连接或者断开连接时会被置为1 peers host中用于储存peer的数组，在host初始化时设置，大小为peerCount。 peerCount 创建host时指定的peerCount，即最大的peer数。如果此时的peer数为peerCount，则在发起连接或者被动连接（收到connect command）时会失败，没有空间容纳新的peer。 channelLimit 每个peer中可以容纳的channel数，最大为255，最小为1。 serviceTime 标记host当前时间的时间戳 dispatchQueue 待处理的peer队列。当peer中有event产生时，则将peer放入dispatchQueue中。 continueSending 用于标记peer中的数据是否发送完的变量。在发送peer中的数据时为保证公平性，则对peer进行轮询发送，每次至多发送一个数据量小于mtu udp数据报，如果peer中数据没有发送完，则将该变量置为1，在下次循环继续发送。 packetSize 用于标记当前待发送的udp数据报中数据的大小，在添加数据前如果packetSize大小大于mtu，则将continueSending置为1，跳出循环，将当前数据发送出去，等待下次循环中发送剩余数据。 headerFlags 标记发送特性的一些flag，例如是否发送当前时间，是否需要压缩等。host-&gt;headerFlags会携带到发送数据报的头部中发送到peer端。 commands 用于储存当前待发送udp数据报中的command commandCount 记录当前待发送udp数据报中的command的数量，如果需要发送的command的数量大于ENET_PROTOCOL_MAXIMUM_PACKET_COMMANDS，则将当前数据报发送出去，剩余数据等待下次循环发送。 buffers 储存需要发送数据的buffer，用于传递给socket接口发送数据 bufferCount 记录buffers中buffer的个数，同样传递给相应socke接口用于数据发送。最大值为ENET_BUFFER_MAXIMUM，如果buffers中buffer的个数大于该值，则先将当前数据报发送出去，剩余数据等待下次循环发送。 checksum 计算校验和的回调函数，需要用户自己设置 compressor 用于压缩和解压的结构变量，需要用户自己设置 packetData 一个二维数组，其中packetData[0]用于储存接收的数据，packetData[1]用于储存压缩后待发送的数据 receivedAddress 接收数据的socket地址，host和port都设为0则意味接收任意地址的数据 receivedData 用于标记当前读取到packetData[0]中位置的指针 receivedDataLength 当前接收的数据的长度 totalSentData host发送出的总的数据量 totalSentPackets host发送出的总的udp数据报数 totalReceivedData host接收的总的数据量 totalReceivedPackets host接收的总的udp数据报数 connectedPeers 当前连接的peer的数量 bandwidthLimitedPeers 需要进行流量控制的peer的数量 duplicatePeers 允许重复的ip的最大的peer的数量，默认值为ENET_PROTOCOL_MAXIMUM_PEER_ID maximumPacketSize 允许一个单个的ENetPacket发送和接收的最大的数据量 maximumWaitingData 允许等待在buffer中的最大的数据量 ENetPeer用于储存通信对端的信息的数据结构，同时控制数据的发送，重传等操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263typedef struct _ENetPeer&#123; ENetListNode dispatchList; struct _ENetHost * host; enet_uint16 outgoingPeerID; enet_uint16 incomingPeerID; enet_uint32 connectID; enet_uint8 outgoingSessionID; enet_uint8 incomingSessionID; ENetAddress address; void * data; ENetPeerState state; ENetChannel * channels; size_t channelCount; enet_uint32 incomingBandwidth; enet_uint32 outgoingBandwidth; enet_uint32 incomingBandwidthThrottleEpoch; enet_uint32 outgoingBandwidthThrottleEpoch; enet_uint32 incomingDataTotal; enet_uint32 outgoingDataTotal; enet_uint32 lastSendTime; enet_uint32 lastReceiveTime; enet_uint32 nextTimeout; enet_uint32 earliestTimeout; enet_uint32 packetLossEpoch; enet_uint32 packetsSent; enet_uint32 packetsLost; enet_uint32 packetLoss; enet_uint32 packetLossVariance; enet_uint32 packetThrottle; enet_uint32 packetThrottleLimit; enet_uint32 packetThrottleCounter; enet_uint32 packetThrottleEpoch; enet_uint32 packetThrottleAcceleration; enet_uint32 packetThrottleDeceleration; enet_uint32 packetThrottleInterval; enet_uint32 pingInterval; enet_uint32 timeoutLimit; enet_uint32 timeoutMinimum; enet_uint32 timeoutMaximum; enet_uint32 lastRoundTripTime; enet_uint32 lowestRoundTripTime; enet_uint32 lastRoundTripTimeVariance; enet_uint32 highestRoundTripTimeVariance; enet_uint32 roundTripTime; enet_uint32 roundTripTimeVariance; enet_uint32 mtu; enet_uint32 windowSize; enet_uint32 reliableDataInTransit; enet_uint16 outgoingReliableSequenceNumber; ENetList acknowledgements; ENetList sentReliableCommands; ENetList sentUnreliableCommands; ENetList outgoingReliableCommands; ENetList outgoingUnreliableCommands; ENetList dispatchedCommands; int needsDispatch; enet_uint16 incomingUnsequencedGroup; enet_uint16 outgoingUnsequencedGroup; enet_uint32 unsequencedWindow [ENET_PEER_UNSEQUENCED_WINDOW_SIZE / 32]; enet_uint32 eventData; size_t totalWaitingData;&#125; ENetPeer; 内部变量 作用 dispatchList 在host中的dispatchQueue的链表节点。每当该peer产生一个event时，便将peer放入 host-&gt;disptachQueue中 host peer所在的host的指针 outgoingPeerID 对端host-&gt;peers中的peer的index incomingPeerID peer在本地host-&gt;peers中的index connectID 在创建host时会生成一个随机数种子，每次请求新的连接时，会将随机数种子递增1产生 connectID。用于匹配收到的 verify connect 是否对应之前connect请求。当需要计算校验和时，connectID也参与校验和的计算。 outgoingSessionID 本地用于发送时封装protocol header的会话号，接收端在收到数据报时会将该 sessionid 取出与接收端的peer-&gt;incomingSessionID进行匹配。 incomingSessionID 没到收到一个udp数据报时，会将protocol header中封装的session ID 取出与本地的incomingSessionID匹配，用于判断收到的数据报是否属于本次会话。 address 该peer的socket地址 state peer当前的状态，例如已经连接，断开连接等。 channels peer用于发送数据的channel channelCount channels的大小 incomingBandwidth 该peer下载的带宽(字节/秒) outgoingBandwidth 该peer上传的带宽(字节/秒) incomingBandwidthThrottleEpoch 在调节packetThrottle时用于记录调节该peer下载带宽的时间戳 outgoingBandwidthThrottleEpoch 在调节packetThrottle时用于记录调节该peer上传带宽的时间戳 incomingDataTotal 记录在流量控制的间隔时间内从该peer接收的总的数据量的大小 outgoingDataTotal 记录在流量控制的间隔时间内向该peer发送的总的数据量的大小 lastSendTime 记录上次发送数据包的时间戳 lastReceiveTime 记录上次收到ack的时间，如果超过一定时间没有收到ack，则host会向该peer发送ping包用于判断该peer是否已经断开连接 nextTimeout 下次有数据包超时的时间戳。在发送command和接收ack时会根据数据包的rto设置peer下次超时的时间戳。如果检测到当前时间戳大于该值，则调用enet_protocol_check_timeouts进行超时检测。 earliestTimeout 记录当前时间段内的最早的超时时间。每当收到ack时会将earliestTimeout重置为0 packetThrottle 流量控制的阀门，通过该值进行流量控制，最大值为32，最小为1 packetThrottleLimit 在进行流量控制时会根据peer设置的带宽计算出该peer的packetThrottle的上限，确保数据的发送不会超过host的发送能力和peer的接收能力。packetThrottle的大小不会超过packetThrottleLimit的大小 packetThrottleCounter 在发送不可靠包时会根据packekThrottleCounter的值和packetThrottle的值判断是否会在发送前丢掉该不可靠包 packetThrottleEpoch 记录当前更新lastRoundTripTime,lastRoundTripTimeVariance,lowestRoundTripTime,highestRoundTripTimeVariance的时间戳，每隔packetThrottleInterval的时间间隔会刷新一次 packetThrottleAcceleration 每当收到rtt时用于增加packetThrottle的增量 packetThrottleDeceleration 每当收到rtt试用于减少packetThrottle的增量 packetThrottleInterval 流量控制中相应变量更新周期的大小 pingInterval 如果超过pingInterval的时间没有收到ack，则向peer发送一个ping包，用于探测是否断开连接 lastRoundTripTime 记录上个流量控制周期中最小的rtt lowestRoundTripTime 记录当前流量控制周期中最小的rtt lastRoundTripTimeVariance 记录上个流量控制周期中最大的rtt的变化值 highestRoundTripTimeVariance 记录当前流量控制周期中最大的rtt的变化值 roundTripTime 该peer当前平滑的rtt roundTripTimeVariance 该peer当前平滑的rtt的变化值 mtu 该peer的最大传输单元，当需要发送的单个packet的大小超过该值时会进行分片操作 reliableDataInTransit 正在传输过程中的可靠包的大小（已经发送但没有收到ack的），如果其值超过由packetThrottle计算出的发送窗口的大小，则暂停发送 outgoingReliableSequenceNumber 由peer发送的ENet的系统指令的当前的包的序号。所谓系统指令指connect，disconnect，ping等指令。而reliable，unreliable数据包会在channel中发送，用的是channel的序号。 acknowledgements 等待发送ack的队列 sentReliableCommands 已经发送reliable但是没收到ack的队列 sentUnreliableCommands 已经发送的unreliable的队列 outgoingReliableCommands 等待发送reliable的队列 outgoingUnreliableCommands 等待发送unreliable的队列 dispatchedCommands 已经收到的，等待用户处理的指令队列 needsDispatch 是否需要用户处理，如果dispatchedCommands队列中有指令，则将该值置为1 incomingUnsequencedGroup peer记录的当前到来的unsequenced数据包的该group的头部的序号 outgoingUnsequencedGroup 发送的unsequenced数据包的序号 unsequencedWindow 用位图的方式记录当前unsequenced group的数据包有没有重复 totalWaitingData ENet已经收到的但是用户还未处理的数据大小的总和 SessionID的作用ENet使用简单的SessionID的匹配防止两个具有相同ip地址和端口号的前后两次连接发送的数据发生混淆。（这种情况是在断开连接后如果发起的新的连接的端口号和之前的端口号相同，在连接时会被判定为相同的连接，这时如果之前连接发送的网络包在网络中没有消逝并发送到对端，会与本次的连接发送的数据产生混淆。TCP使主动断开连接的一方处于TIME_WAIT的状态来防止这种情况的发生。） 在每次请求连接时，接收请求连接的一方会更新相应的session并返回给该peer，在第二次握手时请求连接方会同步该Session的数值。在每次发送数据时会将SessionID包含在ENetProtocolHeader.peerID中，接收端在每次收到UDP数据报时会首先检测protocol header中的session ID不匹配，则丢掉该数据报中的数据，表明该数据报不是本次连接中发送的数据。 因为仅仅时简单的ID匹配，所以并不能像TCP那样100%防止两次连接中数据包混淆这种情况的发生，但是大部分情况下仍是有效的。 ENet Channel每个peer中会有多个Channel用于数据的发送，每个Channel发送和接收数据的过程和对command的编号彼此是独立的。 1234567891011typedef struct _ENetChannel&#123; enet_uint16 outgoingReliableSequenceNumber; enet_uint16 outgoingUnreliableSequenceNumber; enet_uint16 usedReliableWindows; enet_uint16 reliableWindows [ENET_PEER_RELIABLE_WINDOWS]; enet_uint16 incomingReliableSequenceNumber; enet_uint16 incomingUnreliableSequenceNumber; ENetList incomingReliableCommands; ENetList incomingUnreliableCommands;&#125; ENetChannel; 内部变量 作用 outgoingReliableSequenceNumber channel中当前发送的可靠包的序号 outgoingUnreliableSequenceNumber channel中当前发送的不可靠包的序号 usedReliableWindows 用位图的方式记录已经使用的发送窗口的序号 reliableWindows 每个发送窗口中已经发送但是还没有收到ack的指令的个数 incomingReliableSequenceNumber 已经收到的可靠包的序号 incomingUnreliableSequenceNumber 已经收到的不可靠包的序号 incomingReliableCommands 已经收到的reliable数据包，等待有序排序后转到peer-&gt;dispatchedCommands队列中 incomingUnreliableCommands 已经收到的unreliable的数据包，等待转到peer-&gt;dispatchedCommands队列中 关于reliableWindow由于ENet采用的是选择重传的方式，为保证新窗口与老窗口的序号没有重叠，窗口的最大尺寸不应该超过序号空间的一半。ENet在发送新的数据包时会通过usedReliableWindows判断当前窗口占用是否与空闲窗口重叠，如果重叠则暂停数据包的发送。reliableWindows会记录各个窗口中目前在传输中的包的个数。 ENet 协议ENet发送数据时以一个udp数据报为单位，在发送时首先会在每个udp数据报的头部包含一个4个字节的protocol header表明当前数据报内的各个command由哪个peer发送和相应的发送时间。 在protocl header后会包含多个command。 1234 |&lt;------------ command1 -----------&gt;|&lt;------------ command2 -----------&gt;| -------------------------------------------------------------------------------------------------------| protocol Header | command1 header | command1 data | command2 header | command2 data | ...------------------------------------------------------------------------------------------------------- 协议头部 (Protocol Header)12345typedef struct _ENetProtocolHeader&#123; enet_uint16 peerID; enet_uint16 sentTime;&#125; ENET_PACKED ENetProtocolHeader; Protocol Header是ENet整个协议的头部，由于ENet底层由UDP封装而成，在发送UDP数据报时该字段会放在整个UDP数据报的头部，用于标记该数据报的peer和发送时间。 与TCP的端对端连接不同，ENet可以是多对多的连接，所以需要peerID字段标记相应的peer。peerID的同步会在三次握手时同步完成。 protocol header12345|&lt;------------ 4 bytes ------------&gt;|+--------+--------+--------+--------+| peerID | sentTime | +--------+--------+--------+--------+ |&lt;---------protocol header---------&gt;| 指令头部(Command Header)ENet中共有12种command，其中每个command会有一个相同的4个字节的command heaer，包含command每个command必须的信息：command类型，所在的channelID和该command的序列号。除去command header，每个command剩余的内容根据command类型而不同，所以ENet不同类型的command的大小是不同的。 123456typedef struct _ENetProtocolCommandHeader&#123; enet_uint8 command; enet_uint8 channelID; enet_uint16 reliableSequenceNumber;&#125; ENET_PACKED ENetProtocolCommandHeader; 在每次发送的UDP的数据报中可能会包含多个指令(Command)，所以由每个指令的头部来标记该指令的信息，包括: command: 指令类型 channelID:该command的所在channel的序号 reliableSequenceNumber:该指令在相应channel的序号 每个指令对应固定的格式，所以根据command对应的指令类型，便可以得到该指令对应的长度。 command header12345|&lt;-------------------- 4 bytes --------------------&gt;|+------------+------------+------------+------------+| command | channelID | reliableSequenceNumber | +------------+------------+------------+------------+ |&lt;------------------command header-----------------&gt;| ENet 协议类型ENet共有12种协议类型，每种协议类型会对应一个Command Number。 协议类型定义如下：12345678910111213141516171819typedef enum _ENetProtocolCommand&#123; ENET_PROTOCOL_COMMAND_NONE = 0, ENET_PROTOCOL_COMMAND_ACKNOWLEDGE = 1, ENET_PROTOCOL_COMMAND_CONNECT = 2, ENET_PROTOCOL_COMMAND_VERIFY_CONNECT = 3, ENET_PROTOCOL_COMMAND_DISCONNECT = 4, ENET_PROTOCOL_COMMAND_PING = 5, ENET_PROTOCOL_COMMAND_SEND_RELIABLE = 6, ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE = 7, ENET_PROTOCOL_COMMAND_SEND_FRAGMENT = 8, ENET_PROTOCOL_COMMAND_SEND_UNSEQUENCED = 9, ENET_PROTOCOL_COMMAND_BANDWIDTH_LIMIT = 10, ENET_PROTOCOL_COMMAND_THROTTLE_CONFIGURE = 11, ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE_FRAGMENT = 12, ENET_PROTOCOL_COMMAND_COUNT = 13, ENET_PROTOCOL_COMMAND_MASK = 0x0F&#125; ENetProtocolCommand; 由于在协议中每个Command Number由一个字节储存，但是总共的协议号不超过16，所以4个bit便足够储存，剩下的4位bit ENet用于标记该Command的一些特性，例如是否需要排序，是否需要发送验证（Ack）等。 Acknowledge指令12345678910111213141516171819202122232425262728293031323334typedef struct _ENetProtocolAcknowledge&#123; ENetProtocolCommandHeader header; enet_uint16 receivedReliableSequenceNumber; enet_uint16 receivedSentTime;&#125; ENET_PACKED ENetProtocolAcknowledge;``` Acknowledge是接收确认指令，在收到可靠包后需要向发送端发送Acknowledge指令来表明已经收到了相应的数据包。其中包含了：- **header**: 相应command的头部- **receivedReliableSequenceNumber**: 需要返回Ack的相应指令的序号（不是该Acknowledge的序号，而是其对应发送端发送的指令的序号）- **receivedSentTime**:其对应指令的发送时间，用于计算相应指令的rtt。对于每个`CommandHeader`中commnd参数带有`ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE`标记的command，接收端都会向发送端发送Ack指令。如果发送端在相应时间内没有收到Ack，则会重发该command，直到收到Ack。`ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE`的值是`1 &lt;&lt; 7`,占用commandNumber中空白位来标记该command是否需要重传。### Connect指令```ctypedef struct _ENetProtocolConnect&#123; ENetProtocolCommandHeader header; enet_uint16 outgoingPeerID; enet_uint8 incomingSessionID; enet_uint8 outgoingSessionID; enet_uint32 mtu; enet_uint32 windowSize; enet_uint32 channelCount; enet_uint32 incomingBandwidth; enet_uint32 outgoingBandwidth; enet_uint32 packetThrottleInterval; enet_uint32 packetThrottleAcceleration; enet_uint32 packetThrottleDeceleration; enet_uint32 connectID; enet_uint32 data;&#125; ENET_PACKED ENetProtocolConnect; connect指令用于主动发起连接的一端进行主动连接操作，其中包含的参数较多： header: command的头部 outgoingPeerID: 对应本地端的ENetPeer.incomingPeerID，后续通信通过该peerID访问host-&gt;peers中的相应的peer。 incomingSessionID: 对应本地端的ENetPeer.incomingSessionID，本地用于匹配对端发送的Session ID，即每次收到该peer的UDP数据报时会与数据报中的Session ID的值进行匹配。 outgoingSessionID: 对应本地端的ENetPeer.outgoingSessionID，本地用于发送时封装protocol header的会话号，接收端在收到数据报时会将该sessionid取出与接收端的incomingSessionID进行匹配。 mtu:即最大传输单元。在发送数据大小大于mtu的packet时，ENet会在本地进行分片，并在接收端进行重组。 windowSize: ENet发送窗口的大小，控制ENet在传输过程中的可靠包的数据量。每个peer会独立计算windowSize，在发送数据包时如果检测到正在传输的数据 channelCount:channel的数量 incominBandwidth: 对应本地的host-&gt;incomingBandwidth，即host的下载带宽。 outgoingBandwidth: 对应本地的host-&gt;outgoingBandwidth，即host的上传带宽。 packetThrottleInterval: 通过rtt对packetThrottle调节周期的设置。 packetThrottleAcceleration： packetThrottleDeceleration： connectID：防止重复的连接（比如：connect 命令丢掉后重发） Verify Connet指令verify Connect用于三次握手连接的第二次握手，同时用于主动连接方同步被动连接方的相关信息。 12345678910111213141516typedef struct _ENetProtocolVerifyConnect&#123; ENetProtocolCommandHeader header; enet_uint16 outgoingPeerID; enet_uint8 incomingSessionID; enet_uint8 outgoingSessionID; enet_uint32 mtu; enet_uint32 windowSize; enet_uint32 channelCount; enet_uint32 incomingBandwidth; enet_uint32 outgoingBandwidth; enet_uint32 packetThrottleInterval; enet_uint32 packetThrottleAcceleration; enet_uint32 packetThrottleDeceleration; enet_uint32 connectID;&#125; ENET_PACKED ENetProtocolVerifyConnect; 其中参数基本和connect命令中的参数相同，不一一列举了。 Protocol Bandwidth Limit指令123456typedef struct _ENetProtocolBandwidthLimit&#123; ENetProtocolCommandHeader header; enet_uint32 incomingBandwidth; enet_uint32 outgoingBandwidth;&#125; ENET_PACKED ENetProtocolBandwidthLimit; Bandwidth Limit指令用于流量控制时调节对端对应本地的peer的带宽的相应的数值。 header: command的头部 incomingBandwidth: 对应本地端的host-&gt;incomingBandwidth，设置对端的peer对应本地的host的下载带宽的数值。 outgoingBandwidth: 对应本地端的host-&gt;outgoingBandwidth，设置对端的peer对应本地host的上行带宽的数值。 Throttle Configure 指令1234567typedef struct _ENetProtocolThrottleConfigure&#123; ENetProtocolCommandHeader header; enet_uint32 packetThrottleInterval; enet_uint32 packetThrottleAcceleration; enet_uint32 packetThrottleDeceleration;&#125; ENET_PACKED ENetProtocolThrottleConfigure; Throttle Configure用于调节由rtt控制 packetThrottle的相关设置，关于packetThrottle的作用请看ENet流量控制相关章节。 header: command的头部 packetThrottleInterval: peer调节rtt相关参数的周期 packetThrottleAcceleration: 根据rtt调节packetThrottle的增加的速率 packetThrottleDeceleration： 根据rtt调节packetThrottle的减小的速率 Disconnect 指令12345typedef struct _ENetProtocolDisconnect&#123; ENetProtocolCommandHeader header; enet_uint32 data;&#125; ENET_PACKED ENetProtocolDisconnect; 用于断开连接。 Ping指令1234typedef struct _ENetProtocolPing&#123; ENetProtocolCommandHeader header;&#125; ENET_PACKED ENetProtocolPing; ENet当检测到超过一定的时间没有收到ack时便会发送ping指令以判断当前相连的peer是否已经断开连接。因为是探测指令，所以只发送指令头即可。 Send Reliable 指令12345typedef struct _ENetProtocolSendReliable&#123; ENetProtocolCommandHeader header; enet_uint16 dataLength;&#125; ENET_PACKED ENetProtocolSendReliable; 用于发送不用分片的可靠包的指令，在发送时，相应的data数据会跟在指令的后面。 header: 指令头部 dataLength: 发送数据的长度 Send Unreliable 指令123456typedef struct _ENetProtocolSendUnreliable&#123; ENetProtocolCommandHeader header; enet_uint16 unreliableSequenceNumber; enet_uint16 dataLength;&#125; ENET_PACKED ENetProtocolSendUnreliable; 发送不需要分片的Unreliable指令，与ENet unrealiable包的实现机制相关，不仅需要携带reliable sequence number，还需要携带unreliable sequence number。 unreliableSequeceNumber: 不可靠包的序号 dataLength: 发送数据的长度 Send Unsequenced指令123456typedef struct _ENetProtocolSendUnsequenced&#123; ENetProtocolCommandHeader header; enet_uint16 unsequencedGroup; enet_uint16 dataLength;&#125; ENET_PACKED ENetProtocolSendUnsequenced; 发送不需要分片的Unsequenced指令，与reliable包和unreliable包的实现都不同，unsequenced不会用到header中的reliable sequence number，而是用相应的unsequencedGroup标记相应的序号。 unsequencedGroup: 用于标记unsequenced包的序号 dataLength: 需要发送的数据的长度 Send Fragment指令12345678910typedef struct _ENetProtocolSendFragment&#123; ENetProtocolCommandHeader header; enet_uint16 startSequenceNumber; enet_uint16 dataLength; enet_uint32 fragmentCount; enet_uint32 fragmentNumber; enet_uint32 totalLength; enet_uint32 fragmentOffset;&#125; ENET_PACKED ENetProtocolSendFragment; fragment用于发送所有需要分片的数据包，通过flag标记相应包的类型，例如reliable和unreliable等。 startSequenceNumber: 被分片的数据包的开始的序号 dataLength: 该分片携带的数据的长度 fragmentCount: 总的分片的数量 fragmentNumber: 该分片在所有分片中的序号，从0开始 totalLength: 分片前的总的数据长度 fragmentOffset: 该分片的起始位置在分片前的数据包中的偏移量 ENet数据包类型ENet中主要的数据包类型有：Reliable，Unreliable和Unsequenced和系统指令。 数据包的类型是通过commandheader中的command的携带的protocolFlag标记的。 由于command有8个字节，而ENet只有13种指令，只需要用到前4个bit，所以剩下的bit可以用来标记相应的数据包的类型，用于标记数据包的类型主要有两个flag：12ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE = (1 &lt;&lt; 7),ENET_PROTOCOL_COMMAND_FLAG_UNSEQUENCED = (1 &lt;&lt; 6), acknowledge和unsequenced。 如果标记unsequenced，则该数据包对应为unsequence数据包。如果标记acknowledge，则对应reliable数据包，意味着需要对端返回ack指令。如果都没有标记，则对应unreliable数据包。 系统指令一般是reliable的，如果标记了unsequenced，则会当成unsequenced处理，例如diconnectnow功能中的disconnect指令。 系统指令系统指令包括有：connect,verifyConnect, disconnect, ping, bandwidthLimit, throttleConfigure。 系统指令所在的Channel是255，即不会占用peer中的任何一个channel。 系统指令一般都是需要对端发送ack的。 并且系统指令的发送不会受流量控制的限制，流量控制只是针对发送数据包的指令有效。 Reliable数据包如果相应命令标记了acknowledge，则会要求接收方收到后返回ack指令，如果没有收到ack，则会对数据包进行重传。如果重传次数超过一定的限制，则对该peer进行断开连接。 如果命令标记acknowledge的命令是ENetProtocolSendReliable和ENetProtocolSendFragment类型，接收方还会对指令进行排序。 对于ENetProtocolSendReliable则会对数据包进行排序，之后收到连续有序的数据包才会dispatch给用户。如果序号较大的数据包已经到达，而之前的数据包没有到达，ENet则会等待之前的数据包都到达以后，才会将相应的数据包发给用户。 对于ENetProtocolSendFragment类型的指令，接收方只有当分片中所有的数据包都收到后才会将数据dispatch给用户，如果有任何一个没有收到，则会等待至所有数据包都收到后。 reliable数据包的流量控制通过packetThrottle计算发送窗口大小实现，如果发现已经在传输中的reliable数据的量超过发送窗口大小，则会暂停对reliable数据包的传输，直到有空闲的发送窗口大小。 Unreliable 数据包对于Unreliable数据包，不会要求对端返回ack指令，同样会对数据包进行排序，但是与reliable数据包不同的是，如果后续的数据包已经到达，而之前的数据包则没有收到，则直接会将已经收到的数据包dispatch给用户，如果之前的数据包再次到达的话，则会直接丢弃。 并且Unreliable数据包的编号需要依赖reliable 序号，每次发送reliable数据包时，都会将unreliable数据包的编号重置为0开始传输。每个unreliable数据包会携带当前channel的reliable序号和unreliable序号。如果后续的reliable序号已经到达，则当前unreliable会被丢弃，如果后续的unreliable包到达，则当前unreliable序号同样会丢弃。 同时需要注意的一个细节是，ENet的每个数据包的sequence number的大小只有16位，也就是说最大序号只有65535，如果需要overflow的话，会从0开始重新统计。reliable包在进行接收的时候会判断当前的序号有没有已经overflow，但是对unreliable包确没有进行这种判断。 对于fragment的unreliable数据包，同样会等待所有分片都到达后才会将该数据包dispatch给用户，如果在处理分片的过程中，有该所有分片的后续序号的数据包到达，该分片中所有的数据包也会被丢弃。 unreliable数据包在进行流量控制的时候是通过packetThrottle计算一个数值在发送前进行概率性的随机丢弃的。如果packetThrottle是最大值，则不会丢弃，如果packetThrottle的值越小，则被丢弃的可能性越大。 Unsequenced数据包Unsequenced数据包同样是不会要求返回ack命令的，与unreliable不同的是，它不会依赖于reliable序号，也不会排序，对端只要收到，便会直接dispatch给用户。 unsequended数据包占用的队列其实是unreliable数据包的队列，所以流量控制也与unreliable数据包相同，会通过pakcetThrottle计算数值概率随机丢弃。 unsequenced数据包没有分片类型，如果需要分片，则会直接转成unreliable fragment发送。 ENet整体流程框架收发数据过程ENet会在创建时建立一个ENetHost作为通信的客户端，host中包含与peer进行通信的socket，一个ENetList dispatchQueue：用于存放有事件产生的peer队列，和一个ENetPeer* peers数组用于存放与外部客户端通信的peer数据结构。 每个ENetPeer结构主要用于管理与外部的连接和数据发送，ENetPeer中用于数据发送的队列主要有5个：12345ENetList acknowledgements;ENetList sentReliableCommands;ENetList sentUnreliableCommands;ENetList outgoingReliableCommands;ENetList outgoingUnreliableCommands; acknowledgements: 用于发送ack sentReliableCommands: 用于储存已经发送的可靠包 sentUnreliableCommands: 用于储存已经发送的不可靠包 outgoingReliableCommands: 准备发送的可靠包队列 outgpingUnreliableCommands: 准备发送的不可靠包队列 其中需要ack的指令均由reliable队列管理，unreliable和unsequenced数据包均由unreliable队列管理。 在调用enet_peer_send函数时，会将需要发送的数据压入到outgoing队列中。而ack则是在收到可靠包时，将数据压入到acknowledgements队列中。 peer中还有一个队列：1ENetList dispatchedCommands; 用于储存已经接收好准备dispatch给用户的数据。 每个ENetPeer中还有一个ENetChannel数组，ENetChannel主要用于接收对端发送回来的数据。 ENetChannel中有两个队列：12ENetList incomingReliableCommands;ENetList incomingUnreliableCommands; incomingRelibaleCommands: 用于储存已经收到的可靠数据包。 incomingUnreliableCommands: 用于储存已经收到的不可靠数据包 对数据的排序操作会在将其放进channel中的这两个incoming队列中进行，在channel中已经排序好的数据（reliable 数据包的话还需要保证序号连续）会放到peer的dispatchedCommands队列中，并且将peer放到host的dispatchQueue，当host下次处理时如果发现dispatchQueue中已经有peer存在，则会对其进行处理。如果没有，则会进入正常的收发包流程。 host运行过程host的主要运行通过一个enet_host_service函数，当有事件产生时，enet_host_service函数就会返回1，并将相应的event储存在传入的ENetEvent指针中，如果没有超过时间限制没有事件产生，则会返回0，出现错误时，enet_host_service会返回-1。 enet_host_service的整体流程如下：1234567891011121314151617enet_protocol_dispatch_incoming_commands (host, event);do &#123; enet_host_bandwidth_throttle (host); enet_protocol_send_outgoing_commands (host, event, 1); enet_protocol_receive_incoming_commands (host, event); enet_protocol_send_outgoing_commands (host, event, 1); enet_protocol_dispatch_incoming_commands (host, event); do&#123; enet_socket_wait(); &#125;while&#125;while 在enet_host_service函数的每一个步骤中如果产生了Evnet，则直接返回。 首先会调用protocol_dispatch_incoming_commands函数查看当前是否存在待处理的事件，如果存在则直接返回。 否则进入循环，首先如果当前系统时间到达下次设置带宽限制的时间戳，则进行带宽限制。 然后发送相应的命令，enet_protocol_send_outgoing_commands会发送用户传入的数据和系统产生的指令。 随后调用enet_protocol_receive_incoming_commands从udp缓冲区中接收相应数据并处理。 随后再次调用enet_protocol_send_outgoing_commands发送相应数据 随后再次调用enet_protocol_dispatch_incoming_commands检测是否有事件产生，如果仍无事件产生，则进入enet_socket_wait()函数的循环 enet_socket_wait()内部由select函数实现，用于监听socket读是否有相应，如果udp缓冲区中有数据到达，则重新进入上述循环，如果无数据，则等待用户传入的等待时间后退出。 循环中两次调用send的原因在调用enet_protocol_receive_incoming_commands函数后，如果接收到数据后会产生相应的ack指令，这是再次调用enet_protocol_send_outgoing_commands函数，则会立即将ack发送出去，不会像TCP那样捎带发送，减少了网络库对丢包的判断过程。 ENet连接管理连接建立流程ENet在连接建立过程中同样需要三次握手，并且在建立连接的过程中改变peer的状态。 首先两个host建立连接前需要保证peers数组内有空闲的peer(状态为disconnected)。 建立连接时，主动连接方首先找到一个状态为disconnected的peer，并向对端发送connect指令，并且将其状态变为connecting。 对端接收到connect指令后同样找到一个状态为disconnected的peer，并将其状态变为acknowledgeing connect，并返回一个verify connect指令。 主动连接方收到verify connect指令后，将其状态变为connected，意味着连接建立，并且向用户dispatch一个connect event事件，并返回ack指令。 对端接收到ack命令后，将其状态变为connnected，连接建立完成，并同样向用户dispatch一个connect event事件。 至此，双方连接建立完成。 断开连接流程ENet提供了三种断开连接的方式：disconnect, disconneted now和disconnect later disconnect 断开连接时，主动断开连接的一方向对端发送disconnect指令，并把状态由connected变为disconnecting。 对端收到disconnect指令之后，将状态由connected变为acknowledging disconnect，并且返回ack指令，在发送完ack指令之后，将状态变为zombie状态，并将断开连接事件dispatch给用户之后，将状态由zombie变为disconnected。 主动连接方收到ack后，将状态由disconnecting变为zombie，将断开连接事件dispatch给用户之后，将状态由zombie变为disconnected。 为什么要有acknowledging disconnect状态因为需要返回ack时，不能将peer状态设为zombie或者disconnected，因为在发送数据时，这两个状态的peer是被忽略的，所以需要设置一个状态，等待将ack发送出去之后，再将状态设置为zombie。 为什么要有zombie状态因为需要将断开连接的事件返回给用户，zombie状态就是已经准备断开连接，但是还没断开连接时的状态，被标记为zombie状态的peer不会分配给新的连接，除非用户已经处理该事件。当用户已经收到断开连接的事件后，才会真正将该peer的状态从zombie变为disconnected。 disconnect laterdisconnect later会首先将该peer的状态改为disconnect later。状态为disconnect later的peer不会再添加新的数据，也不会处理已经到来的数据，当检测到将现有queue中的数据发送完后，则会发送disconnect命令，进入之前的断开连接流程。 disconnect now 与disconnect不同的是，发送方在调用disconnect_now函数之后，会将peer现有队列中的数据和一个unsequenced的disconnect发送给对端，并直接将状态变为disconnceted，并且不会dispatch event给用户。 对端在收到unsequenced的disconnect指令之后，会将状态变为zombie，在将断开连接事件dispatch给用户之后，将状态变为disconnected。 ENet 数据的发送ENet数据发送主要在enet_protocol_send_outgoing_commands函数中进行，该函数会将在outgoing queue中的command和packet调用socket接口发送出去。 enet_protocol_send_outgoing_commands函数的大致流程为：123456789101112131415while(host-&gt;continueSending) &#123; for(peer in host-&gt;peers) &#123; send_acknowldeges(); check_timeouts(); send_reliable_outgoing_commands(); send_unreliable_outgoing_commands(); enet_socket_send(); &#125;&#125; ENet在发送时会遍历host中每个已经连接的peer，其中不同指令发送的顺序依次是： 将ack放入host-&gt;buffers中 检测当前send reliable queue中的命令是否超时，如果超时则将其加到outgoing command的队列头部 将outgoing reliable queue中的命令放入host-&gt;buffers中 将outgoing unreliable queue中的命令放入host-&gt;buffers中（包括unreliable 和 unsequenced命令） 调用socket接口，将host-&gt;buffers中的数据用一个udp数据报发送出去 ENet在发送时会保证发送的udp数据报的大小不会超过peer的mtu的大小，如果一个peer内的数据没有发送完，则会将host-&gt;continueSending置为1，意味着还需要继续发送，在下次遍历peer时将数据发送出去。 为保证公平性，不会因为单个peer的需要发送的数据量过大而影响其余peer数据的发送，所以每次对单个peer发送的数据量至多为mtu，如果仍有数据没有发送，则会在下次循环中继续发送，直到host-&gt;contingueSending不再被置为1。 reliable数据包的发送在发送reliable数据时，会检测三个条件： 发送的数据的范围是否在滑动窗口的有效范围内（选择重传的方法要求发送中的序号不超过序号空间的一半）。 在传输中的数据总量的大小是否超过了发送窗口大小的限制。 host-&gt;buffers是否已经占满或者当前buffer中数据的大小是否超过mtu。 如果上述条件均不满足，意味着可以向buffer中继续添加数据，则从peer -&gt; outgoingReliableCommands中将该command取出，放入buffer中，并将该command转移到peer -&gt; sentReliableCommands队列中。 peer -&gt; sentReliableCommands会缓存已经发送的但是还没有收到ack的可靠包的command，在每次超时检测时，会检测peer -&gt; sentReliableCommands队列中的command是否已经超时，如果超时则会将该command重新放入到peer -&gt; outgoingReliableCommands队列的头部，在发送数据时将其重新发送。如果一个command的rto超过最大限制或者重传次数超过最大限制，则判定当前peer已经断开连接，进入断开连接流程。 每当收到ack时，会从peer -&gt; sentReliableCommands队列中将相应的command移除。 unreliable数据报的发送在发送unreliable数据时，会首先检测两个条件： 发送的数据的范围是否在滑动窗口的有效范围内 随机性丢弃一些数据。 与reliable数据不同，unreliable不会缓存已经发送的数据，因为它们不需要ack，但是为了避免发送的数据超过peer的带宽限制，则根据带宽控制阀门计算出的随机数在发送前为了保证在传输的数据量不超过peer的带宽，将不可靠包根据packetThrottle的值进行概率随机丢弃。 在发送时同样会将已经发送的command从peer -&gt; outgoingUnreliableCommands放入peer -&gt; sentUnreliableCommands，在每次调用enet_socket_send函数将数据发送出去后则会立即清空peer -&gt; sentUnreliableCommands队列。 不立即清空peer -&gt; sentUnreliableCommands队列的原因host-&gt;buffers储存的内容不是真正意义的buffer，而是需要发送的数据的packet的指针。需要发送的数据的内容实际上仍在各个队列的command中存储，这样避免了数据拷贝的额外消耗。 如果直接将队列清空的话，在调用enet_socket_send发送时则会出现不可预知的错误，所以将peer -&gt; sentUnreliableCommands队列在调用socket接口发送后清空。 ENet 数据的接收ENet在创建host时将socket设置为非阻塞模式。在每次接收数据时至多接收256次UDP数据报，如果udp缓冲区中没有数据或者接收次数达到256次，则跳出接收循环，先将接收到的数据dispatch给用户。 接收数据在enet_protocol_receive_incoming_commands函数中进行。 1234567891011for (packets = 0; packets &lt; 256; ++ packets)&#123; receivedLength = enet_socket_receive (); if (receivedLength &lt; 0) return -1; if (receivedLength == 0) return 0; enet_protocol_handle_incoming_commands ();&#125; enet_protocol_handle_incoming_commands函数会对接收到的数据进行解析和处理。 在对数据进行解析和处理时，如果是系统指令，则直接对其进行相应的操作。如果是需要接收的数据类型的指令，例如send_reliable，send_unreliable指令，则需要对其进行排序，分片后的重组等操作。 接收send reliable指令ENet在接收reliable指令时会首先将其按发送序号存放在channel -&gt; incomingReliableCommands队列中。首先需要在channel -&gt; incomingReliableCommands队列中查找到合适的位置，如果相应序号的指令已经存在，则将指令丢弃，如果不存在，则插入到队列中。 这里需要注意的时，由于ENet的序号只有16位，也就是最大只有65535，很容易发生越界。在进行插入的时候同样需要判断序号是否已经出现越界。 每次有新的数据包到来后，则会将channel -&gt; incomingReliableCommands队列中连续不中断的commands移动到peer -&gt; dispatchedCommands队列中，在下次调用enet_host_service函数时，该peer便会产生一个接收数据的事件，并将接收到的数据包返回给用户。 接收send unreliable指令unreliable指令的接收与reliable大致相似，同样会对数据包进行排序，不同的是，在将数据包从channel -&gt; incomingUnreliableCommands队列转移到peer -&gt; dispatchedCommands队列中时，不会保证数据包的连续性，如果序号较大的已经到了，而序号较小的没有到达，则直接将已经收到的数据包放入peer -&gt; dispatchedCommands队列中，如果后续较小序号的数据包到达的话，则直接丢弃。 还有一点不同的是，之前已经介绍到unreliable数据包的序号要依赖reliable数据包的序号，如果发送新的reliable数据包，则会将该peer中unreliable数据包的序号刷新。所以ENet默认unreliable序号不会超过65535的序号空间，也就没有对unreliable数据包的序号的越界情况进行考虑。 由于unsequenced指令同样放在unreliable队列中处理，如果有unsequenced的指令的话，则会直接放到peer -&gt; dispatchedCommands队列中。 接收fragment指令fragment分为reliable和unreliable两种类型。 在处理fragment指令时，会首先判断该分片组中的第一个分片是否已经在channel -&gt; incomingReliableCommands或者channel -&gt; incomingUnreliableCommands队列中。 如果已经到达，则将新到达的数据包的数据并入该第一个分片的command中，如果没有到达，则新建一个command，将其序号设置为分片组的start sequencenum，即第一个分片的序号，插入到channel -&gt; incomingReliableCommands或者channel -&gt; incomingUnreliableCommands队列中的合适位置，并将到达的command中的数据copy到该新建的command中。 在新建分片组第一个分片序号的command时，会同时建立一个位图，判断相应位置的command是否已经到达，如果相应分片已经全部到达，则调用dispatch函数将channel -&gt; incomingReliableCommands或者channel -&gt; incomingUnreliableCommands队列中的数据dispatch到peer -&gt; dispatchedCommands队列中。 如果fragment是unreliable类型的话，操作与reliable类型的command基本相同，不同的是在调用dispatch函数时，如果后续序号的command已经到达，则会将没有重组完全的分片组全部丢弃，而不会进行等待。 ENet RTT 和 RTO设置RTT运算过程ENet在每次收到reliable包的acknowledge时，会对该peer的roundTripTime和roundTripTimeVariance进行更新。更新时并不是将该peer的roundTripTime设置为当前的rtt，而是根据当前的rtt和peer的roundTripTime的差值对roundTripTime和roundTripTimeVariance进行平滑的更新。 123rtt_var_thistime = rtt_thistime - peer-&gt;rttpeer-&gt;rtt = rtt + rtt_var_thistime / 8peer-&gt;rtt_var = peer-&gt;rtt_var * 3/4 + rtt_var_thistime / 4 1234if (peer -&gt; roundTripTime &lt; peer -&gt; lowestRoundTripTime) peer -&gt; lowestRoundTripTime = peer -&gt; roundTripTime;if (peer -&gt; roundTripTimeVariance &gt; peer -&gt; highestRoundTripTimeVariance) peer -&gt; highestRoundTripTimeVariance = peer -&gt; roundTripTimeVariance; 并根据peer-&gt;rountTripTime和peer-&gt;roundTripTimeVariance来更新peer-&gt;lowestRoundTripTime和peer-&gt;highestRoundTripTimeVariance这两个最值。 peer-&gt;lowestRoundTripTime和peer-&gt;highestRoundTripTimeVariance它们在每个packetThrottleInterval时间间隔中会被重置为该peer的peer-&gt;rountTripTime和peer-&gt;roundTripTimeVariance当前的值。 这两个最值用于enet_peer_throttle函数中对peer-&gt;packetThrottle的调控和更新 RTO的设置ENet在enet_protocol_send_reliable_outgoing_commands函数中每次发送相应可靠包时会为其设置rto，用于判断该包是否超时。 1command-&gt;rto = peer-&gt;rtt + 4 * peer-&gt;rtt_var 在enet_protocol_check_timeouts函数中每当检测到一个command超时后，会将其rto设置为原来的2倍，并重发该command。1command-&gt;rto *= 2 当一个command的roundTripTimeout大于该command的rounTripTimeout,并且host在相应时间内没有收到相应peer发送的command，则视为该peer已经断开连接，并进入断开连接的流程。 ENet 流量控制ENet流量控制在创建host时，如果设置incomingBandWidth或者outgoingBandWidth为0，则将相应的流量控制关闭，否则则将其打开。 ENet的流量控制简单的通过一个packetThrottle变量实现，通过各个peer的带宽和相应时间内发送的数据量以及收发包的延迟对packetThrottle进行调控，从而达到控制发送数据量的目的。 对于可靠包的发送，ENet在发送数据前会根据padketThrottle计算一个发送窗口的大小，如果当前在传输过程中的数据量的大小超过了发送窗口的大小，则暂停数据的发送，直到发送窗口有足够的空间。 对于不可靠数据包，ENet在发送时会根据packetThrottle计算一个数值来随机丢弃相应的不可靠包，确保数据的发送不会超过peer的发送能力。 ENet流量控制分为两个部分： 调节host端的发送能力，确保peer的download bandwidth足够承载host向其发送的数据。 调节peer端的发送能力，确保peer端发送的数据不会超过host端download bandwitdh的承载能力。 调节host端的发送调节host的发送能力其实是通过对peer-&gt;packetThrottle的调节完成的，ENet在发送数据时，会通过peer-&gt;packetThrottle计算出一个windowSize(发送窗口大小)，如果检测到在发送中的数据的量大于peer-&gt;packetThrottle的话，则暂停发送，直到发送窗口大小有足够的空间。 对于peer-&gt;packetThrottle的调节又分为两个步骤： 在每次收到ack时通过本次rtt对于之前rtt的变化对peer-&gt;packetThrottle进行调节 通过比较host的outgoingBandwidth和host在一定时间内发送的数据总量以及peer的incomingBandwitdh和相同时间内向该peer发送的数据量进行调节，确保host的发送不会超过peer的接收能力。 如果未打开流量控制，则步骤2的调节可以忽略。 通过rtt对packetThrottle进行调节在ENet收到reliable包的ack时，会根据本次的rtt和lasttime_rtt对该peer的packetThrottle进行调节。 具体过程在enet_peer_throttle函数中：1234567891011121314151617181920212223242526int enet_peer_throttle (ENetPeer * peer, enet_uint32 rtt) &#123; if (peer -&gt; lastRoundTripTime &lt;= peer -&gt; lastRoundTripTimeVariance) &#123; peer -&gt; packetThrottle = peer -&gt; packetThrottleLimit; &#125; else if (rtt &lt; peer -&gt; lastRoundTripTime) &#123; peer -&gt; packetThrottle += peer -&gt; packetThrottleAcceleration; if (peer -&gt; packetThrottle &gt; peer -&gt; packetThrottleLimit) peer -&gt; packetThrottle = peer -&gt; packetThrottleLimit; return 1; &#125; else if (rtt &gt; peer -&gt; lastRoundTripTime + 2 * peer -&gt; lastRoundTripTimeVariance) &#123; if (peer -&gt; packetThrottle &gt; peer -&gt; packetThrottleDeceleration) peer -&gt; packetThrottle -= peer -&gt; packetThrottleDeceleration; else peer -&gt; packetThrottle = 0; return -1; &#125; return 0;&#125; 关于peer-&gt;lastRoundTripTime和peer-&gt;lastRoundTripTimeVariance的更新过程在函数enet_protocol_handle_acknowledge中：123456789if (peer -&gt; packetThrottleEpoch == 0 || ENET_TIME_DIFFERENCE (host -&gt; serviceTime, peer -&gt; packetThrottleEpoch) &gt;= peer -&gt; packetThrottleInterval)&#123; peer -&gt; lastRoundTripTime = peer -&gt; lowestRoundTripTime; peer -&gt; lastRoundTripTimeVariance = peer -&gt; highestRoundTripTimeVariance; peer -&gt; lowestRoundTripTime = peer -&gt; roundTripTime; peer -&gt; highestRoundTripTimeVariance = peer -&gt; roundTripTimeVariance; peer -&gt; packetThrottleEpoch = host -&gt; serviceTime;&#125; 可以看到peer-&gt;lastRoundTripTime取得是上一个时间段内peer统计的rtt的最小值。而peer-&gt;lastRountRripTimeVariance取得是上一个时间段内rtt_var的最大值。并且每次更新后将peer中相应的lowestRoundTripTime和highestRoundTripTimeVariance重置为当前的值。 在enet_peer_throttle函数中， 如果上个时间段中rtt的最小值小于rtt的变化的最大幅度，可以理解为rtt至少在上个时间段内变为原来的一半，则直接将peer-&gt;pakcetThrottle设置为其上限peer-&gt;packetThrottleLimit。 如果本次的rtt小于上个时间端内rtt的最小值，说明当前网络状况较好，则对该peer的packetThrottle进行相应的增加。 如果本次的rtt大于上次的rtt的最小值加上2倍的rtt变化的最大值，说明当前网络延时有所增加，当前网络的拥塞状况较差，则对该peer的packetThrottle进行相应的减少。 通过带宽和数据发送对packetThrottle进行调节首先统计出距离上次流量调节的时间间隔内的host发送的数据总量：1234567891011121314if (host -&gt; outgoingBandwidth != 0)&#123; dataTotal = 0; bandwidth = (host -&gt; outgoingBandwidth * elapsedTime) / 1000; for (peer = host -&gt; peers; peer &lt; &amp; host -&gt; peers [host -&gt; peerCount]; ++ peer) &#123; if (peer -&gt; state != ENET_PEER_STATE_CONNECTED &amp;&amp; peer -&gt; state != ENET_PEER_STATE_DISCONNECT_LATER) continue; dataTotal += peer -&gt; outgoingDataTotal; &#125;&#125; elapsedTime是距离上次流量控制的间隔时间。bandwidth可以理解为在该间隔时间内host发送数据的能力。dataTotal是在间隔时间内host向已连接的peer发送的数据的总量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667while (peersRemaining &gt; 0 &amp;&amp; needsAdjustment != 0)&#123; needsAdjustment = 0; if (dataTotal &lt;= bandwidth) throttle = ENET_PEER_PACKET_THROTTLE_SCALE; else throttle = (bandwidth * ENET_PEER_PACKET_THROTTLE_SCALE) / dataTotal; for (peer = host -&gt; peers; peer &lt; &amp; host -&gt; peers [host -&gt; peerCount]; ++ peer) &#123; enet_uint32 peerBandwidth; if ((peer -&gt; state != ENET_PEER_STATE_CONNECTED &amp;&amp; peer -&gt; state != ENET_PEER_STATE_DISCONNECT_LATER) || peer -&gt; incomingBandwidth == 0 || peer -&gt; outgoingBandwidthThrottleEpoch == timeCurrent) continue; peerBandwidth = (peer -&gt; incomingBandwidth * elapsedTime) / 1000; if ((throttle * peer -&gt; outgoingDataTotal) / ENET_PEER_PACKET_THROTTLE_SCALE &lt;= peerBandwidth) continue; peer -&gt; packetThrottleLimit = (peerBandwidth * ENET_PEER_PACKET_THROTTLE_SCALE) / peer -&gt; outgoingDataTotal; if (peer -&gt; packetThrottleLimit == 0) peer -&gt; packetThrottleLimit = 1; if (peer -&gt; packetThrottle &gt; peer -&gt; packetThrottleLimit) peer -&gt; packetThrottle = peer -&gt; packetThrottleLimit; peer -&gt; outgoingBandwidthThrottleEpoch = timeCurrent; peer -&gt; incomingDataTotal = 0; peer -&gt; outgoingDataTotal = 0; needsAdjustment = 1; -- peersRemaining; bandwidth -= peerBandwidth; dataTotal -= peerBandwidth; &#125;&#125;if (peersRemaining &gt; 0)&#123; if (dataTotal &lt;= bandwidth) throttle = ENET_PEER_PACKET_THROTTLE_SCALE; else throttle = (bandwidth * ENET_PEER_PACKET_THROTTLE_SCALE) / dataTotal; for (peer = host -&gt; peers; peer &lt; &amp; host -&gt; peers [host -&gt; peerCount]; ++ peer) &#123; if ((peer -&gt; state != ENET_PEER_STATE_CONNECTED &amp;&amp; peer -&gt; state != ENET_PEER_STATE_DISCONNECT_LATER) || peer -&gt; outgoingBandwidthThrottleEpoch == timeCurrent) continue; peer -&gt; packetThrottleLimit = throttle; if (peer -&gt; packetThrottle &gt; peer -&gt; packetThrottleLimit) peer -&gt; packetThrottle = peer -&gt; packetThrottleLimit; peer -&gt; incomingDataTotal = 0; peer -&gt; outgoingDataTotal = 0; &#125;&#125; throttle是host的bandwidth和发送数据总量的比值的调节值。 12if ((throttle * peer -&gt; outgoingDataTotal) / ENET_PEER_PACKET_THROTTLE_SCALE &lt;= peerBandwidth) continue; 如果peer-&gt;incomingBandWidth/peer-&gt;outgoingDataTotal的比值大于throttle，意味着此时peer的带宽足够承载host对peer发送数据的速度，则暂时不予处理，否则则对peer-&gt;packetThrottleLimit进行调节。设置相应peer的packetThrottleLimit：1peer -&gt; packetThrottleLimit = (peerBandwidth * ENET_PEER_PACKET_THROTTLE_SCALE) / peer -&gt; outgoingDataTotal; ENet会保证peer-&gt;packetThrottle不超过peer-&gt;packetThrottleLimit。通过设置packetThrottleLimit保证发送数据时host向peer发送的数据量不会超过peer的incomingBandwidth。 对于之前没有设置的peer则统一将其packetThrottle设置为throttle。 采用双层循环的原因每次循环中会将 向peer发送数据量/peer的download bandwidth &lt; throttle的peer的packetThrottleLimit设置为其当前的值，并在bandwidth和dataTotal中减去相应的peerBandwidth，再下一次循环中计算出的throttle会比上一次计算得出的throttle跟更高。如果只是单次循环并将剩下的peer的packetThrottleLimit设置为当前的throttle，会对peer的incomingBandwidth造成浪费。 最后统一设置为thtottle原因为保证平均高效的利用host的带宽，虽然剩余的peer的incomingBandwidth足够承载host的发送的数据，但是host在发送数据时也需要考虑到host总的outgoingBandwidth，所以将剩下的peer的pakcetThrottleLimit设置为throttle，防止单个peer发送数据过多占满host的upload bandwidth。 调节peer端的发送每当ENet中有peer连接或者断开连接时，会将ENetHost-&gt;recalculateBandwidthLimits结构变量置为1，在下次enet_host_service函数中调用enet_host_bandwidth_throttle时会进行该项的流量控制。 调节peer端发送能力，通过向该peer发送ENetProtocolBandwidthLimit指令实现。其中 ENetProtocolBandwidthLimit.outgoingBandwidth简单的对应host -&gt; outgoingBandwidth ENetProtocolBandwidthLimit.incomingBandwidth则是host端对该peer调节后的bandwidthLimit host通过向peer发送ENetProtocolBandwidthLimit指令设置client端对应host的peer的incomingBandwidth，进而client端通过incomingBandwidth调节对应host的peer中的packetThrottleLimit和packetThrottle来控制对host流量传输。 具体调节流程可以看如下代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849host -&gt; recalculateBandwidthLimits = 0;peersRemaining = (enet_uint32) host -&gt; connectedPeers;bandwidth = host -&gt; incomingBandwidth;needsAdjustment = 1;if (bandwidth == 0) bandwidthLimit = 0;elsewhile (peersRemaining &gt; 0 &amp;&amp; needsAdjustment != 0)&#123; needsAdjustment = 0; bandwidthLimit = bandwidth / peersRemaining; for (peer = host -&gt; peers; peer &lt; &amp; host -&gt; peers [host -&gt; peerCount]; ++ peer) &#123; if ((peer -&gt; state != ENET_PEER_STATE_CONNECTED &amp;&amp; peer -&gt; state != ENET_PEER_STATE_DISCONNECT_LATER) || peer -&gt; incomingBandwidthThrottleEpoch == timeCurrent) continue; if (peer -&gt; outgoingBandwidth &gt; 0 &amp;&amp; peer -&gt; outgoingBandwidth &gt;= bandwidthLimit) continue; peer -&gt; incomingBandwidthThrottleEpoch = timeCurrent; needsAdjustment = 1; -- peersRemaining; bandwidth -= peer -&gt; outgoingBandwidth; &#125;&#125;for (peer = host -&gt; peers; peer &lt; &amp; host -&gt; peers [host -&gt; peerCount]; ++ peer)&#123; if (peer -&gt; state != ENET_PEER_STATE_CONNECTED &amp;&amp; peer -&gt; state != ENET_PEER_STATE_DISCONNECT_LATER) continue; command.header.command = ENET_PROTOCOL_COMMAND_BANDWIDTH_LIMIT | ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE; command.header.channelID = 0xFF; command.bandwidthLimit.outgoingBandwidth = ENET_HOST_TO_NET_32 (host -&gt; outgoingBandwidth); if (peer -&gt; incomingBandwidthThrottleEpoch == timeCurrent) command.bandwidthLimit.incomingBandwidth = ENET_HOST_TO_NET_32 (peer -&gt; outgoingBandwidth); else command.bandwidthLimit.incomingBandwidth = ENET_HOST_TO_NET_32 (bandwidthLimit); enet_peer_queue_outgoing_command (peer, &amp; command, NULL, 0, 0);&#125; peersRemaining指与host已经连接的peer的数量。bandwidth指host的download bandwidth的大(incomingBandwidth)。 如果host端未开启流量控制，即host -&gt; incomingBandwidth的值为0，则设置bandwidthLimit为0。 否则通过双层循环对带宽限制进行调节。 每次while循环会重新计算bandwidthLimit，并将不需要带宽限制的peer或者发送能力小于bandwidthLimit的peer标记出来。在接下来发送ENetProtocolBandwidthLimit指令时则将其中的incomingBandwidth设置为peer-&gt;outgoingBandwidth，即不用改变。对于发送能力大于bandwidthLimit的peer，则将相应的ENetProtocolBandwidthLimit指令中的incomingBandwidth设置为bandwidthlimit。 关于用双层循环的原因如果第一次循环将所有发送能力大于bandwidthLimit的peer都设置为bandwidthLimit而对于那些发送能力小的则不改变的话，host的incomingBandwidth其实是没有使用完的，会造成浪费。 在每次for循环中将发送发送能力小于bandwidthLimit的peer剔除之后，重新计算的bandwidthLimit会增大，意味着host的incomingBandwidth可以承载更多的带宽，低于该值的peer都是不用调节的，这样可以更加充分的利用host的带宽，而不造成浪费。","categories":[{"name":"network","slug":"network","permalink":"https://uyouii.github.io/categories/network/"}],"tags":[{"name":"network","slug":"network","permalink":"https://uyouii.github.io/tags/network/"},{"name":"coderead","slug":"coderead","permalink":"https://uyouii.github.io/tags/coderead/"},{"name":"enet","slug":"enet","permalink":"https://uyouii.github.io/tags/enet/"}]},{"title":"记一次闹心的网络调试经经历","slug":"记一次闹心的网络调试经历","date":"2018-05-12T12:26:19.000Z","updated":"2019-08-02T03:28:18.919Z","comments":true,"path":"2018/05/12/记一次闹心的网络调试经历/","link":"","permalink":"https://uyouii.github.io/2018/05/12/记一次闹心的网络调试经历/","excerpt":"","text":"背景目前为测试下自己毕业设计实现的网络库，手边没有两台电脑，所以就打算在本机测试实现，方法是通过修改本极路由表，让发向本地ip的网络包不直接通过回环端口，而是先发送到网关，在通过网关返回回来，这样通过丢包模拟软件设置本地网卡的丢包率和延时便可以模拟真实网络环境的波动，进而进行测试。 环境是：Windows 10，丢包模拟软件是：Network Emulator Client 修改本地路由表的命令是：1route add [本地ip] mask 255.255.255.255 [网关ip] 问题出现这种方法首先在公司是可行的，可是回到自己住的地方后，再通过这种方法发现发向本地ip的UDP包无法收到，ping本地ip测试之后，返回的是这个结果:1Reply from 192.168.31.1: Destination port unreachable. 目标端口不可达，这就非常奇怪了。 一开始以为是本机防火墙的锅，但是修改了win10防火墙各种参数之后还是没有效果。 并且通过测试可以发现，同一子网下的不同的两台主机之间是可以ping通的，所以不存在路由器找不到mac地址的问题，既然能找到mac地址，很有可能是路由器把这个包丢掉了。 解决尝试既然是路由器的问题，一种方法是直接将路由器去掉，把网线直接插到网口上面，这样直接在上层的子网内尝试向本机ip发包，然后这次问题变成了超时，由于房间内网线上层连接的是2层交换机，交换机会进行什么样的操作就无法干预了，退回到路由器的问题。 远程连接路由器路由器管理员界面是没有提供发包调试的功能，也没有命令行页面的，仅仅通过管理员界面是无法对路由表和防火墙进行操作的，没办法，先试着远程链接下路由器。 由于我的路由器的型号是小米路由器3，通过查阅资料发现，要远程连接路由器首先需要将路由器刷机到开发版，然后给路由器装上ssh，这样就可以远程连接了。 然后就去重官网上下载了小米路由器3开发版的最新版，尝试了几次之后给路由器成功刷成了开发者版本。 发现安装ssh要通过u盘进行操作，然后先去找室友借到了u盘，下好ssh文件，插到路由器上后，重启，尝试连接，没有反应。 这样反复几次之后，突然意识到u盘需要时fat32格式的，借到的u盘太大，无法格式化为fat32格式，只能是NTFS和EXFAT格式，因为FAT32最好的支持是小于32g的U盘，太大的U盘格式化便没了这个选项。 没办法，费劲心力找到了一个8g的小U盘，格式化为FAT32格式的，插入路由器，安装，OK，重启，尝试连接，成功！ 远程路由器不得不说小米是骚气，路由器登陆界面竟然是这个：123456789101112 ----------------------------------------------------- Welcome to XiaoQiang! ----------------------------------------------------- $$$$$$\\ $$$$$$$\\ $$$$$$$$\\ $$\\ $$\\ $$$$$$\\ $$\\ $$\\ $$ __$$\\ $$ __$$\\ $$ _____| $$ | $$ | $$ __$$\\ $$ | $$ | $$ / $$ |$$ | $$ |$$ | $$ | $$ | $$ / $$ |$$ |$$ / $$$$$$$$ |$$$$$$$ |$$$$$\\ $$ | $$ | $$ | $$ |$$$$$ / $$ __$$ |$$ __$$&lt; $$ __| $$ | $$ | $$ | $$ |$$ $$&lt; $$ | $$ |$$ | $$ |$$ | $$ | $$ | $$ | $$ |$$ |\\$$\\ $$ | $$ |$$ | $$ |$$$$$$$$\\ $$$$$$$$$ | $$$$$$ |$$ | \\$$\\ \\__| \\__|\\__| \\__|\\________| \\_________/ \\______/ \\__| \\__|root@XiaoQiang:~# 不知道雷布斯同学看了后是什么反应，= =。 终于登陆到路由器了，然后下一步该干嘛呢 0.0 先看一下路由器的路由表:12345678root@XiaoQiang:~# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0.2192.168.31.0 0.0.0.0 255.255.255.0 U 0 0 0 br-lan###.###.##.# 0.0.0.0 255.255.255.0 U 0 0 0 wl20.0.0.0 192.168.1.1 0.0.0.0 UG 0 0 0 eth0.20.0.0.0 192.168.1.1 0.0.0.0 UG 50 0 0 eth0.2 个人外网的ip地址处于安全问题就先用#代替了 小米路由器的内网网关是192.168.31.1，掩码是 255.255.255.0，个人主机的ip地址是192.168.31.233。对应的规则是：1192.168.31.0 0.0.0.0 255.255.255.0 U 0 0 0 br-lan 好像并没有什么问题，发向192.168.31.0的子网的包会通过自己转发出去。 难道是路由器防火墙的问题？ 坑爹的路由器防火墙尝试下命令：1/etc/init.d/firewall stop 关掉了路由器的防火墙，重新向本地ip用Ping命令测试，居然成功了！！！！！ OK，果然是这个坑爹的路由器防火墙把发向源ip和目的ip相同的包给拒了。 但是····QAQ，把防火墙关了之后，坑爹的网居然被断了，只能子网内自己发发包玩下，包发不出去了= =，坑爹的，实在是没精力去学习路由器防火墙规则了，先这样把，测试的时候先把路由器防火墙关了，不用的时候再打开= =，非常郁闷了。 不过花了三个晚上找到了问题还是很开心的。 把这个问题放在这边，希望大家不要再踩这个坑了，测试还是用两台主机去测试吧。","categories":[{"name":"Personal Journal","slug":"Personal-Journal","permalink":"https://uyouii.github.io/categories/Personal-Journal/"}],"tags":[{"name":"network","slug":"network","permalink":"https://uyouii.github.io/tags/network/"},{"name":"debug","slug":"debug","permalink":"https://uyouii.github.io/tags/debug/"}]},{"title":"UDP","slug":"UDP","date":"2018-03-01T09:11:24.000Z","updated":"2019-08-02T03:28:18.916Z","comments":true,"path":"2018/03/01/UDP/","link":"","permalink":"https://uyouii.github.io/2018/03/01/UDP/","excerpt":"","text":"UDP是无连接不可靠的数据报协议，使用UDP编写的一些常见的应用程序有：DNS（域名系统），NFS（网络文件系统）和SNMP（简单网络管理协议）。 UDP客户/服务器程序所有套接字函数 recvfrom 和 sendto 函数123#include &lt;sys/socket.h&gt;ssize_t recvfrom(int sockfd, void* buff, size_t nbytes, int flags, struct sockaddr* from, socklen_t* addrlen);ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags, const struct sockaddr *to, socklen_t addrlen); 前三个参数sockfd、buff和nbytes等同于read和write函数的三个参数：描述符、指向读入或写出缓冲区的指针和读写字节数。 sendto的to参数指向一个含有数据报接收者的协议地址的套接字地址结构，其大小由addrlen参数指定。recvfrom的from参数指向一个将由该函数在返回时填写数据报发送者的协议地址的套接字结构，而在该套接字地址结构中填写的字节数则放在addrlen参数所指向的整数中返回给调用者。 注意:sendto的最后一个参数是一个整数值，而recvfrom的最后一个参数是一个指向整数的指针。 则两个函数都把所读写数据的长度作为函数返回值。在recvfrom使用数据报协议的典型用途中，返回值就是所接收数据报中的用户数据量。 写一个长度为0的数据报是可行的。在UDP情况下，这会形成一个只包含IP首部和一个8字节UDP首部而没有数据的IP数据报。对于数据报协议，recvfrom返回0是可以接受的：它并不像TCP套接字上read返回0值那样表示对端已关闭连接。既然UDP是无连接的，因此也就没有诸如关闭一个UDP连接之类的事情。 对于一个UDP套接字，如果进程首次调用sendto时它没有绑定一个本地端口，那么内核就在此时为它选择一个临时端口。同TCP一样，客户也可以显示地调用bind，不过很少这样做。 接收缓冲区每个UDP套接字都有一个接受缓冲区，到达该套接字的每个数据报都进入这个套接字的接收缓冲区。当进程调用recvfrom时，接收缓冲区中的下一个数据报以FIFO的顺序返回给进程。 在进程能够取该套接字中任何已排好队的数据报之前，如果有多个数据报达到该套接字，那么相继到达的数据报仅仅加到该套接字的接收缓冲区中。然而这个缓冲区的大小是有限的。 UDP 从客户端和服务端角度 客户端必须给sendto调用指定服务器地IP地址和端口号。一般来说，客户端地IP地址和端口号均由内核自动选择。 客户端地临时端口是在第一次调用sendto时一次性选定，不能改变；然而客户地IP地址却可以随客户端发送地每个UDP数据报而变动。 如果客户端捆绑了一个IP地址到其套接字上，但是内核决定外出数据报必须从另一个数据链路发出，这种情形下，IP数据报将包含一个不同于外出链路IP地址地源IP地址。 UDP套接字目的IP地址只能通过为IPv4设置IP_RECVDSTADDR套接字选项（或为IPv6设置IPV6_PKTINFO套接字选项）然后调用recvmsg（而不是recvfrom）取得。 由于UDP是无连接地，因此目的IP地址可随发送到服务器地每个数据报而改变。UDP服务器也可接收目的服务器主机地某个广播地址或多播地址地数据报。 UDP connect函数对于一个UDP套接字，由它引发地异步错误并不返回给它，除非它已连接。 UDP调用connect，内核只是检查是否存在立即可知的错误，记录对端的IP地址和端口号，然后立即返回到调用进程。 对于已连接UDP套接字与默认的未连接UDP套接字相比，发生了三个变化： 不能该输出操作指定目的IP地址和端口号。也就是说，我们不使用sendto，而改用write或send。写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址。（其实sendto也可以用，但是不能指定目的地址，snedto的第五个参数必须为空指针，第六个参数为0）。 不必使用recvfrom获悉数据报的发送者，而改用read、recv或recvmsg。在一个已连接UDP套接字上，由内核为输入操作返回的数据报只有那些来自connect所指定协议地址的数据报。目的地为这个已连接UDP套接字的本地协议地址，发源地却不是该套接字早先connect到的协议地址的数据报，不会投递到该套接字。这样就限制一个已连接UDP套接字能且仅能与一个对端交换数据报。 由已连接UDP套接字引发的异步错误会返回给他们所在的进程，而未连接UDP套接字不会接收任何异步错误。 给一个UDP套接字多次调用 connect 指定新的ip地址和端口号 断开套接字 给一个已连接的UDP套接字指定新的对端不同于TCP套接字中connect的使用：对于TCP套接字，connect只能调用一次。 为了断开一个已连接UDP套接字，再次调用connect时把套接字地址结构的地址族改成员设置为AF_UNSPEC。这么做可能返回一个EAFNOSUPPORT错误。 性能当应用进程在一个未连接的UDP套接字上调用sendto时，源自Berkeley的内核暂时连接该套接字，发送数据报，然后断开连接。通常涉及内核执行下列6个步骤： 连接告戒之 输出第一个数据报 断开套接字连接 连接套接字 输出第二个数据报 断开套接字连接 如果应用进程知道自己要给同一目的地址发送多个数据报时，显示连接套接字效率更高。调用connect后调用两次write设计内核执行如下步骤： 连接套接字 输出第一个数据报 输出第二个数据报","categories":[{"name":"Unix Network Programming","slug":"Unix-Network-Programming","permalink":"https://uyouii.github.io/categories/Unix-Network-Programming/"}],"tags":[{"name":"c","slug":"c","permalink":"https://uyouii.github.io/tags/c/"},{"name":"network","slug":"network","permalink":"https://uyouii.github.io/tags/network/"},{"name":"udp","slug":"udp","permalink":"https://uyouii.github.io/tags/udp/"},{"name":"socket","slug":"socket","permalink":"https://uyouii.github.io/tags/socket/"}]},{"title":"IP","slug":"IP","date":"2018-02-23T09:17:17.000Z","updated":"2019-08-02T03:28:18.912Z","comments":true,"path":"2018/02/23/IP/","link":"","permalink":"https://uyouii.github.io/2018/02/23/IP/","excerpt":"","text":"IPv4头部 IPv6头部","categories":[{"name":"Unix Network Programming","slug":"Unix-Network-Programming","permalink":"https://uyouii.github.io/categories/Unix-Network-Programming/"}],"tags":[{"name":"network","slug":"network","permalink":"https://uyouii.github.io/tags/network/"},{"name":"ip","slug":"ip","permalink":"https://uyouii.github.io/tags/ip/"}]},{"title":"IO复用：select和poll","slug":"IO复用：select和poll","date":"2018-02-23T09:17:07.000Z","updated":"2019-08-02T03:28:18.912Z","comments":true,"path":"2018/02/23/IO复用：select和poll/","link":"","permalink":"https://uyouii.github.io/2018/02/23/IO复用：select和poll/","excerpt":"","text":"使用I/O复用的经典场合 当客户处理多个描述符（通常是交互式输入和网络套接字）时，必须使用I/O复用。 当一个客户端同时处理多个套接字时可能的。 如果一个TCP服务器既要处理监听套接字，又要处理已连接套接字。 如果一个服务器既要处理TCP，又要处理UDP，一般就要使用I/O复用。 如果一个服务器要处理多个服务器或者多个协议，一般要使用I/O复用。 select 函数该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。 1234#include &lt;sys/select.h&gt;#include &lt;sys/time.h&gt;int select(int maxfdpl, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout); select函数修改由指针readset、writeset和exceptset所指向的描述符集，因而这三个参数都是值-结果参数。调用该函数时，我们所指定所关心的描述符的值，该函数返回时，结果将指示哪些描述符已就绪。该函数返回后，我们使用FD_ISSET宏来测试fd_set数据类型中的描述符。描述符集内任何与未就绪描述符对应的位返回时均清成0。每次重新调用select函数时，我们都得再次把所有描述符集内所关心的位置均置为1。 描述符就绪条件套接字准备好读 该套接字接收缓冲区中的数据字节数大于等于套接字接收缓冲区低水位标记的当前大小。对这样的套接字执行读操作不会阻塞并将返回一个大于0的值。可以使用SO_RCVLOWAT套接字选项设置该套接字的低水位标记。对于TCP和UDP套接字，其默认值为1。 该连接的读半部关闭（也就是接收了FIN的TCP连接）。对于这样的套接字的读操作将不阻塞并返回0(也就是返回EOF)。 该套接字是一个监听套接字且已完成的连接数不为0。对这样的套接字的accept通常不会阻塞。 其上有一个套接字错误待处理。对这样的套接字的读操作将不阻塞并返回-1（也就是返回一个错误），同时把errno设置成确切的错误条件。这些待处理错误（pending error）也可以通过指定SO_ERROR套接字选项调用getsockopt获取并清除。 套接字准备好写 该套接字发送缓冲区中的可用空间字节数大于等于套接字发送缓冲区低水位标记的当前大小，并且u后者该套接字已连接，或者该套接字不需要连接（如UDP套接字）。这意味着如果我们把这样的套接字设置为非阻塞，写操作将不阻塞并返回一个正值。可以使用SO_SNDLOWAT套接字选项来设置该套接字的低水位标记。对于TCP和UDP套接字而言，其默认值是2048。 该连接的写半部关闭，对这样的套接字的写操作将产生SIGPIPE信号。 使用非阻塞式connect的套接字已建立连接，或者connect已经以失败告终。 其上有一个套接字错误待处理。对这样的套接字的写操作将不阻塞并返回-1(也就是返回一个错误)，同时把errno设置成确切的错误条件。这些待处理的错误也可以通过指定的SO_ERROR套接字选项调用getsockopt获取并清除。 当某个套接字发生错误时，它将由select标记为即可读又可写。","categories":[{"name":"Unix Network Programming","slug":"Unix-Network-Programming","permalink":"https://uyouii.github.io/categories/Unix-Network-Programming/"}],"tags":[{"name":"IO multiplexing","slug":"IO-multiplexing","permalink":"https://uyouii.github.io/tags/IO-multiplexing/"},{"name":"c","slug":"c","permalink":"https://uyouii.github.io/tags/c/"},{"name":"network","slug":"network","permalink":"https://uyouii.github.io/tags/network/"}]},{"title":"TCP","slug":"TCP","date":"2018-02-23T09:16:50.000Z","updated":"2019-08-02T03:28:18.915Z","comments":true,"path":"2018/02/23/TCP/","link":"","permalink":"https://uyouii.github.io/2018/02/23/TCP/","excerpt":"","text":"TCP 状态转换图 TCP连接分组转换 捎带（piggybacking）服务器对于客户端请求的确认可以伴随其应答发生，这种做法称为捎带（piggybacking），它通常在服务器处理请求并产生应答的时间少于200ms时发生。 TIME_WAIT状态在TCP链接中，执行主动关闭的那端会有TIME_WAIT状态。改端点停留在这个状态的持续时间时最长分节生命期 maximum segment lifetime，MSL的两倍，有时称为2MSL。 任何TCP的实现都需要为MSL选择一个值。MSL时任何IP数据报能够在因特网中存活的最长时间。这个时间是有限的，因为每个数据报含有一个称为跳限 hop limit的8位字段，它的最大值是255。虽然跳限不是真正的时间限制，但是仍然假设：具有最大跳限的分组在网络中存活的时间不会超过MSL秒。 分组在网路中的迷途通常是路由异常的结果。某个路由器崩溃或某两个路由器之间的某个链路断开时，路由协议需要花费数秒钟到数分钟的时间才能稳定并找出另一条通路。并且在这段时间内有可能发生路由循环(路由器A把分组发送给路由器B，而B再把他们发送回A)。 假设迷途的分组是一个TCP分节，在迷途期间，发送端TCP超时并重传该分组，而重传的分组却通过某条候选路径到达最终目的地。不久之后路由器修复，之前迷途的分组也最终被送到目的地。这个原来的分组称为迷途的重组分组 lost duplicate或漫游的重组分组 wandering duplicate。 TIME_WAIT状态存在的理由 可靠地实现TCP全双工连接的终止 允许老的重复分节在网络中消逝 对于理由1，在TCP关闭连接的4次握手中，如果最终的ACK丢失了，服务器将重新发送它的最后的那个FIN，因此客户端必须维护状态信息，以允许它重新发送最终那个ACK。如果客户端不维护状态信息，它将相应一个rst，该分节将被服务器解释成一个错误。如果TCP打算执行所有必要的工作以彻底终止某个连接上的两个方向的数据流，那么它必须正确处理连接终止序列4个分节中任何一个分节丢失的情况。 执行主动关闭的那一端是处于TIME_WAIT状态的那一端，因为可能不得不重传最终的ACK的就是那一端。 对于理由2：假设服务端和客户端分别在1500端口和21端口之间有一个TCP连接。关闭这个连接之后，在相同的IP地址和端口之间建立另一个连接。后一个连接称为前一个连接的化身 incarnation，因为他们的IP地址和端口号都相同。 TCP必须防止来自某个连接的老的重复分组在该连接已终止后再现，从而被误解为属于同一连接的某个新的化身。为做到这一点，TCP将不给处于TIME_WAIT状态的连接发起新的化身。TIME_WAIT的持续时间是MSL的2倍，足以让某个方向上的分组最多存活MSL秒被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃。通过这个规则可以保证没成功建立一个TCP连接时，来自该连接先前化身的重复分组都已在网络中消逝了。 TCP输出每一个TCP套接字都有一个发送缓冲区，可以使用SO_SNDBUF套接字选项来更改缓冲区的大小。当某个应用进程调用write时，内核从该应用进程的缓冲区复制所有数据写到套接字的发送缓冲区。 如果该套接字的发送缓冲区容不下应用进程的所有数据（或是应用进程的缓冲区大于套接字的发送缓冲区，或是套接字的发送缓冲区中已有其他数据），该应用进程将被投入睡眠。这里假设套接字是阻塞的（套接字默认设置是阻塞的）。内核将不从write系统调用返回，知道应用进程缓冲区中的所有数据都复制到套接字的发送缓冲区。 从写一个TCP套接字的write调用成功返回仅仅表示我们可以从重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已经接收到数据。 PF_INET和AF_INET的区别AF: Address Family，表示地址族 PF: Protocol Family，表示协议族 在windows中的Winsock2.h中定义：12#define AF_INET 0#define PF_INET AF_INET 所以在windows中AF_INET与PF_INET完全一样。 而在Unix/Linux系统中，不同的版本这两者有微小的差别。对于BSD，是AF，对于POSIX，是PF。 理论上在建立socket时指定协议，应该用PF_xxxx，设置地址时应该用AF_xxxx。 当然AF_INET和PF_INET的值是相同的，混用也不会有太大问题。 RSTRST是TCP在发生错误时发送的一种TCP分节，产生RST的三个条件是： 目的地为某端口的SYN到达，然而该端口上并没有正在监听的服务器 TCP想取消一个已有连接 TCP接收到一个根本不存在的连接上的分节 基于TCP客户/服务器程序的套接字函数 connect 函数12#include&lt;sys/socket.h&gt;int connect(int sockfd, const struct sockaddr* servaddr, socklen_t addrlen); 客户端在调用函数connect前不必非得调用connect函数，因为如果需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。 如果是TCP套接字，调用connect时会激发TCP的三次握手过程，而且仅在连接建立成功或出错时才返回。 出错有以下几种情况: 若TCP客户端没有收到SYN分节的响应，则返回ETIMEDOUT错误。 若对客户的SYN的响应时RST，则表明该服务器主机在我们指定的端口上没有进程在等待与之连接。这是一种硬错误（hard error），客户一接收到RST就马上返回ECONNECTREFUSED 若客户端发出的SYN在中间的某个路由器上引发了一个“destination unreachable”ICMP错误，则认为是一种软错误（soft error）。 bind函数12#include&lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen); 如果一个TCP客户端或者服务器未曾调用bind捆绑一个端口，当调用connect或者listen时，内核就要为相应的套接字选择一个临时端口。 这个过程有一个例外：远程过程调用服务器（Remote Procedure Call，RPC）。他们通常由内核为他们的监听套接字选择一个临时端口，而该端口随后通过RPC端口映射器进行注册。客户在connect这个服务器之前，必须与端口映射器联系以获取他们的临时端口。 进程可以把一个特地的IP地址捆绑到它的套接字上，不过这个IP地址必须属于其所在主机的网络接口之一。对于TCP客户，这就为在该套接字上发送的IP数据报指派了源IP地址。对于TCP服务器，这就限定该套接字只接收那些目的地为这个IP地址的客户连接。 TCP客户通常不把IP地址捆绑到它的套接字上，当连接套接字时，内核将根据所用外出网络接口来选择源IP地址，而所用外出接口则取决于到达服务器所需的路径。如果TCP服务器没有把IP地址捆绑到它的套接字上，内核就把客户端发送的SYN的目的IP地址作为服务器的源IP地址。 如果指定端口号为0，那么内核就找bind被调用时选择一个临时端口。然而如果指定IP地址为通配地址，那么内核将等到套接字已连接（TCP）或已在套接字上发出数据报（UDP）时才选择一个本地IP地址。 如果想要得到内核所选择的临时端口值，必须调用函数getsockname来返回协议地址。 bind函数返回一个常见错误EADDRINUSE(“Adress already in use”，地址已使用) listen函数12#include&lt;sys/socket.h&gt;int listen(int sockfd,int backlog) listen函数仅由TCP服务器调用，它完成两件事情： 当socket函数创建一个套接字时，它被假定为一个主动套接字，也就是说，它是一个将调用connect发起连接的客户端套接字。listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。调用listen导致套接字从closed状态转换到LISTEN状态。 第二个参数规定了内核应该为相应套接字排队的最大连接个数。 内核为任何一个给定的监听套接字维护两个队列： 未完成连接队列（incomplete connection queue），每个这样的SYN分节对应其中一项：已由某个客户端发出并到达服务器，而服务器正在等待并完成相应的TCP三路握手过程。这些套接字处于SYN_RCVD状态。 已完成连接队列（complete connection queue），每个已完成三路握手的客户端对应其中一项，这些套接字处于ESTABLISHED状态。 如果三路握手正常完成，该项就从未完成连接队列移到已完成队列的队尾。当进程调用accept时，已完成连接队列中的队头将返回给进程，如果该队列为空，那么进程将被投入睡眠，知道TCP在该队列中放入一项才唤醒它。 关于两个队列： listen函数的backlog参数曾被规定为这两个队列的总和的最大值。 源自Berkeley的实现给backlog增设了一个模糊因子（fudge factor）：把它乘以1.5得到未处理队列最大长度。 不要把backlog定义为0，如果不想让客户端连接到套接字上，可以关掉该监听套接字。 在三路握手正常完成的前提下（也就是说没有丢失分节，从而没有重传），未完成连接队列中的任何一项在其中的存留时间就是一个RTT，而RTT的值取决于特定的客户与服务器。 当一个客户SYN到达时，若这些队列是满的，TCP就忽略该分节，也就是不发送RST，这么做是因为：这种情况是暂时的，客户TCP将重发SYN。 在三路握手完成之后，但在服务器调用accept之前到达的数据应由服务器TCP排队，最大数据量为已连接套接字接收缓冲区大小。 accept函数12#include&lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen) accept函数由TCP服务器调用，用于从已完成连接队列头返回下一个已完成连接。如果已完成连接队列为空，那么进程被投入睡眠（假设套接字为默认的阻塞方式）。 如果accept成功，那么其返回值是由内核自动生成的一个全新描述符，代表与说返回客户的TCP连接。 accept函数的第一个参数为监听套接字（listening socket）描述符（由socket创建，随后用作bind和listen的第一个参数的描述符），称它的返回值为已连接套接字（connected socket）。 一个服务器通常只创建一个监听套接字，它在该服务器的生命期内一直存在。内核为每个由服务器进程接收的客户连接创建一个已连接套接字（也就是说对于它的TCP三路握手过程已经完成）。当服务器完成对某个给定客户的服务时，相应的已连接套接字就被关闭。 close函数12#include &lt;unistd.h&gt;int close(int sockfd); close将一个TCP套接字的默认行为是把该套接字标记成已关闭，然后立即返回到调用进程，该套接字不能再由调用进程使用。然而TCP尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接终止序列。 并发服务器中父进程关闭已连接套接字只是导致相应描述符的引用计数值减1。如果引用计数值仍大于0，这个close调用并不引发TCP的四分组连接终止序列。 如果确实想在某个TCP连接上发送FIN，那么可以改用shutdown函数以代替close。 如果父进程对每个accept返回的已连接套接字都不调用close，首先父进程最终将耗尽可用描述符，因为任何进程在任何时刻可拥有的打开着的描述符通常都是有限制的。更重要的是，没有一个客户端连接会被终止。当子进程关闭已连接套接字时，它的引用计数值将由2递减为1且保持为1，因为父进程永不关闭任何已连接的套接字。这将妨碍TCP连接终止序列的发生，导致连接一直打开。 getsockname 和 getpeername函数这两个函数或者返回与某个套接字关联的本地协议地址（getsockname），或者返回与某个套接字关联的外地协议地址（getpeername）。123#include&lt;sys/socket.h&gt;int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);int getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen); wait 和 waitpid 函数123#include &lt;sys/wait.h&gt;pid_t wait(int *statloc);pid_t waitpid(pid_t pid, int *statloc, int options); 函数wait和waitpid均返回两个值：已终止子进程的进程ID号，以及通过statloc指针返回的子进程终止状态（一个整数）。 如果调用wait的进程没有已终止的子进程，不够有一个或多个子进程仍在执行，那么wait将阻塞到现有子进程第一个终止为止。 waitpid函数就等待哪个进程以及是否阻塞给了更多的控制。首先，pid参数允许我们指定想等待的进程ID，值-1表示等待第一个终止的子进程。其次，option允许指定附加选项，最常用的选项是WNOHANG，它告知内核在没有已终止的子进程时不要阻塞。 shutdown函数终止网络连接的常用方法是调用close函数。不过close有两个限制，却可以使用shutdown函数来避免。 close把描述符的引用计数减1，仅在该计数变成0时才关闭套接字。使用shutdown可以不管引用计数就激发TCP的正常连接终止序列。 close终止读和写两个方向的数据传送。既然TCP连接是全双工的，有时候需要告知对端我们已经完成了数据发送，即使对端仍有数据要发送给我们。 12#include&lt;sys/socket.h&gt;int shutdown(int sockfd, int howto); shutdown的行为依赖于howto参数的值： SHUT_RD 关闭连接的读这一半————套接字中不再有数据可接收，而且套接字接收缓冲区中的现有数据都被丢弃。进程不能再对这样的套接字调用任何读函数。对一个TCP套接字调用这样的shutdown函数后，由该套接字接收的来自对端的任何数据都被确认，然后丢弃。 SHUT_WR 关闭连接的写这一半————对于TCP套接字，则成为半关闭（half close）。当前留在套接字发送缓冲区中的数据将被发送掉，后跟TCP的正常的连接终止序列。不管套接字描述符的引用计数是否等于0，这样的写半部分关闭照样执行。进程不能在对这样的套接字调用任何写函数。 SHUT_RDWR 连接的读半部和写半部都关闭————这与调用shutdown两次等效：第一次调用指定SHUT_RD，第二次调用指定SHUT_WR。 网络编程时遇到的情况 当fork子进程时，必须捕获SIGHLD信号。 当捕获信号时，必须处理被中断的系统调用。 SIGCHLD的信号处理函数必须正确编写，应使用waitpid函数以面留下僵死进程。","categories":[{"name":"Unix Network Programming","slug":"Unix-Network-Programming","permalink":"https://uyouii.github.io/categories/Unix-Network-Programming/"}],"tags":[{"name":"c","slug":"c","permalink":"https://uyouii.github.io/tags/c/"},{"name":"network","slug":"network","permalink":"https://uyouii.github.io/tags/network/"},{"name":"socket","slug":"socket","permalink":"https://uyouii.github.io/tags/socket/"},{"name":"tcp","slug":"tcp","permalink":"https://uyouii.github.io/tags/tcp/"}]},{"title":"网络知识","slug":"网络知识","date":"2018-02-23T09:16:20.000Z","updated":"2019-08-02T03:28:18.918Z","comments":true,"path":"2018/02/23/网络知识/","link":"","permalink":"https://uyouii.github.io/2018/02/23/网络知识/","excerpt":"","text":"客户端端口号客户端通常使用短期存活的临时端口（ephemeral port）。这些端口号通常由传输层协议自动赋予客户端。客户通常不关心其临时端口的具体值，只需要确定该端口号在所在主机中是唯一的就行。传输协议代码要确保这种唯一性。 MTUmaximum transmission unit, 最大传输单元。 许多网络有一个硬件规定的MTU。例如，以太网的MTU是1500字节。 在两个主机之间的路径最下的MTU称为路径MTU(path MTU)。两个主机相反方向上路径MTU可以不一致，因为在因特网中路由选择往往是不对称的，也就是说从A到B的路径和从B到A的路径可以不相同。 当一个IP数据报从某个接口送出时，如果它的大小超过相应链路的MTU，IPv4和IPv6都将执行分片(fragmentation)。这些片段在到达目的地之前通常不会被重组（reassembling）。IPv4主机对其产生的数据报执行分片，IPv4路由器对其转发的数据包执行分片。然而IPv6只有主机对其产生的数据报执行分片，IPv6路由器不对其转发的数据报执行分片。 IPv4和IPv6都定义了最小重组缓冲区大小（minimum reassembly buffer size），它是IPv4或IPv6的任何实现都必须保证支持的最小数据报大小。其值对于IPv4是576字节，对于IPv6是1500字节。 TCP中有一个MSS（maximum segment size，最大分片大小），用于向对端TCP通告对端在每个分节中能发送的最大TCP数据量。MSS的目的是告诉对端其重组缓冲区大小的实际值，从而避免试图分片。MSS经常设置成MTU减去IP和TCP首部固定长度。 在以太网中使用IPv4的MSS值为1460，使用IPv6的MSS值为 PDU(协议数据单元 protocol data unit)计算机网络各层对等实体间交换的单位信息称为协议数据单元(PDU)，按照协议与服务之间的关系，除了最底层（物理层）外，每层的PDU通过紧邻下层提供给本层的服务接口，作为下层的服务数据单元(service data unit, SDU)传递给下层，并由下层完成本层的PDU交换。如果本层的PDU大小超过紧临下层的最大SDU限制，那么本层需要实现把SDU划分为若干个合适的片段让下层分开载送，再在相反的方向把这些碎片重组成PDU。 应用层实体(如客户或者服务器进程)间交换的PDU称为应用数据(application data)，其中在应用进程之间交换的时没有长度限制的单个双向字节流，在UDP应用进程之间交换的是其长度不超过UDP发送缓冲区大小的单个记录(record)，在SCTP应用进程之间交换的是没有总长度限制的单个或多个双向记录流。 传输层实体间交换的PDU称为消息(message)，其中TCP的PDU称为分节(segment)。消息或分节的长度是有限的。 在TCP传输中，发送端TCP把来自应用进程的字节流数据按顺序经分割后封装在各个分节中传送给接收端TCP，其中每个分节所封装的数据即可能是发送端应用进程单次输出操作的结果，也可能是连续数次输出操作的结果，而且每个分节所封装的单次输出操作的结果或者首尾两次输出操作的结果既可能是完整的，也可能是不完整的，具体取决于连接建立阶段由对端通告的最大分节大小(MSS, maximum segment size)，以及外出接口的最大传输单元(maximum transmission unit, MTU)。 UDP传输层相当简单，发送端UDP就把来自应用进程的单个记录整个封装在UDP消息中传送给接收端UDP。 SCTP引入了称为块(chunk)的数据单元，SCTP消息就由一个公共首部加上一个或多个块构成：公共首部类似UDP消息的首部，仅仅给出源目的端口号和整个SCTP消息的校验和；块既可以承载数据，也可以承载控制信息。发送端SCTP把来自应用进程的（一个或多个）记录流数据按照数据流内顺序和记录边界封装在各个DATA块中，并在DATA块首部记上各自的流ID。 一个记录通常对应一个DATA块，对于过长的记录，发送端SCTP既可以像UDP那样拒绝发送，也可以把他们拆分到多个DATA块中以便发送，接收端SCTP收取后把他们组合成单个记录上传。 网络成实体间交换的PDU称为IP数据报(IP datagram)，其长度有限：IPV4数据报最大65535字节，IPv6数据报最大65575字节。发送端IP把来自传输层的消息（或TCP分节）整个封装在IP数据报中传送。 链路层实体间交换的PDU称为帧（frame），其长度取决于具体的接口。 IP数据报由IP首部和所承载的传输层数据构成。过长的IP数据报无法封装在单个帧中，需要首先对其SDU进行分片（fragementation），再把分成对得各个片段（fragement）冠以新的IP首部封装到多个帧中。在一个IP数据包从源端传送到目的端的传送过程中，分片操作既可能发生在源端，也可能发生在途中。 TCP/IP协议族为提高效率会尽可能避免IP分片/重组操作：TCP根据MSS和MTU限定每个分节的大小以及SCTP根据MTU分片/重组过长记录都是这个目的（STCP的块捆绑这是为了避免IP分片/重组操作的前提下提高块传输效率）；另外，IPv6禁止在途中的分片操作（基于其路径MTU发现功能），IPv4也尽量避免这种操作。 不论是否分片，都由IP作为链路层的SDU传入链路层，并由链路层封装再帧中的数据称为分组（packet，俗称包）。一个分组既可能是一个完整的IP数据报，也可能是某个IP数据报的SDU的一个片段冠以新的IP首部的结果。","categories":[{"name":"Unix Network Programming","slug":"Unix-Network-Programming","permalink":"https://uyouii.github.io/categories/Unix-Network-Programming/"}],"tags":[{"name":"network","slug":"network","permalink":"https://uyouii.github.io/tags/network/"}]},{"title":"socket 编程","slug":"socket-编程","date":"2018-02-23T09:16:07.000Z","updated":"2019-08-02T03:28:18.917Z","comments":true,"path":"2018/02/23/socket-编程/","link":"","permalink":"https://uyouii.github.io/2018/02/23/socket-编程/","excerpt":"","text":"套接字标识每个端点的两个值（IP地址和端口号）通常称为一个套接字。 TCP无法仅仅通过查看端口号来分离外来的分节到不同的端点。它必须查看套接字对的所有4个元素才能确定由哪个端点接收某个到达的分节。 不同套接字地址结构比较 getsockopt 和 setsockopt 函数这两个函数仅用于套接字123#include &lt;sys/socket.h&gt;int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);int setsockopt(int sockfd, int level, int optname, const void* optval, socklen_t optlen); optval是一个指向某个变量的指针，setsockopt从*optval中取得选项待设置的新值，getsockopt则把已获取的选项当前值存放到*optval中。 套接字选项粗分为两大基本类型：一是启用或者禁止某个特性的二元选项（称为标志选项），二是取得并返回我们可以设置或检查的特定值选项（称为值选项）。 当给这些标志选项调用getsockopt函数时，*optval是一个整数。*optval中返回的值为0表示相应选项被禁止，不为0表示相应选项被启用。 setsockopt函数需要一个不为0的*optva值来启用选项，一个为0的*optval值来禁止选项。 套接字选项SO_KEEPALIVE 套接字选项给一个TCP套接字设置保持存活（keep-alive）选项后，如果在2小时内在该套接字的任一方向上都没有数据交换，TCP就自动给对端发送一个保持存活探测分节(keep-alive probe)。这是一个对端必须响应的TCP分节。 发送该分节后： 对端以期望的ACK响应。应用进程得不到通知（因为一切正常）。在又经过仍无动静的2小时后，TCP将发出另一个探测分节。 对端以rst响应，它告知本端TCP：对端已崩溃且已重新启动。该套接字的待处理错误被置为ECONNRESET，套接字本身则被关闭。 对端对保持存活探测分节没有任何响应。源自Berkeley的TCP将另外发送8个探测分节，两两相隔75秒，试图得到一个响应。TCP在发出第一个探测分节后11分15秒内若没有得到任何响应则放弃。 如果根本没有对TCP的探测分节的响应，该套接字的待处理错误就被置为ETIMEOUT，套接字本身则被关闭，然而如果该套接字收到一个ICMP错误作为某个探测分节的响应，那就返回相应的错误，套接字本身也被关闭。 本选项的功能是检测对端主机是否崩溃或变得不可达。如果对端进程崩溃，它的TCP将跨连接发送一个FIN，这可以通过调用select很容易的检测到。同时也要认识到，即使对任何保持存活探测分节均无响应（第三种情况），我们也不能肯定对端主机已经崩溃，因而TCP可能会终止一个有效连接。 本选项一本由服务器调用，不过客户端也可以使用。服务器使用本选项是因为它们花大部分时间阻塞在等待穿越TCP的连接输入上，也就是说在等待客户端的请求。然而如果客户主机连接掉线、电源掉线或系统崩溃，服务器进程将永远不会知道，并将继续等待永远不会到达的输入。这种情况称为半开连接（half-open connection）。保持存活选项将检测出这些半开连接并终止他们。 SO_RCVBUF 和 SO_SNDBUF 套接字选项每个套接字都有一个发送缓冲区和一个接收缓冲区。 接收缓冲区被TCP、UDP和SCTP用来保存接收到的数据，知道由应用进程来读取。对于TCP来说，套接字接收缓冲区中可用空间的大小限定了TCP通告对端的窗口大小。TCP套接字接收缓冲区不可能溢出，因为不允许对端发出超过本端所通告窗口大小的数据。这就是TCP的流量控制，如果对端无视窗口大大小而发出了超过该窗口大小的数据，本端TCP将丢弃他们。UDP是没有流量控制的：较快的发送端可以很容易地淹没较慢的接收端，导致接收端的UDP丢弃数据报。事实上较快的发送端甚至可以淹没本机的网络接口，导致数据报被本机丢弃。 当设置TCP套接字接收缓冲区的大小时，函数调用的顺序很重要。这是因为TCP的窗口规模选项是在建立连接时用SYN分节与对端互换得到的。对于客户，这意味着SO_RCVBUF选项必须在调用connect之前设置；对于服务器，这意味着该选项必须在调用listen之前给监听套接字设置。给已连接套接字设置该选项对于可能存在的窗口规模选项没有任何影响，因为accept直到TCP的三路握手完成才会创建并返回已连接套接字。这就是必须给监听套接字设置本选项的原因。（套接字缓冲区的大小总是由新创建的已连接套接字从监听套接字继承而来）。 TCP套接字缓冲区的大小至少应该是相应连接的MSS值的四倍。这一点的依据是TCP快速恢复算法的工作机制。TCP发送端使用三个重复的确认来检测某个分节是否丢失。发现某个分节丢失后，接收端将给新收到的每个分节发送一个重复的确认，如果窗口大小不足以存放4个这样的分节，那就不可能连发三个重复的确认，从而无法激活快速恢复算法。 TCP_NODELAY套接字选项开启TCP_NODELAY选项将禁止TCP的Nagle算法。 Nagle算法的目的在于减少广域网（WAN）上小分组的数目。该算法指出：如果某个给定连接上有待确认数据（outstanding dataa），那么原本应该作为用户写操作相应的在该连接上立即发送相应小分组的行为就不会发生，直到现有数据被确认为止。这里“小”的定义就是小于MSS的任何分组。TCP总是尽可能地发送最大大小的分组，Nagle算法的目的在于防止一个连接在任何时刻有多个小分组待确认。 Nalge算法常常与另一个TCP算法联合使用：ACK延滞算法（delayed ACK algorithm）。该算法使得TCP在收到数据后不立即发送ACK，而是等待一小段时间(典型值为50~200ms)，然后才发送ACK。TCP期待在这一小段时间内自身有数据发送回对端，被延滞的ACK就可以由这些数据捎带，从而省掉一个TCP分节。","categories":[{"name":"Unix Network Programming","slug":"Unix-Network-Programming","permalink":"https://uyouii.github.io/categories/Unix-Network-Programming/"}],"tags":[{"name":"network","slug":"network","permalink":"https://uyouii.github.io/tags/network/"},{"name":"socket","slug":"socket","permalink":"https://uyouii.github.io/tags/socket/"}]},{"title":"python2.7 深入理解","slug":"python2-7-深入理解","date":"2018-02-02T03:04:13.000Z","updated":"2019-08-02T03:28:18.916Z","comments":true,"path":"2018/02/02/python2-7-深入理解/","link":"","permalink":"https://uyouii.github.io/2018/02/02/python2-7-深入理解/","excerpt":"","text":"tuple 和 list的异同 tuple是不可变的，list是可变的。 tuple表示的是结构，list表示的是顺序。 list不能当作dict的key，tuple可以。 由于元组支持的操作比列表小，所以元组的操作相对于list会快上一点点。(除非有巨量的数据需要去处理，否则这一点不需要特别强调) tuple所谓的不可变指的是指向的位置不可变。如果tuple中含有一个list，这个list的内容是可以变化的，因为list本身在内存中的分配不是连续的。 while/else 和 for/else循环可以有一个else子句在循环迭代完整个列表(对于for)后或执行条件为false(对于while)时执行，但循环被break中止的情况下不会执行。 三元运算符value if condition else other_value e.g.12is_fat = Truestate = \"fat\" if is_fat else \"not fat\" 嵌套函数和闭包(Closure)函数不仅可以定义在模块的最外层，还可以定义在另一个函数的内部，像这种定义在函数里面的函数称之为嵌套函数。 嵌套函数可以访问到其外层作用域中声明的非局部变量。 闭包却可以即使脱离函数本身的作用范围，局部变量还是可以被访问得到。 闭包的定义：在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量， 则可能产生闭包。运行时，一旦外部的 函数被执行，一个闭包就形成了， 闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用。 闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。 在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。 注意：python闭包必须通过嵌套函数定义实现，但是嵌套函数不一定是闭包。 当一个函数在执行完以后，访问了嵌套作用域的局部变量，闭包就产生了。假如嵌套函数没有访问嵌套作用域的局部变量，它就不是闭包。 产生闭包必须具备三个条件： 需要定义嵌套函数 嵌套函数需要引用enclosing function中的变量 enclosing function需要返回嵌套函数 闭包的作用：闭包可以避免全局变量的使用，并且可以隐藏一些数据的格式。同时也可以提供面向对象的方法。 Python Closures 迭代器(Iterators)python中的迭代器是一个可以被迭代的对象，每次迭代返回一个数据元素。 python的迭代器对象必须要实现两个特殊的方法：__iter()__和__next()__，被称为iterator protocol 如果我们可以从一个对象获取iterator，则把这个对象成为iterable。很多python内置的容器都是可迭代的，像list, tuple, string。 可以通过next()函数人工的迭代遍历迭代器中所有的元素，当没有数据返回时，函数会抛出StopIteration异常。 一个更优雅的使用迭代器的方式是使用for循环，for可以迭代任何能够返回迭代器的对象。 for 的内部实现12for element in iterable: # do something with element 实际实现：123456789101112# create an iterator object from that iterableiter_obj = iter(iterable)# infinite loopwhile True: try: # get the next item element = next(iter_obj) # do something with element except StopIteration: # if StopIteration is raised, break from loop break for语句首先通过调用iter()创建了一个迭代器对象：iter_obj。 在循环内部通过调用next()函数去获取下一个元素。在所有元素都处理完之后，StopIteration被抛出，并在循环内部被捕获，并保证其他类型的异常不被捕获。 实现迭代器对象实现迭代器对象只需要实现两个方法：__iter()__和__next()__ __iter()__方法返回迭代器对象本身。如果需要的话，可以进行初始化的操作。 __next()__方法返回序列中的下一个元素。当达到最后一个元素的下一个调用时必须抛出StopIteration异常。 for example：123456789101112131415161718class PowTwo: \"\"\"Class to implement an iterator of powers of two\"\"\" def __init__(self, max = 0): self.max = max def __iter__(self): self.n = 0 return self def __next__(self): if self.n &lt;= self.max: result = 2 ** self.n self.n += 1 return result else: raise StopIteration Python Interators 生成器(Generators)生成器是创建迭代器的一种简单的方式。简单的说，生成器就是可以返回一个可迭代对象的函数（每次返回一个元素） 生成器的创建非常简单，只需要把函数定义中的return替换为yeild即可。 如果一个函数中包含了至少一个yeild语句，这个函数就是生成器。yeild和return都会从函数中返回值。 不同的是，return语句会终止整个函数的执行，yeild语句会暂停函数的执行并且储存函数的状态，在下一次成功调用后继续执行。 生成器函数和普通函数的异同： 生成器函数包含了一个或者多个yelid语句 当被调用时，生成器函数返回一个迭代器对象，但是函数不会立即开始执行。 __iter()__方法和__next()__方法会被自动的实现，所以可以调用next()函数获取下一个元素。 当函数执行yelid语句时，函数会被暂停执行，控制权会返还给调用者 局部变量和他们的状态在成功的调用之间会被保存 当函数结束时，StopIteration会在下一次的调用时被自动抛出。 每个生成器只能被调用一次，要重新开始生成器的调用可以创建一个新的生成器对象，像:a = my_gen() 可以直接在for循环中使用生成器 生成器表达式(Generator Expression)生成器表达式(generateor expression)的语法和列表推导式(list comprehension)的结构很像，只需要把方括号替换为圆括号。 generator expression和list comprehension最主要的区别就是list comprehension每次生成整个列表，但是generator expression每次生成一个元素。 genreator expression只有每次被调用的时候才会输出元素，所以generator expression比list comprehension在内存的使用上跟高效。 12345678910# Initialize the listmy_list = [1, 3, 6, 10]# square each term using list comprehension# Output: [1, 9, 36, 100][x**2 for x in my_list]# same thing can be done using generator expression# Output: &lt;generator object &lt;genexpr&gt; at 0x0000000002EBDAF8&gt;(x**2 for x in my_list) generator expression可以被函数调用，这种情况下圆括号可以省去。12&gt;&gt;&gt; sum(x**2 for x in my_list)146 Python Generators 装饰器(decorator)装饰器可以向已经写好的代码中添加功能，程序的一部分可以在编译时修改程序的另一部分。 everything in python are objects. python函数的一些特性： 同一个函数对象可以绑定不同的函数名称 函数可以作为参数传递给另一个函数(这些函数也被称为higher order functions) 函数可以把函数当作返回值 函数和方法被称为可调用的(called)。在python中任何实现__call__()方法的对象都称为可调用的(called)。 装饰器就是callable并返回callable的对象。 装饰器一般读取一个函数，为其添加功能然后返回。 12345678def make_pretty(func): def inner(): print(\"I got decorated\") func() return innerdef ordinary(): print(\"I am ordinary\") 12345678&gt;&gt;&gt; ordinary()I am ordinary&gt;&gt;&gt; # let's decorate this ordinary function&gt;&gt;&gt; pretty = make_pretty(ordinary)&gt;&gt;&gt; pretty()I got decoratedI am ordinary 可以使用@符号和装饰器名称一起使用，放在函数定义前，表示该函数使用该装饰器123@make_prettydef ordinary(): print(\"I am ordinary\") 等价于123def ordinary(): print(\"I am ordinary\")ordinary = make_pretty(ordinary) 带参数的装饰器需要保证inner function的参数和被修饰的函数参数保持一致。可以用一种通用的装饰器的实现方法：12345def works_for_all(func): def inner(*args, **kwargs): print(\"I can decorate any function\") return func(*args, **kwargs) return inner args是位置参数的元组，kwargs是默认参数的字典。 同一个函数可以被多个装饰器装饰多次（可以是同一个装饰器）。 Python Decorator 属性（Property）property example:123456789101112131415161718class Celsius(object): def __init__(self, temperature = 0): self.temperature = temperature def to_fahrenheit(self): return (self.temperature * 1.8) + 32 def get_temperature(self): print(\"Getting value\") return self._temperature def set_temperature(self, value): if value &lt; -273: raise ValueError(\"Temperature below -273 is not possible\") print(\"Setting value\") self._temperature = value temperature = property(get_temperature,set_temperature) 我们在最后一行创造了一个property对象：temperature。任何获取temperature值的代码会自动调用get_temperature()方法，而不是向__dict__中查找，任何给temperature赋值的代码会自动调用set_temperature()。 在python中，property()是一个内置的函数，创建和返回一个property对象。1property(fget=None, fset=None, fdel=None, doc=None) fget是获取属性的值的函数，fset是设置属性值的函数，fdel是删除属性的函数，doc是一个字符串（类似于注释）。 property对象有三个方法：gettter(),setter()和delete()用于设置fget,fset和del。1temperature = property(get_temperature,set_temperature) 可以等价于123456# make empty propertytemperature = property()# assign fgettemperature = temperature.getter(get_temperature)# assign fsettemperature = temperature.setter(set_temperature) 注意：python2中实现property时，需要继承object，否则setter无效。python3默认继承，所以没有问题。 使用装饰器实现property123456789101112131415161718class Celsius(object): def __init__(self, temperature = 0): self._temperature = temperature def to_fahrenheit(self): return (self.temperature * 1.8) + 32 @property def temperature(self): print(\"Getting value\") return self._temperature @temperature.setter def temperature(self, value): if value &lt; -273: raise ValueError(\"Temperature below -273 is not possible\") print(\"Setting value\") self._temperature = value Python Property 方法和函数的区别 function(函数) —— A series of statements which returns some value toa caller. It can also be passed zero or more arguments which may beused in the execution of the body. method(方法) —— A function which is defined inside a class body. If called as an attribute of an instance of that class, the method will get the instance object as its first argument (which isusually called self). 本质上，函数和方法的区别是：函数属于FunctionObject，而方法属于PyMethodObject。 e.g.123456789def aa(d, na=None, *kasd, **kassd): passclass A(object): def f(self): return 1a = A()print aaprint A.fprint a.f 结果：123&lt;function aa at 0x0000000004D995F8&gt;&lt;unbound method A.f&gt;&lt;bound method A.f of &lt;__main__.A object at 0x0000000004DB97F0&gt;&gt; Bound Method 和 Unbound Methodmethod还可以分为bound method和unbound method，bound method多了一个实例绑定的过程。 A.f是unbound method，a.f是bound method bound和unbound的判断依据就是，当方法真正执行时，有没有传入实例。 A.f(a)和a.f()用法的区别只在于，第一种需要认为传入实例才能调用，第二种虚拟机帮我们做好了传入实例的动作，两种方法本质上是等价的。 类方法(classmethod)和静态方法(statimethod) @classmethod means: when this method is called, we pass the class as the first argument instead of the instance of that class (as we normally do with methods). This means you can use the class and its properties inside that method rather than a particular instance. @staticmethod means: when this method is called, we don’t pass an instance of the class to it (as we normally do with methods). This means you can put a function inside a class but you can’t access the instance of that class (this is useful when your method does not use the instance). classmethod must have a reference to a class object as the first parameter, whereas staticmethod can have no parameters at all. example:123456789101112131415161718192021class Date(object): def __init__(self, day=0, month=0, year=0): self.day = day self.month = month self.year = year @classmethod def from_string(cls, date_as_string): day, month, year = map(int, date_as_string.split('-')) date1 = cls(day, month, year) return date1 @staticmethod def is_date_valid(date_as_string): day, month, year = map(int, date_as_string.split('-')) return day &lt;= 31 and month &lt;= 12 and year &lt;= 3999date2 = Date.from_string('11-09-2012')is_date = Date.is_date_valid('11-09-2012') class method现在如果有一种需求通过接收一个外部的格式化的字符串(形如dd-mm-yy)需要创造大量的Date的实例。 在C++中可以通过重载的方式实现这种操作(重载Date的构造函数)，但是python没有这种特性。 上述的classmethod方法中，cls这个对象承载的是这个类本身，而不是这个类的实例。并且在cls的子类中也可以获取到这个方法。 static method静态方法和类方法很像，但是静态方法没有强制性参数的要求。 但是静态方法无法访问这个实例本身，也无法调用类的内部方法和变量。 classmethod and staticmethod in stackoverflow","categories":[{"name":"learning python","slug":"learning-python","permalink":"https://uyouii.github.io/categories/learning-python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://uyouii.github.io/tags/python/"}]},{"title":"python2.7 基础知识","slug":"python2.7 基础知识","date":"2018-01-30T13:13:58.000Z","updated":"2019-08-02T03:28:18.917Z","comments":true,"path":"2018/01/30/python2.7 基础知识/","link":"","permalink":"https://uyouii.github.io/2018/01/30/python2.7 基础知识/","excerpt":"","text":"python 入门指南 数字 //运算符用于 floor division 而无论操作数是什么类型。 可以使用 ** 运算符计算幂乘方 字符串 使用 原始字符串，方法是在第一个引号前面加上一个 r，例如 r&#39;C:\\some\\name&#39; 字符串文本能够分成多行。一种方法是使用三引号：&quot;&quot;&quot;...&quot;&quot;&quot; 或者 &#39;&#39;&#39;...&#39;&#39;&#39;。行尾换行符会被自动包含到字符串中，但是可以在行尾加上 \\ 来避免这个行为。 字符串可以由 + 操作符连接(粘到一起)，可以由 * 表示重复 相邻的两个字符串文本自动连接在一起，只用于两个字符串文本，不能用于字符串表达式，如果想连接多个变量或者连接一个变量和一个字符串文本，使用 + 支持索引和切片。索引用于获得单个字符，切片 让你获得一个子字符串。 12345&gt;&gt;&gt; word = 'Python'&gt;&gt;&gt; word[0:2] # characters from position 0 (included) to 2 (excluded)'Py'&gt;&gt;&gt; word[2:5] # characters from position 2 (included) to 5 (excluded)'tho' Python字符串不可以被更改—它们是不可变的。因此，赋值给字符串索引的位置会导致错误。 内置函数 len() 返回字符串长度。 See also Sequence Types — str, unicode, list, tuple, bytearray, buffer, xrange字符串和下节描述的Unicode字符串是 序列类型 的例子，它们支持这种类型共同的操作。 String Methods字符串和Unicode字符串都支持大量的方法用于基本的转换和查找。 String Formatting这里描述了使用 str.format() 进行字符串格式化的信息。 String Formatting Operations这里描述了旧式的字符串格式化操作，它们在字符串和Unicode字符串是 % 操作符的左操作数时调用。 流程控制 在迭代过程中修改迭代序列不安全(只有在使用链表这样的可变序列时才会有这样的情况)。如果你想要修改你迭代的序列(例如：复制选择项)，你可以迭代它的复本。 需要迭代链表索引的话，可以结合使用 range() 和 len() 123a = [&apos;Mary&apos;, &apos;had&apos;, &apos;a&apos;, &apos;little&apos;, &apos;lamb&apos;]for i in range(len(a)): print i, a[i] 循环可以有一个else子句；它在循环迭代完整个列表(对于for)后或执行条件为false(对于while) 时执行，但循环被 break中止的情况下不会执行。 try语句的else子句在未出现异常时运行，循环的else子句在未出现break时运行。 函数 函数调用 会为函数局部变量生成一个新的符号表。确切地说，所有函数中的变量赋值都是将值存储在局部符号表。变量引用首先在局部符号表中查找，然后是包含函数的局部符号表，然后是全局符号表，最后是内置名字表。因此，全局变量不能在函数中直接赋值 (除非用global语句命名)，尽管他们可以被引用。 函数引用的实际参数在函数调用时引入局部符号表，因此，实参总是传值调用(这里的值总是一个对象引用，而不是该对象的值)。 没有 return 语句的函数确实会返回一个值： None。 函数默认值只被赋值一次。这使得当默认值是可变对象时会有所不同，比如列表、字典或者大多数类的实例。 def是一个可执行指令，只有def执行的时候才会计算默认默认参数的值 在函数调用中，关键字的参数必须跟随在位置参数的后面。 引入一个形如**name的参数时，它接收一个字典。形如*name的形式参数，它接收一个元组。 可以在调用函数时加一个*操作符来自动把参数列表拆开。使用 ** 操作符分拆关键字参数为字典。 列表方法1234567891011121314151617181920212223242526272829list.append(x)把一个元素添加到链表的结尾，相当于 a[len(a):] = [x]。list.extend(L)将一个给定列表中的所有元素都添加到另一个列表中，相当于 a[len(a):] = L。list.insert(i, x)在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引。例如 a.insert(0, x) 会插入到整个链表之前，而 a.insert(len(a), x) 相当于 a.append(x)。list.remove(x)删除链表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。list.pop([i])从链表的指定位置删除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从链表中被删除。\"方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号。\"list.index(x)返回链表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。list.count(x)返回 x 在链表中出现的次数。list.sort(cmp=None, key=None, reverse=False)对链表中的元素就地进行排序（参数可以用来自定义排序方法）。list.reverse()就地倒排链表中的元素。 函数式编程工具filter()filter(function, sequence)返回一个 sequence(序列)，包括了给定序列中所有调用 function(item) 后返回值为 true 的元素(如果可能的话，会返回相同的类型)。如果该序列 (sequence)是一个 str, unicode 或者 tuple，返回值必定是同一类型，否则，它总是 list。 map()map(function, sequence)为每一个元素依次调用 function(item) 并将返回值组成一个链表返回。 可以传入多个序列，函数也必须要有对应数量的参数，执行时会依次用各序列上对应的元素来调用函数(如果某些序列比其它的短，就用 None 来代替)。如果把 None 做为一个函数传入，则直接返回参数做为替代。 reduce()reduce(function, sequence)返回一个单值，它是这样构造的：首先以序列的前两个元素调用函数 function，再以返回值和第三个参数调用，依次执行下去。 如果序列中只有一个元素，就返回它，如果序列是空的，就抛出一个异常。 可以传入第三个参数作为初始值。如果序列是空的，就返回初始值，否则函数会先接收初始值和序列的第一个元素，然后是返回值和下一个元素，依此类推。 列表推导式列表推导式由包含一个表达式的括号组成，表达式后面跟随一个 for 子句，之后可以有零或多个 for 或 if 子句。结果是一个列表，由表达式依据其后面的 for 和 if 子句上下文计算而来的结果构成。 例如：12345678squares = [x**2 for x in range(10)]&gt;&gt;&gt; [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y][(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]&gt;&gt;&gt; from math import pi&gt;&gt;&gt; [str(round(pi, i)) for i in range(1, 6)]['3.1', '3.14', '3.142', '3.1416', '3.14159'] 列表推导式可以嵌套。 例如：12345678&gt;&gt;&gt; matrix = [... [1, 2, 3, 4],... [5, 6, 7, 8],... [9, 10, 11, 12],... ]&gt;&gt;&gt; [[row[i] for row in matrix] for i in range(4)][[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] del语句del语句可以从列表中按给定的索引而不是值来删除一个子项。它不同于有返回值的 pop() 方法。语句 del 还可以从列表中删除切片或清空整个列表(我们以前介绍过一个方法是将空列表赋值给列表的切片)。 del 也可以删除整个变量。 元组和序列一个元组由数个逗号分隔的值组成。 元组在输出时总是有括号的，以便于正确表达嵌套结构。在输入时可以有或没有括号，不过经常括号都是必须的(如果元组是一个更大的表达式的一部分)。 不能给元组的一个独立的元素赋值(尽管你可以通过联接和切割来模拟)。还可以创建包含可变对象的元组，例如链表。 元组是不可变的，通常包含不同种类的元素并通过分拆或索引访问（如果是 namedtuples，甚至可以通过属性）。列表是可变的，它们的元素通常是相同的类型并通过迭代访问。 构造包含零个或一个元素的元组：12&gt;&gt;&gt; empty = ()&gt;&gt;&gt; singleton = 'hello', # &lt;-- note trailing comma 可变参数(multiple assignment)其实只是元组封装和序列拆封的一个结合。 集合集合是一个无序不重复元素的集。集合对象还支持union(联合)，intersection(交)，difference(差)和 sysmmetric difference(对称差集)等数学运算。 大括号或set()函数可以用来创建集合。注意：想要创建空集合，你必须使用 set() 而不是 {}。后者用于创建空字典。 类似列表推导式，集合也有推导式语法：1&gt;&gt;&gt; a = &#123;x for x in 'abracadabra' if x not in 'abc'&#125; 字典字典以 关键字 为索引，关键字可以是任意不可变类型，通常用字符串或数值。如果元组中只包含字符串和数字，它可以作为关键字，如果它直接或间接地包含了可变对象，就不能当做关键字。 字典的主要操作是依据键来存储和析取值。也可以用del来删除键：值对(key:value)。 对一个字典执行keys()将返回一个字典中所有关键字组成的无序列表(如果你想要排序，只需使用 sorted())。 dict() 构造函数可以直接从 key-value 对中创建字典:1dict([('sape', 4139), ('guido', 4127), ('jack', 4098)]) 字典推导式可以从任意的键值表达式中创建字典:1&#123;x: x**2 for x in (2, 4, 6)&#125; 如果关键字都是简单的字符串，有时通过关键字参数指定 key-value 对更为方便:1dict(sape=4139, guido=4127, jack=4098) 模块模块可以包含执行语句，一般用来初始化模块，仅在第一次被导入的地方执行一次。 每个模块都有自己私有的符号表，被模块内所有的函数定义作为全局符号表使用。因此，模块的作者可以在模块内部使用全局变量，而无需担心它与某个用户的全局变量意外冲突。也可以引用模块函数的表示法访问模块的全局变量，modname.itemname。 出于性能考虑，每个模块在每个解释器会话中只导入一遍。因此，如果修改了模块，需要重启解释器或者如果想交互式的测试这么一个模块，可以用reload()重新加载，例如 reload(modulename)。 如果调用python module.py执行某个模块，此时改模块的__name__被设置为__main__。如果在模块后加入代码：12if __name__ == \"__main__\": pass 就可以让此文件像作为模块导入时一样作为脚本执行。此代码只有在模块作为 “main” 文件执行时才被调用。如果模块被导入，则不会执行这段代码。 当导入一个叫module的模块时，解释器现在当前的目录中搜索名为module.py的文件，如果没有找到的话，接着会到sys.path变量中给出的目录列表中查找。 sys.path变量的初始值： 输入脚本的目录(当前目录)。 环境变量PYTHONPATH表示的目录列表中搜索 Python 默认安装路径中搜索。 如果在name.py所在的目录下存在一个名为name.pyc的文件，它会被视为name模块的预编译(byte-compiled,二进制编译版本)，对于引用了大量标准模块的短程序，可以提高启动速度。用于创建name.pyc的这一版spam.py的修改时间记录在spam.pyc文件中，如果两者不匹配，.pyc文件就被忽略。 包为了让 Python 将目录当做内容包，目录中必须包含__init__.py文件。这是为了避免一个含有烂俗名字的目录无意中隐藏了稍后在模块搜索路径中出现的有效模块，比如string。最简单的情况下，只需要一个空的__init__.py文件即可。当然它也可以执行包的初始化代码，或者定义__all__变量。 执行from package import *时，如果包中的__init__.py代码定义了一个名为__all__的列表，就会按照列表中给出的模块名进行导入。 显式或隐式相对位置导入都基于当前模块的命名。因为主模块的名字总是 __main__，Python 应用程序的主模块应该总是用绝对导入。 异常处理try 语句按如下方式工作： 首先，执行 try 子句(在 try 和 except 关键字之间的部分)。 如果没有异常发生，except 子句在 try 语句执行完毕后就被忽略了。 如果在 try 子句执行过程中发生了异常，那么该子句其余的部分就会被忽略。如果异常匹配于 except 关键字后面指定的异常类型，就执行对应的 except 子句。然后继续执行 try 语句之后的代码。 如果发生了一个异常，在 except 子句中没有与之匹配的分支，它就会传递到上一级 try 语句中。如果最终仍找不到对应的处理语句，它就成为一个 未处理异常，终止程序运行，显示提示信息。 一个 try 语句可能包含多个 except 子句，分别指定处理不同的异常。至多只会有一个分支被执行。异常处理程序只会处理对应的 try 子句中发生的异常，在同一个 try 语句中，其他子句中发生的异常则不作处理。一个 except 子句可以在括号中列出多个异常的名字，例如:12except (RuntimeError, TypeError, NameError): pass 最后一个 except 子句可以省略异常名称，以作为通配符使用。你需要慎用此法，因为它会轻易隐藏一个实际的程序错误！可以使用这种方法打印一条错误信息，然后重新抛出异常(允许调用者处理这个异常):123456except IOError as e: passexcept ValueError: passexcept: raise try … except 语句可以带有一个 else子句 ，该子句只能出现在所有 except 子句之后。当 try 语句没有抛出异常时，需要执行一些代码，可以使用这个子句。 raise语句允许程序员强制抛出一个指定的异常。要抛出的异常由raise的唯一参数标识。它必需是一个异常实例或异常类(继承自 Exception 的类)。如果你需要明确一个异常是否抛出，但不想处理它，raise语句可以让你很简单的重新抛出该异常。 不管有没有发生异常，finally子句 在程序离开 try 后都一定会被执行。当 try 语句中发生了未被 except 捕获的异常(或者它发生在 except 或 else 子句中)，在 finally 子句执行完后它会被重新抛出。try 语句经由 break，continue 或 return 语句退出也一样会执行 finally 子句。1234try: raise KeyboardInterruptfinally: print 'Goodbye, world!' 类命名空间和作用域命名空间 是从命名到对象的映射。当前命名空间主要是通过 Python 字典实现的。 不同命名空间中的命名没有任何联系。 不同的命名空间在不同的时刻创建，有不同的生存期。包含内置命名的命名空间在 Python 解释器启动时创建，会一直保留，不被删除。模块的全局命名空间在模块定义被读入时创建，通常，模块命名空间也会一直保存到解释器退出。由解释器在最高层调用执行的语句，不管它是从脚本文件中读入还是来自交互式输入，都是__main__模块的一部分，所以它们也拥有自己的命名空间(内置命名也同样被包含在一个模块中，它被称作__builtin__)。 当调用函数时，就会为它创建一个局部命名空间，并且在函数返回或抛出一个并没有在函数内部处理的异常时被删除。每个递归调用都有自己的局部命名空间。 作用于访问顺序：包含局部命名的使用域在最里面，首先被搜索；其次搜索的是中层的作用域，这里包含了同级的函数；最后搜索最外面的作用域，它包含内置命名。 首先搜索最内层的作用域，它包含局部命名任意函数包含的作用域，是内层嵌套作用域搜索起点，包含非局部，但是也非全局的命名 接下来的作用域包含当前模块的全局命名 最外层的作用域(最后搜索)是包含内置命名的命名空间。 一个定义于某模块中的函数的全局作用域是该模块的命名空间，而不是该函数的别名被定义或调用的位置。 类对象类对象支持两种操作：属性引用和实例化。 类定义了__init__()方法的话，类的实例化操作会自动为新创建的类实例调用__init__()方法。 和局部变量一样，数据属性不需要声明，第一次使用时它们就会生成。 类中所有(用户定义)的函数对象对应它的实例中的方法。实例中的函数是方法对象，不是函数对象。 例子：123456class MyClass: \"\"\"A simple example class\"\"\" i = 12345 def f(self): return 'hello world'x = MyClass() 方法的特别之处在于实例对象作为函数的第一个参数传给了函数。 调用x.f()相当于MyClass.f(x) 引用非数据属性的实例属性时，会搜索它的类。如果这个命名确认为一个有效的函数对象类属性，就会将实例对象和函数对象封装进一个抽象对象：这就是方法对象。以一个参数列表调用方法对象时，它被重新拆 封，用实例对象和原始的参数列表构造一个新的参数列表，然后函数对象调用这个新的参数列表。 一般来说，实例变量用于对每一个实例都是唯一的数据，类变量用于类的所有实例共享的属性和方法。 数据属性会覆盖同名的方法属性。 方法可以像引用普通的函数那样引用全局命名。与方法关联的全局作用域是包含类定义的模块(类本身永远不会做为全局作用域使用)。 对于 C++ 程序员来说，Python 中的所有方法本质上都是虚方法 派生类中的覆盖方法可能是想要扩充而不是简单的替代基类中的重名方法。有一个简单的方法可以直接调用基类方法，只要调用：BaseClassName.methodname(self, arguments)。 实用技巧 在Python源文件中可以使用非 ASCII 编码。最好的方法是在 #! 行的后面再增加一行特殊的注释来定义源文件的编码: 1# -*- coding: encoding -*- 迭代器 生成器 格式化输入和输出 文件读写 序列中循环时，索引位置和对应值可以使用enumerate()函数同时得到: 12&gt;&gt;&gt; for i, v in enumerate(['tic', 'tac', 'toe']):... print(i, v) 同时循环两个或更多的序列，可以使用 zip() 整体打包: 1234&gt;&gt;&gt; questions = ['name', 'quest', 'favorite color']&gt;&gt;&gt; answers = ['lancelot', 'the holy grail', 'blue']&gt;&gt;&gt; for q, a in zip(questions, answers):... print 'What is your &#123;0&#125;? It is &#123;1&#125;.'.format(q, a) 需要逆向循环序列的话，先正向定位序列，然后调用 reversed() 函数: 12&gt;&gt;&gt; for i in reversed(xrange(1, 10, 2)):... print(i) sorted() 函数不改动原序列，而是生成一个新的已排序的序列。 遍历字典时，使用 iteritems() 方法可以同时得到键和对应的值： 123&gt;&gt;&gt; knights = &#123;'gallahad': 'the pure', 'robin': 'the brave'&#125;&gt;&gt;&gt; for k, v in knights.iteritems():... print k, v 在循环内部修改正在遍历的序列，应首先制作副本： 123words = ['cat', 'window', 'defenestrate']for w in words[:]: # Loop over a slice copy of the entire list. pass print 用一个逗号结尾就可以禁止输出换行 注意 is 用来判断两个对象是否是同一个对象，== 用来判断两个对象是否相等 编码风格 使用 4 空格缩进，而非 TAB。 在小缩进(可以嵌套更深)和大缩进(更易读)之间，4 空格是一个很好的折中。TAB 引发了一些混乱，最好弃用。 折行以确保其不会超过 79 个字符。 这有助于小显示器用户阅读，也可以让大显示器能并排显示几个代码文件。 使用空行分隔函数和类，以及函数中的大块代码。 可能的话，注释独占一行 使用文档字符串 把空格放到操作符两边，以及逗号后面，但是括号里侧不加空格：a = f(1, 2) + g(3, 4)。 统一函数和类命名。 推荐类名用 驼峰命名，函数和方法名用小写_和_下划线。总是用self作为方法的第一个参数(关于类和方法的知识详见 初识类)。 不要使用花的编码，如果你的代码的目的是要在国际化环境。Python的默认情况下，UTF-8，甚至普通的 ASCII 总是工作的最好。 同样，也不要使用非 ASCII 字符的标识符，除非是不同语种的会阅读或者维护代码。","categories":[{"name":"learning python","slug":"learning-python","permalink":"https://uyouii.github.io/categories/learning-python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://uyouii.github.io/tags/python/"}]},{"title":"Lua Table Parser","slug":"Lua-Table-Parser","date":"2018-01-30T10:03:35.000Z","updated":"2019-08-02T03:28:18.915Z","comments":true,"path":"2018/01/30/Lua-Table-Parser/","link":"","permalink":"https://uyouii.github.io/2018/01/30/Lua-Table-Parser/","excerpt":"","text":"Lua Table Parser 使用说明PyLuaTblParser类中有两个私有变量： self.str_praser是类LuaStrParser的实例，用来实现lua字符串的解析。 self.lua_table是一个dict或者list，用来储存从lua table字符串或者其他dict中读取的数据。 接口1234567891011121314151617181920212223def load(self, s):读取Lua table数据，输入s为一个符合Lua table定义的字符串，无返回值遇到Lua table格式错误则抛出异常def dump(self):根据类中数据返回Lua table字符串def loadLuaTable(self, f):从文件中读取Lua table字符串，f为文件路径，遇到Lua Table的格式错误则抛出异常，文件操作失败抛出异常def dumpLuaTable(self, f):将类中的内容以Lua table格式存入文件，f为文件路径，文件若存在则覆盖，文件操作失败抛出异常def loadDict(self, d):读取dict中的数据，存入类中，只处理数字和字符串两种类型的key，其他类型的key直接忽略def dumpDict(self):返回一个dict，包含类中的数据def update(self, d):用字典d更新类中的数据，类似于字典的updatePyLuaTblParser类支持用[]进行赋值、读写数据的操作，类似字典 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440class LuaStrParser: __spaceChars = [' ', '\\t', '\\n', '\\r'] __stopChars = [' ', '\\t', '\\n', '\\r', '=', ',', ';', '&#125;', ']'] keyTypes = [int, float, str] __specialChars = &#123; 'a': '\\a', 'b': '\\b', 'f': '\\f', 'n': '\\n', 'r': '\\r', 't': '\\t', 'v': '\\v', '\\\\': '\\\\', '\"': '\"', \"'\": \"'\", &#125; __reverseSpecialChars = &#123; '\\a': '\\\\a', '\\b': '\\\\b', '\\f': '\\\\f', '\\n': '\\\\n', '\\r': '\\\\r', '\\t': '\\\\t', '\\v': '\\\\v', '\\\\': '\\\\\\\\', '\"': '\\\\\"', \"'\": \"\\\\'\" &#125; def __init__(self): self.__lua_object = None self.__lua_str = None def __jumpSpace(self, string, loc): while loc &lt; len(string) and string[loc] in self.__spaceChars: loc += 1 return loc def __getBackSlashNum(self, lua_str, loc): backslash_num = 0 while loc &gt;= 0 and lua_str[loc] == '\\\\': loc -= 1 backslash_num += 1 return backslash_num def __getStringEnd(self, lua_str, loc, quote): result = loc + 1 if lua_str[loc] == quote: end = lua_str.find(quote, loc + 1) if end != loc + 1: at_end = False while not at_end: if self.__getBackSlashNum(lua_str, end - 1) % 2 == 0: at_end = True if not at_end: end = lua_str.find(quote, end + 1) if end &lt; 0: raise Exception(\"wrong quotes!\") result = end return result def __getStringConent(self, lua_str, loc): \"\"\" return the string in the @para lua_str thee result contain the quotes\"\"\" loc = self.__jumpSpace(lua_str, loc) result = None if lua_str[loc] == '\"' or lua_str[loc] == \"'\": end = self.__getStringEnd(lua_str, loc, lua_str[loc]) result = lua_str[loc: end + 1] loc = end + 1 return result, loc def __removeComment(self, lua_str): result = \"\" loc = 0 while loc &lt; len(lua_str): # string should be add in result directly if lua_str[loc] == '\"' or lua_str[loc] == \"'\": string, loc = self.__getStringConent(lua_str, loc) result += string # remove comment elif lua_str[loc] == '-': if loc + 1 &lt; len(lua_str) and lua_str[loc + 1] == '-': loc += 2 # multi line comments if loc + 1 &lt; len(lua_str) and lua_str[loc:loc + 2] == '[[': loc = lua_str.find(']]', loc + 1) + 2 # single line comment else: loc = lua_str.find('\\n', loc + 1) + 1 # add a space after remove the comment result += ' ' else: result += lua_str[loc] loc += 1 # remove '\\r' elif lua_str[loc] == '\\r': loc += 1 continue else: result += lua_str[loc] loc += 1 return result def __getRightBrace(self, lua_str, loc): loc = lua_str.find('&#123;', loc) + 1 left_barce_num = 0 while loc &lt; len(lua_str): if lua_str[loc] == '\"' or lua_str[loc] == \"'\": loc = self.__getStringEnd(lua_str, loc, lua_str[loc]) + 1 elif lua_str[loc] == '&#123;': left_barce_num -= 1 loc += 1 elif lua_str[loc] == '&#125;': left_barce_num += 1 if left_barce_num &gt;= 1: break loc += 1 else: loc += 1 if loc == len(lua_str): raise Exception(\"wrong number of brace\") return loc def __getRightBracket(self, lua_str, loc): loc = lua_str.find('[', loc) + 1 while loc &lt; len(lua_str): if lua_str[loc] == '\"' or lua_str[loc] == \"'\": loc = self.__getStringEnd(lua_str, loc, lua_str[loc]) + 1 elif lua_str[loc] == ']': break else: loc += 1 if loc == len(lua_str): raise Exception(\"wrong number of bracket\") return loc def __getLastBrace(self, lua_str): end = len(lua_str) - 1 while end &gt;= 0 and lua_str[end] != '&#125;': end -= 1 if end &lt; 0: raise Exception(\"wrong number of brace\") return end def __readNum(self, number_str): try: num = eval(number_str) except Exception: return None else: return num def __getRealStr(self, s): result = \"\" i = 0 while i &lt; len(s): if s[i] == '\\\\': if i + 1 &lt; len(s) and s[i + 1] in self.__specialChars.keys(): result += self.__specialChars[s[i+1]] i += 2 else: result += s[i] i += 1 else: result += s[i] i += 1 # print s, \"&gt;&gt;\" , result return result def __readValue(self, value): value = value.strip() if len(value) &gt; 0: if value[0] == '\"' or value[0] == \"'\": return self.__getRealStr(value[1:len(value) - 1]), str elif value == 'nil': return None, \"nil\" elif value == 'false': return False, bool elif value == 'true': return True, bool else: number = self.__readNum(value) if isinstance(number, int): return number, int elif isinstance(number, float): return number, float else: return None, None return value, str def __readStatement(self, lua_str, loc): loc = self.__jumpSpace(lua_str, loc) if lua_str[loc] == '&#123;': end = self.__getRightBrace(lua_str, loc) stat = self.__parserLuaStr(lua_str[loc: end + 1]) stat_type = type(stat) loc = end + 1 elif lua_str[loc] == '[': end = self.__getRightBracket(lua_str, loc) stat, stat_type = self.__readValue(lua_str[loc + 1: end]) loc = end + 1 elif lua_str[loc] == '\"' or lua_str[loc] == \"'\": end = self.__getStringEnd(lua_str, loc, lua_str[loc]) stat = lua_str[loc + 1: end] stat = self.__getRealStr(stat) stat_type = str loc = end + 1 else: end = loc while end &lt; len(lua_str) and lua_str[end] not in self.__stopChars: end += 1 stat, stat_type = self.__readValue(lua_str[loc: end]) loc = end return stat, stat_type, loc def __parserLuaStr(self, lua_str): loc = lua_str.find('&#123;') + 1 end = self.__getLastBrace(lua_str) has_equal = False keys = [] values = [] while 0 &lt;= loc &lt; end: key, key_type, loc = self.__readStatement(lua_str, loc) value, value_type = None, None has_value = False loc = self.__jumpSpace(lua_str, loc) if lua_str[loc] == '=': has_value = has_equal = True loc += 1 value, value_type, loc = self.__readStatement(lua_str, loc) loc = self.__jumpSpace(lua_str, loc) loc += 1 if has_value: if key is not None: keys.append((key, key_type)) values.append((value, value_type)) else: raise Exception(\"the key is nil\") else: keys.append((key, key_type)) values.append((None, None)) number = 1 if has_equal: result = &#123;&#125; for key_tuple, value_tuple in zip(keys, values): if value_tuple[1] is not None: result[key_tuple[0]] = value_tuple[0] else: if key_tuple[1] != 'nil' and key_tuple[0] is not None: result[number] = key_tuple[0] number += 1 result = &#123;k: v for k, v in result.iteritems() if v is not None&#125; else: result = [] for key_tuple in keys: if key_tuple[1] is not None: result.append(key_tuple[0]) return result def readStr(self, lua_str): lua_str = self.__removeComment(lua_str.strip()) self.__lua_object = self.__parserLuaStr(lua_str) def getLuaObject(self): return self.__lua_object def __generateKeyStr(self, lua_object): result = \"\" if lua_object is not None: if type(lua_object) is str: result = '[\"' + self.__getOriginStr(lua_object) + '\"]' elif type(lua_object) is int or type(lua_object) is float: result = '[' + str(lua_object) + ']' elif type(lua_object) is bool: if lua_object: result = '[true]' else: result = '[false]' else: raise Exception(\"Wrong type of key: \" + str(lua_object)) return result def __getOriginStr(self, s): result = \"\" for c in s: if c in self.__reverseSpecialChars.keys(): result += self.__reverseSpecialChars[c] else: result += c return result def __generateValueStr(self, lua_object): result = \"\" object_type = type(lua_object) if lua_object is None: result = 'nil' elif object_type is list or object_type is dict: result = self.generateLuaStr(lua_object) elif object_type is str: result = '\"' + self.__getOriginStr(lua_object) + '\"' elif object_type is int or object_type is float: result = str(lua_object) elif object_type is bool: if lua_object: result = 'true' else: result = 'false' return result def generateLuaStr(self, lua_object): result = \"\" if lua_object is not None: result += '&#123;' if type(lua_object) is dict: for key, value in lua_object.iteritems(): result += self.__generateKeyStr(key) + ' = ' + self.__generateValueStr(value) + ', ' elif type(lua_object) is list: for value in lua_object: result += self.__generateValueStr(value) + ', ' result += '&#125;' self.__lua_str = result return resultclass PyLuaTblParser: def __init__(self): self.str_praser = LuaStrParser() self.lua_table = None def load(self, s): self.str_praser.readStr(s) self.lua_table = self.str_praser.getLuaObject() def dump(self): return self.str_praser.generateLuaStr(self.lua_table) def loadLuaTable(self, f): with open(f, 'r') as lua_str_file: lua_str = lua_str_file.read() self.load(lua_str) def dumpLuaTable(self, f): with open(f, 'w') as out_file: out_file.write(self.str_praser.generateLuaStr(self.lua_table)) def deleteOtherKey(self, d): result = None if type(d) is dict: result = &#123;&#125; for key, value in d.iteritems(): if type(key) in LuaStrParser.keyTypes: if type(value) is list or type(value) is dict: result[key] = self.deleteOtherKey(value) else: result[key] = value elif type(d) is list: result = [] for value in d: if type(value) is list or type(value) is dict: result.append(self.deleteOtherKey(value)) else: result.append(value) return result def loadDict(self, d): if type(d) is dict: self.lua_table = self.deleteOtherKey(d) def dumpDict(self): if type(self.lua_table) is dict: return self.lua_table.copy() elif type(self.lua_table) is list: return [v for v in self.lua_table] def update(self, d): if self.lua_table is None: self.lua_table = d else: if type(self.lua_table) is list: new_table = &#123;&#125; for k, v in zip(range(1, len(self.lua_table) + 1), self.lua_table): if v is not None: new_table[k] = v self.lua_table = new_table new_table = self.deleteOtherKey(d) for k, v in new_table.iteritems(): self.lua_table[k] = v def __getitem__(self, item): try: return self.lua_table[item] except: return None def __setitem__(self, key, value): if self.lua_table is None: self.lua_table = &#123;&#125; self.lua_table[key] = value elif type(self.lua_table) is dict: self.lua_table[key] = value elif type(self.lua_table) is list: new_table = &#123;&#125; for k, v in zip(range(1,len(self.lua_table) + 1), self.lua_table): if v is not None: new_table[k] = v new_table[key] = value self.lua_table = new_tableif __name__ == '__main__': pyluatblparser = PyLuaTblParser() pyluatblparser.load('&#123;&#123;&#125;,nil,nil,2,3&#125;') pyluatblparser[1] = 1 print pyluatblparser[1] print pyluatblparser.dump() pyluatblparser[1] = &#123;&#125; print pyluatblparser.dump() # print repr(lua_str) # print str_parser.__removeComment(lua_str) # with open('sysinput2', 'r') as f: # lua_str = f.read() # pyluatblparser.load(lua_str) # outDict = pyluatblparser.dumpDict() # print outDict # result = outDict['root'][7] # print result[\"\\\\\\\"\\b\\f\\n\\r\\t`1~!@#$%^&amp;*()_+-=[]&#123;&#125;|;:',./&lt;&gt;?\"] # # print '\\n' # print pyluatblparser.dump() # # print result # # next = None # # for key,value in result.iteritems(): # # for k, v in value.iteritems(): # # if k == 7: # # next = v # # # # for k,v in next.iteritems(): # # print k ,'=', v # # print '\\n' # # pyluatblparser.dumpLuaTable('output') # # # with open('output', 'w') as out: # # new_str = pyluatblparser.dump() # # print new_str # # out.write(new_str) # # with open('output.lua', 'w') as out: # # out.write(result) 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960if __name__ == '__main__': # test multi table levels a1 = PyLuaTblParser() test_str = '&#123;array = &#123;65,23,5,&#125;,dict = &#123;mixed = &#123;43,54.33,false,9,string = \"value\",&#125;,array = &#123;3,6,4,&#125;,string = \"value\",&#125;,&#125;' a1.load(test_str) d1 = a1.dumpDict() print '&gt;&gt;&gt;&gt;&gt;', d1 print '===========================================================' # test file load a2 = PyLuaTblParser() a2.loadDict(d1) a2.dumpLuaTable('test_output') # test file dump a3 = PyLuaTblParser() a3.loadLuaTable('test_input') d3 = a3.dumpDict() print '&gt;&gt;&gt;&gt;&gt;', d3 print '===========================================================' # test complex string test_str = '&#123; strs = \"\\\\\"\\'\\\\\" \\\\t\\\\b\\\\f\\\\n\", [\"\\\\\"\\'\\\\\" \\\\t\\\\b\\\\f\\\\n\"] = \"complex string is key\"&#125;' print test_str a4 = PyLuaTblParser() a4.load(test_str) d4 = a4.dumpDict() print '&gt;&gt;&gt;&gt;&gt;', d4 print '===========================================================' # test comment test_str = '&#123;\\t\\n-- \"comment str\",\\t\\n[\"hello world\"] = 1,\\t\\n--[[\\t\\n\"should be comment\",\\t\\n2 = 1\\t\\n ]]\\t\\n[3] = 2\\n&#125;' print test_str a5 = PyLuaTblParser() a5.load(test_str) d5 = a5.dumpDict() print '&gt;&gt;&gt;&gt;&gt;', d5 print '===========================================================' # test [] test_str = '&#123;[1] = \"1\", a = \"a\"&#125;' print test_str a6 = PyLuaTblParser() a6.load(test_str) print '&gt;&gt;&gt;&gt;&gt;', a6.dump() a6[1] = \"changed\" print '&gt;&gt;&gt;&gt;&gt;', a6[1] print '&gt;&gt;&gt;&gt;&gt;&gt;', a6.dump() print '===========================================================' # test update test_str = '&#123;[1] = \"1\", a = \"a\"&#125;' print test_str a7 = PyLuaTblParser() a7.load(test_str) print '&gt;&gt;&gt;&gt;&gt;', a7.dump() update_table = &#123;1: [&#123;&#125;], \"b\": \"b\"&#125; a7.update(update_table) print '&gt;&gt;&gt;&gt;&gt;', a7.dump() 测试样例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&#123; root = &#123; \"Test Pattern String\", -- &#123;\"object with 1 member\" = &#123;\"array with 1 element\",&#125;,&#125;, &#123;[\"object with 1 member\"] = &#123;\"array with 1 element\",&#125;,&#125;, &#123;&#125;, [99] = -42, [98] = &#123;&#123;&#125;&#125;, [97] = &#123;&#123;&#125;,&#123;&#125;&#125;, [96] = &#123;&#123;&#125;, 1, 2, nil&#125;, [95] = &#123;1, 2, &#123;[\"1\"] = 1&#125;&#125;, [94] = &#123; &#123;[\"1\"]=1, [\"2\"]=2&#125;, &#123;1, [\"2\"]=2&#125;, [\"3\"] = 3 &#125;, true, false, nil, &#123; [\"integer\"]= 1234567890, real=-9876.543210, e= 0.123456789e-12, E= 1.234567890E+34, zero = 0, one = 1, space = \" \", quote = \"\\\"\", backslash = \"\\\\\", controls = \"\\b\\f\\n\\r\\t\", slash = \"/ &amp; \\\\\", alpha= \"abcdefghijklmnopqrstuvwyz\", ALPHA = \"ABCDEFGHIJKLMNOPQRSTUVWYZ\", digit = \"0123456789\", special = \"`1~!@#$%^&amp;*()_+-=&#123;':[,]&#125;|;.&lt;/&gt;?\", hex = \"0x01230x45670x89AB0xCDEF0xabcd0xef4A\", [\"true\"] = true, [\"false\"] = false, [\"nil\"] = nil, array = &#123;nil, nil,&#125;, object = &#123; &#125;, address = \"50 St. James Street\", url = \"http://www.JSON.org/\", comment = \"// /* &lt;!-- --\", [\"# -- --&gt; */\"] = \" \", [\" s p a c e d \" ] = &#123;1,2 , 3 , 4 , 5 , 6 ,7 &#125;, --[[[][][] Test multi-line comments compact = &#123;1,2,3,4,5,6,7&#125;, - -[luatext = \"&#123;\\\"object with 1 member\\\" = &#123;\\\"array with 1 element\\\"&#125;&#125;\", quotes = \"&amp;#34; (0x0022) %22 0x22 034 &amp;#x22;\", [\"\\\\\\\"\\b\\f\\n\\r\\t`1~!@#$%^&amp;*()_+-=[]&#123;&#125;|;:',./&lt;&gt;?\"] = \"A key can be any string\"]] -- ]] compact = &#123;1,2,3,4,5,6,7&#125;, luatext = \"&#123;\\\"object with 1 member\\\" = &#123;\\\"array with 1 element\\\"&#125;&#125;\", quotes = \"&amp;#34; (0x0022) %22 0x22 034 &amp;#x22;\", [\"\\\\\\\"\\b\\f\\n\\r\\t`1~!@#$%^&amp;*()_+-=[]&#123;&#125;|;:',./&lt;&gt;?\"] = \"A key can be any string\" &#125;, 0.5 ,31415926535897932384626433832795028841971693993751058209749445923. , 3.1415926535897932384626433832795028841971693993751058209749445923 , 1066 ,\"rosebud\" &#125;&#125;","categories":[{"name":"python","slug":"python","permalink":"https://uyouii.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://uyouii.github.io/tags/python/"},{"name":"lua","slug":"lua","permalink":"https://uyouii.github.io/tags/lua/"}]},{"title":"合金装备V 幻痛 游戏评测","slug":"合金装备V-幻痛-游戏测评","date":"2017-12-21T15:35:35.000Z","updated":"2019-08-02T03:28:18.918Z","comments":true,"path":"2017/12/21/合金装备V-幻痛-游戏测评/","link":"","permalink":"https://uyouii.github.io/2017/12/21/合金装备V-幻痛-游戏测评/","excerpt":"","text":"游戏概述《合金装备V 幻痛》(Metal Gear Solid V: The Phantom Pain, 台译作“潜龙谍影V 幻痛”) 是一款由小岛制作（KONAMI旗下的王牌游戏研发工作室）开发的隐蔽类开放世界动作冒险游戏。它由小岛制作研发的游戏引擎“狐引擎”（FOX Engine）制作，在2015年9月1日发行于Microsoft Windows、PlayStation 3、PlayStation 4、Xbox 360和Xbox One平台。 游戏起初被分别公布为2个不同的项目，一个是在合金装备25周年纪念会上公布，名为《合金装备 原爆点》（Metal Gear Solid : Ground Zeroes），另一个则是由Moby Dick Studio开发的《幻痛》（Phantom Pain）。至2013年3月游戏网页正式上线，游戏名称才确定为《合金装备V 幻痛》。2013年11月11日，科乐美宣布《合金装备V 原爆点》独立于2014年春季发行。2014年德国Gamescom展，小岛秀夫宣布《幻痛》将借由Steam登上电脑平台。 游戏背景游戏设定在一个架空的冷战世界中，除了对峙的美国和苏联外，世界的格局还被一种名为“合金装备”的武器影响着。游戏的时间设定在《合金装备V 原爆点》九年之后，即1984年，此时游戏中和现实一样也在进行着阿富汗战争。尽管游戏大体和现实相同，但是玩家可以发现游戏内的武器和科技要远远比现实中的冷战时期先进，军事技术诸如外骨骼、双足机甲、光学隐形、全息影像都被各国谍报机关所使用着。其他科学技术诸如纳米技术、克隆、人工智能也进入了实用化的阶段。 主角Big Boss建立的佣兵组织“无界之师”在《合金装备V 原爆点》的结尾被摧毁，主角也陷入了长达9年的昏迷。醒来后世界也发生了翻天覆地的变化。《合金装备V 幻痛》讲述的是主角在苏醒后重新建立佣兵组织“Diamond Dogs”，并在“Snake”的代号下，在阿富汗和安哥拉-扎伊尔边境进行冒险，以向九年前摧毁自己亲手建立的无国界军队MSF的神秘人物”Skull Face”复仇。 配置要求 项目 最低配置 推荐配置 系统 Windows 7 Windows 7 处理器 i5-4460 i7-4790 内存 4GB RAM 8GB RAM 显卡 GeForce GTX 650或更好 GeForce GTX 760或更好 硬盘 28GB空闲空间 28GB空闲空间 资料来源：游民星空 游戏评测1. 游戏场景 9.0合金装备V是开放世界类的潜入冒险游戏。游戏中总共有两个比较大的开放式的地图，分别在中东地区的阿富汗和非洲地区，游戏的情节和任务也都在这两个地图中展开。 可以说合金装备5幻痛的游戏画面是日式游戏中少见的优质画面，几乎所有玩家在进入游戏之后都会在几分钟内被游戏所折服，可以说是真正的划时代之作。在画面的重大突破很大程度上得益于FOX引擎。2008年Kojima开发FOX引擎绝对是个目光长远之举，人们当时还没有意识到游戏画面可以进化到今天这个地步，但当时的“FOX引擎”团队致力于打造世界上最好的游戏引擎，也就是这个好高骛远的目标如今终于为日式游戏正名。 游戏中的场景可谓多种多样，甚至不做任务在游戏中闲逛也是一种乐趣。幻痛对游戏环境场景做了生动的还原。在游戏中你会发现各种植物和动物，有时还会遇到瀑布、峡谷、沼泽等等。游戏中会标出有用的药草和资源等等，收集药草可以用来制作药品和装备，甚至可以在基地出售换取游戏中的金币，进而开发装备。 游戏中的动物可以被主角用麻醉枪麻醉后送往基地（传送或虫洞技术）。游戏中有一个动物保护组织承诺主角收集动物后可以给予主角相应的声望和金币。甚至有个支线任务要求主角前往指定区域抓捕棕熊。 游戏中同样添加了气候和自然时间的设定。笔者总共体验过晴天、阴天、雨天和沙尘暴这几种气候。对于潜入型的游戏来说，这个设定更增添了游戏的趣味性。白天和黑夜会影响NPC的巡逻线路和视野，雨天可以很好的掩盖主角的脚步声，沙尘暴更是无压力潜入（偶尔会撞在敌人脸上…）。 地图上会散布着很多岗哨和敌人的大型据点，兵力和设备也会有所不同。随着游戏的推进，驻守的兵力也会不断增多，而且会根据玩家的入侵习惯不断调整，这是游戏一个特别新颖的地方。比如玩家入侵时喜欢爆头，则NPC会装配头盔、玩家喜欢在夜晚时入侵，敌人则会装备夜视仪等。敌人也会因为玩家的方式来采取不同的措施，他们会组队调查可以的地方对玩家进行包围，必要的时候会采用重武器对玩家进行压制（不止一次被榴弹炮和武装直升机干掉= =）。 幻痛的游戏环境是对现实的高度还原，人物的视觉和感官也做的十分逼真，使人们在玩游戏是的代入感十分强烈。唯一不足是游戏中的时间流逝设定比现实中快了不少，往往潜入敌方基地后还没完成任务天就亮了。俘虏敌人的回答和选项方面的设定也比较单一，希望增强游戏中NPC的多样性，更能增添游戏的趣味性。 2. 游戏玩法 9.5开放世界对于潜入游戏的核心玩法的改变可以说是革命性的，可以说完成游戏的方式完全取决于玩家自身，这款游戏基本没有固定的模式。潜入只是暗示玩家游戏的风格，但玩家完全可以按照自己的路线来完成。当然游戏推荐潜入的玩法确实具有挑战性，也更加考验玩家的耐心。 潜入时玩家可以选择晚上或者暴雨天气，之前先用望远镜标记好敌人的位置，为潜入工作打下基础。枪械方面也可以选择带消音管或者麻醉枪。因为这个游戏中玩家有一个自己的基地，俘虏敌人并传送回基地可以加强基地的建设工作，促进武器的研发和资源的收集。具有特殊技能的NPC也会带来意想不到的好处。例如当你回收一名具有翻译技能的人员后你就能够听懂敌人交流的语言了。 在不惊动其他敌人的情况下俘虏敌人也可以获得一些关键性的情报，例如指挥所的位置，蓝图的地点，钻石的地点，具有特殊技能的人员（专家）是哪些等。在进行主线任务时，通过审问敌人可以得到完成主线任务的线索。这些设定都增加了游戏的趣味性和挑战性。 当然对于没有耐心的玩家这些都是虚的，正面刚才是王道呀。背着火箭炮，空投坦克，穿着重型装甲就可以攻占下来一个基地了，任务什么的在进去探索就行了。这样魂斗罗式的玩法也别有一番趣味。 游戏中NPC使用的任何车辆和武器玩家都可以使用，包括榴弹炮，火箭发射车等，不过在坦克中如果被敌人集火攻击的话也很容易被干掉。 3. 游戏装备和资源 9.0第三人称射击类的游戏怎么会少了武器枪械。合金装备V 中的枪械种类可以说是花样繁多，不管是现实中存在的或者是改版的都有在游戏中体现出来。 武器的研发是在玩家的基地中实现的。玩家通过不断升级研发平台可以不断解锁新的武器装备。研发平台的升级需要人员扩中和基地基础设施研发来完成，部分武器还需要武器蓝图和专业人员存在才可以解锁。 武器的研发是按照树状图的方式进行的，即一类武器只有将其之前的武器解锁后，才可以继续研发更加先进的武器。 玩家在游戏中可以选择各种不同的枪械，不同的武器也拥有不同的功能。玩家在进行任务时，不仅可以呼叫直升机空投武器资源，还可以空投之前回收的武器车辆等，例如双足机器人和坦克。 玩家在执行任务时回收的资源很多会运回基地用于基地基础设施的开发和武器的研究。 玩家可以随时回到基地，有时会触发一些剧情。在基地中有些地方会出现一些试炼任务，完成后会给玩家提供大量的游戏金币。在基地中闲逛的时候偶尔会发现一些钻石碎片，同样可以兑换大量的GMP（游戏金币）。小岛的幽默依然不减，基地中偶尔也会出现一些日式风格的海报，收集后同样可以兑换一下GMP。 在基地的建设中，人员素质占了很大一部分比重。基地人员的能力与基地的研发等级相挂钩。主角的声望越高，越容易招募到高素质的成员。同时玩家在执行任务时对高素质人员的回收也很重要。这同时也暗示了玩家幻痛不仅仅是一个枪战游戏，更重要的是策略和思维。 游戏中黑科技依然不少，寄生虫，人体改造，基因技术，机械手臂，双足机器等。一些超自然的设定和剧情也为游戏增添的不少魔幻主义色彩，很多时候玩家在进行游戏的时候都会有一种惊心动魄的感觉，有些NPC是真的太恐怖了！ 4 游戏剧情 9.9合金装备V 幻痛剧情只是整个合金装备游戏系列的一个中间阶段，它讲述的是Snake在基地被摧毁，经历了长达9年的昏迷之后，在山猫和米勒的帮助下，投身于阿富汗战场，并重新建立佣兵组织钻石狗的故事。这些剧情和往届合金装备游戏的剧情都属于同一种风格，但是不同的是，幻痛中竟然出现了女主！这个设定真的是让不少玩家去趋之若鹜呀，真的是一直在刷妹子的好感度。什么主线剧情的先不管了，最终主角是把大反派“Skull Face”消灭了，我们还是围绕静静来介绍。 女主的名字叫做“Quiet”，顾名思义，意思是女主从来都不说话，至于原因我们会在后面揭晓。 玩家在进行到第11次主线任务时，会触发一次隐藏剧情，在阿富汗某地区会遇到一名强大的女狙击手。不仅身法快捷，而且还会隐身伪装的能力，狙击能力也特别强。这时候玩家就要想办法战胜这位女狙击手。当任务完成后，基地一个NPC会要求玩家杀掉Quiet，认为他是“Skull Face”的人，而另一个NPC则认为可以俘虏Quiet到基地来观察一段时间。这时候玩家就可以选择是否要杀掉Quiet。我觉得正常的玩家肯定会把Quiet带回基地啊！这么漂亮的女主。 游戏的第一个任务是要让昏迷了9年的主角逃出医院。当主角还在医院中的时候，“Skull Face”曾派遣了一位女特工来刺杀主角，结果被主角和一位NPC联手烧伤后不知所踪。细心的玩家会发现者刺杀主角的女特工和静静其实是同一个，由此可以推断Quiet是来复仇的。 当Quiet来到基地以后，基地的NPC发现他们根本控制不住Quiet（根本打不过），Quiet也从不说话，但是只听主角一个人的指挥，Quiet就只能暂时被关押起来。后来一次机缘巧合基地的NPC同意主角带上Quiet一起执行任务。这时玩家会发现Quiet来了以后，执行任务的速度简直事半功倍呀，有时Quiet自己就可以团灭一个敌方基地。 后来主角建立的基地会面临一种灾难，就是不断有成员得一种怪病死去，原因要主角自己调查。在见到密语者（NPC）之后得知这场疾病是由于声带寄生虫引起的。声带寄生虫是指一种寄生到人的声带，根据人的语言种类来进行繁殖的一种寄生虫。只会感染说某种特定语言的群体并繁殖，感染到基本无药可救，而且传染性极强。声带寄生虫是“Skull Face”从密语者哪里获得后拿来进行人体改造实验。静静的特殊能力、以及“Skull Face”身边的一些NPC都是寄生虫改造的产物，因此具有了异于常人的能力。 Quiet和主角的关系也在一次次的任务中不断升温，Quiet和boss这雨中嬉戏的这个画面相信让很多玩家难以忘怀，本以为主角和Quiet最后能走在一次，可是忘了编剧喜欢悲剧的这个事实（寄过刀片了有没有）。 游戏的第30个主线任务完成后，也就是主角终于将最终Boss“Skull Face”杀掉后，会说明一个关键信息。“Skull Face”共制造了三支英语种的寄生虫，可是现在只剩下两支……相信细心的读者已经明白了剩下的一支到哪里去了，但是笔者没想到结果会来的这么突然。 在任务推进到一定程度，会出现隐藏的45号主线任务。任务会提示静静突然消失了，然后主角得知静静被苏联人抓走了，笔者当时第一反应当然是干翻他们找到静静啊！说实话这个关卡挺难的。 关卡任务是玩家要和静静一起摧毁掉苏联军队的一个坦克部队。当玩家摧毁所有地图上的敌军后，会进入下一段剧情。主角以为所有坦克都被摧毁，但一辆没有完全摧毁的坦克已经悄悄瞄准了主角。静静因为不能说话，一把抢过主角的火箭炮摧毁了坦克，但是也被炮弹击中，陷入昏迷，也就在这时，敌军的增援部队赶到，主角要带着静静从这个绝望之地逃出。 主角和静静躲在了一处岩石后，敌人的搜查部队就在眼前，由于沙尘暴的原因主角和静静躲过了一劫，但主角却因此被眼镜蛇咬伤，而后同样陷入昏迷（眼镜蛇是神经性毒素，可以致命）。主角后来在半睡半醒中听到救援直升机赶到，但因为沙尘暴找不到正确的方位。当救援直升机得不到应答，正要返回的时候，静静说出了英语。相信大家都猜到了，静静是英语语种的寄生虫携带者，所以她从不说话。之前“Skull Face”派遣她来就是为了感染主角，但是她没有这样做。在最后时刻她为了救主角却牺牲了自己。静静在直升机到来后，看了主角最后一眼，然后离开。 主角得到救援后发现静静不在，但跟着脚印在一处山顶上发现了静静留下的一个录音磁带。里面说：1234567891011I did not choose to be Quiet.I wanted to express my feelings to you.If only we shared a common tongue.Vengeance was what drove me to them...The only language left to me, revenge.But the words we shared...No, that was no language at all.That&apos;s why I...I chose the language of gratitude instead, and go back to silence.I am Quiet...I am... The absence of words... 从此静静便淡出了玩家的视野，但是回到基地后会发现静静已经列入了基地的死亡名单，直升机上静静的相片也不见了，再也不会有静静的身影了…… 当笔者玩到这里的时候真的是非常的虐心，但是毕竟程序员们的智慧是无限的，虽然网友通过替换文件的方法可以重新找回静静，但是再也没有和静静有关的任务了。 游戏剧情的设计让玩家们如此着迷，甚至主线任务通关后仍然想要找回女主的身影，更让无数玩家尝试各种方法寻回静静，真心满分。 在静静淡出后，游戏的最终关卡也出现了。玩家们发现这个最终关卡和第一关基本一样，但是却揭示了和第一关完全不同的结局。原来玩家操控的主角一直都不是真正的Big Boss，而是Big Boss的一个替身，这个秘密只有将主角救出的山猫一个人知道。真正的Big Boss已经去了其他地方开辟新的基地。游戏开始会让玩家自定义自己的外貌属性，但是在第一关却没有体现出来，直到现在自定义的外貌的选项才出现。原来这个游戏本身就是一场幻痛…… 笔者个人觉得，游戏的画面感和操作倒是其次，游戏的剧情才是游戏真正的灵魂。一个没有剧情的游戏很容易让人感到无聊，但是游戏的剧情却可以让人回味无穷。 5. 游戏音效 9.0游戏的音效方面的效果也是很棒的，游戏中的所有的音效都是立体音，玩家在游戏中的时候，无论是风声，鸟叫声或者是流水的声音都非常的真实，仿佛真的置身于野外一样。在执行任务的时候，敌人的交谈声和脚步声也是非常重要的信息。 游戏中也穿插了大量的70、80年代的大量的经典的歌曲。在执行任务的过程中，玩家可以在敌人的据点或者基地中可以发现一些录音机，从而获得一些磁带，来解锁一些游戏中的经典的歌曲。 这些歌曲玩家可以在任务栏的磁带中收听。在基地中的女主的房间中，玩家可以听到收集来的磁带中的歌曲。女主的房间中有彩蛋的哦。在女主的房间中偶尔可以看到女主在洗澡哦！ 6. 综合评价 9.5很多人对《合金装备V 幻痛》的评价颇高，在笔者看来，有两个主要的原因： 游戏具有超高的自由度。玩家不会再被任务限制在一个狭小的空间内，相反是在两个巨大的沙盒式的世界中。 游戏有着行云流水般的剧情体验，而不是生硬的强迫性的过场。 这两个体验往往不会兼得，重视了一项，就会影响另一项。《合金装备V 幻痛》做到了二者的水乳交融，可以说是行业的顶尖的神作。 游戏具有意义的复杂性、灵活的潜入选择、海量的道具和能力也带给了玩家更加丰富的游戏体验，不可不玩的游戏之一。 媒体评价IGN —— 10/10 “《合金装备5：幻痛》是一款拥有奇迹般的游戏玩法、需要玩家动用自己的创造力和智力的游戏——没有多少游戏可以做成这样。” Gamespot —— 10/10 “每一个粉丝都会有自己喜爱的《合金装备》作品，可能在这方面玩家没有统一的意见。但是《合金装备5：幻痛》的出现解决了这个问题。《合金装备》系列中没有哪一部作品会如此有深度，会有如此丰富的游戏内容。游戏中的开放世界令整体素质更上一个台阶。《幻痛》无疑是合金装备系列中最好的作品。” Daily Dot 5/5 “小岛很机智，他将故事讲的很含蓄。玩家只有在事后才会意识到，原来之前的每件叙事都是有一些深刻的含义的。” Game Informer 9.25/10 “一个游戏系列如果没有进化将很难长久的生存下去，《合金装备5：幻痛》就是一个勇于冒险的证明。一个开放世界，一个可自定义的基地，一个多变的任务体系——这些都不曾是传统《合金装备》系列中的元素，但正是这些令《幻痛》如此出色。”","categories":[{"name":"game","slug":"game","permalink":"https://uyouii.github.io/categories/game/"}],"tags":[{"name":"game","slug":"game","permalink":"https://uyouii.github.io/tags/game/"},{"name":"interview","slug":"interview","permalink":"https://uyouii.github.io/tags/interview/"}]},{"title":"KCP 源码阅读","slug":"KCP-源码阅读","date":"2017-12-21T14:01:04.000Z","updated":"2019-08-02T03:28:18.913Z","comments":true,"path":"2017/12/21/KCP-源码阅读/","link":"","permalink":"https://uyouii.github.io/2017/12/21/KCP-源码阅读/","excerpt":"","text":"KCP项目地址： KCP - A Fast and Reliable ARQ Protocol 版权声明：本文为博主原创文章，转载请注明出处。 作者: Uyouii 简介KCP是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，以 callback的方式提供给 KCP。 连时钟都需要外部传递进来，内部不会有任何一次系统调用。 主要数据结构IKCPSEGIKCPSEG是kcp的数据段结构，即储存需要发送的packet的内容。1234567891011121314151617struct IKCPSEG&#123; struct IQUEUEHEAD node; // 双向链表定义的队列 IUINT32 conv; // conversation, 会话序号: 接收到的数据包与发送的一致才接收此数据包 IUINT32 cmd; // command, 指令类型: 代表这个Segment的类型 IUINT32 frg; // fragment, 分段序号 IUINT32 wnd; // window, 窗口大小 IUINT32 ts; // timestamp, 发送的时间戳 IUINT32 sn; // sequence number, segment序号 IUINT32 una; // unacknowledged, 当前未收到的序号: 即代表这个序号之前的包均收到 IUINT32 len; // length, 数据长度 IUINT32 resendts; // 重发的时间戳 IUINT32 rto; // 超时重传的时间间隔 IUINT32 fastack; // ack跳过的次数，用于快速重传 IUINT32 xmit; // 发送的次数(即重传的次数) char data[1];&#125;; IKCPCBIKCPCB是kcp的控制块，用于控制packet的发送，接收，重传等操作。 buffer的发送和接收均调用外部传入的函数。IKCPCB只负责处理算法层面的逻辑。 12345678910111213141516171819202122232425262728293031323334353637struct IKCPCB&#123; //conv:会话ID，mtu:最大传输单元，mss:最大分片大小，state:连接状态 IUINT32 conv, mtu, mss, state; //sun_una：第一个未确认的包，sen_nxt：待发送包的序号，rcv_nxt：待接收消息的序号 IUINT32 snd_una, snd_nxt, rcv_nxt; //ssthresh:拥塞窗口的阈值 IUINT32 ts_recent, ts_lastack, ssthresh; //rx_rttval：ack接收rtt浮动值，rx_srtt：ack接收rtt平滑值(smoothed)，rx_rto：由ack接收延迟计算出来的复原时间，rx_minrto：最小复原时间 IINT32 rx_rttval, rx_srtt, rx_rto, rx_minrto; //sen_wnd：发送窗口大小，rcv_wnd：接收窗口大小，rmt_wnd：远端接收窗口大小，cwnd：拥塞窗口大小，probe 探查变量，IKCP_ASK_TELL表示告知远端窗口大小。IKCP_ASK_SEND表示请求远端告知窗口大小。 IUINT32 snd_wnd, rcv_wnd, rmt_wnd, cwnd, probe; //currunt：当前的时间戳，interval：内部flush刷新间隔，ts_flush：下次flush刷新时间戳 IUINT32 current, interval, ts_flush, xmit; IUINT32 nrcv_buf, nsnd_buf; IUINT32 nrcv_que, nsnd_que; //nodelay：是否启动无延迟模式，update：是否调用过update函数的标识(kcp需要上层通过不断的ikcp_update和ikcp_check来驱动kcp的收发过程) IUINT32 nodelay, updated; //ts_probe：下次探查窗口的时间戳，probe_wait：探查窗口需要等待的时间 IUINT32 ts_probe, probe_wait; //dead_link：最大重传次数，incr：可发送的最大数据量 IUINT32 dead_link, incr; struct IQUEUEHEAD snd_queue; //发送消息的队列 struct IQUEUEHEAD rcv_queue; //接收消息的队列 struct IQUEUEHEAD snd_buf; //发送消息的缓存 struct IQUEUEHEAD rcv_buf; //接收消息的缓存 IUINT32 *acklist; //待发送的ack的列表 IUINT32 ackcount; //ack数量 IUINT32 ackblock; //acklist的大小 void *user; char *buffer; //储存消息字节流的内存 int fastresend; //触发快速重传的重复ack个数 int nocwnd, stream; //nocwnd：取消拥塞控制，stream：是否采用流传输模式 int logmask; int (*output)(const char *buf, int len, struct IKCPCB *kcp, void *user); //发送消息的回调函数 void (*writelog)(const char *log, struct IKCPCB *kcp, void *user);&#125;; KCP网络包头结构123456789101112131415|&lt;------------ 4 bytes ------------&gt;|+--------+--------+--------+--------+| conv | conv：Conversation, 会话序号，用于标识收发数据包是否一致+--------+--------+--------+--------+ cmd: command，用于标识指令，例如：push，ack等| cmd | frg | wnd | frg: Fragment, 分段序号，序号从大到小+--------+--------+--------+--------+ wnd: 接收窗口大小| ts | ts: 发送的时间戳+--------+--------+--------+--------+| sn | sn: Segment序号+--------+--------+--------+--------+| una | una: Unacknowledged, 当前未收到的序号，即代表这个序号之前的包均收到+--------+--------+--------+--------+ | len | len: data数据的长度+--------+--------+--------+--------+ kcp包头总共占用了24个字节。给sn分配了4个字节，可以不用考虑序号越界的问题。 KCP工作流程发送数据kcp首先将要发送的数据存到kcp-&gt;buffer中，如果需要发送的数据总量的大小大于kcp-&gt;mtu，则将buffer中的数据调用output函数发送出去，output函数由用户传入。 kcp数据包发送顺序： IKCP_CMD_ACK(ack) IKCP_CMD_WASK(请求远程窗口大小) IKCP_CMD_WINS(发送本地窗口大小) IKCP_CMD_PUSH(push data) 在发送PUSH类型的数据时，首先需要将数据从sen_que移动到sen_buf中（在移动时会检测拥塞窗口的大小，sen_que可以理解为发送数的缓冲队列）。 kcp在发送sen_buf队列中的数据时会检测是否是第一次发送： 如果该segment的发送次数为0，则直接发送。 如果发送次数大于0并且已经超时，则再次发送并调整rto和下次超时时间 如果没有超时但是达到了快速重传的条件（被跳过了几个包），则发送并且更新下次超时时间。 函数解析Input1int ikcp_input(ikcpcb *kcp, const char *data, long size) 处理接收到的数据，data即用户传入的数据。kcp不负责网络数据的接收，需要用户将接收到的数据传入。 在接收到数据后，解析数据得到segment的sn，una等数据包头信息。首先根据una清除掉kcp-&gt;snd_buf中已经确认接收到的segment（una即表示该seg之前数据包均已收到），随后根据kcp-&gt;sen_buf更新kcp-&gt;snd_una。 ack: IKCP_CMD_ACK，首先根据该segment的rtt更新计算kcp的rtt和rto，删除掉kcp-&gt;snd_buf中相应的segment，更新kcp的sed_una(下一个未确认的segment)。 push:IKCP_CMD_PUSH，收到push segment后需要发送ack，将该segment的sn和ts放入kcp-&gt;acklist中。 如果该seg符合滑动窗口的范围，则将该segment放入kcp-&gt;rev_buf中。 如果kcp-&gt;queue的大小小于kcp-&gt;rev_wnd(滑动窗口的大小)，则将kcp-&gt;rev_buf符合条件的segment放入kcp-&gt;rcv_queue中(保证序号连续的seg)。 window ask: IKCP_CMD_WASK,将kcp-&gt;probe中相应位置为1，发送segment时向远端发送相应接收窗口大小。 IKCP_CMD_WINS，对应远端的窗口更新包，无需做额外的操作。 随后遍历kcp-&gt;sed_buf，更新每个segment的seg-&gt;fastack(被跳过的次数，用于判断是否需要快速重传)。 如果远端接收状态有更新，则更新本地拥塞窗口的大小。 Receive1int ikcp_recv(ikcpcb *kcp, char *buffer, int len) 用户层面的数据读取，从rcv_queue中读取一个packet（如果该packet在发送前分段的话，则将fragement合并后放入buffer中）。input的操作保证了rcv_queue中的segment都是有序且连续的。 随后如果rcv_queue大小小于rcv_wnd（接收窗口）的大小，则将rcv_buf中合适的segment放入rcv_queue中。 如果需要告知远端主机窗口大小，则1kcp-&gt;probe |= IKCP_ASK_TELL 将ICKP_ASK_TELL置为1。 Send1int ikcp_send(ikcpcb *kcp, const char *buffer, int len) 将buffer中需要发送的数据分片后放入snd_queue中。 在发送数据时，会首先检测是否开启了流模式。如果开启流模式，在发送数据时，如果上一个segment没有填满mss（最大分片大小），则将这次要发送的数据继续写入上一个segment。如果没有开启流模式，则创建一个新的segment发送。 如果需要发送的数据大小大于mss，则将其拆分为多个segment发送，如果不是流模式，则将其frg至为其相应的序号，序号从count-1开始递减至0，即count-1表示第一个segment，0表示最后一个segment。 Flush1void ikcp_flush(ikcpcb *kcp) flush data，即发送需要发送的数据，ack，win probe，push data等，以及检测snd_buf中的数据是否需要重传。 将seg的wnd设置为接收窗口的剩余大小1kcp-&gt;rcv_wnd - kcp-&gt;nrcv_que nrcv_que指接收队列中的segment的数量。 在发送时将需要发送的数据填充到buffer中，如果buffer下次填入的数据量 &gt; mtu，则调用output函数将buffer中的数据发送出去，ouotput函数由用户定义。 发送segment首先将acklist中需要发送的ack发送出去，kcp在发送时会优先发送ack。 如果远端接收窗口大小为0且当前时间超过下次发送窗口探测时间，则1kcp-&gt;probe |= IKCP_ASK_SEND; 并更新窗口探测时间间隔和下次窗口探测时间。 如果需要探测远端发送窗口大小或者需要告诉远端本机发送窗口大小，则发送相应的probe segment。 取拥塞窗口的大小为发送窗口和远端接收窗口的最小值。在已经发送的segment的数量不超过拥塞窗口大小时将送sed_queue中的segment放入snd_buf中。 遍历snd_buf中的数据： 如果之前没有发送过，则设置其rto和超时重传时间，并将needsend置为1. 如果snd_buf中的segment超过其超时重传时间，如果启动无延时模式，则将segment的rto1.5，否则将rto 2，并将needsend置为1。 如果启动了快速重传并且该segment被跳过的次数大于resent，则将needsend置为1，并更新该segment的超时时间。 如果needsend被置为1，则将该segment发送出去。 如果segment的重传次数超过kcp的最大重传次数，则更新kcp的连接状态为-1。 发送之后更新ssthresh(拥塞窗口阈值)和cwnd(拥塞窗口大小)。","categories":[{"name":"network","slug":"network","permalink":"https://uyouii.github.io/categories/network/"}],"tags":[{"name":"network","slug":"network","permalink":"https://uyouii.github.io/tags/network/"},{"name":"kcp","slug":"kcp","permalink":"https://uyouii.github.io/tags/kcp/"},{"name":"coderead","slug":"coderead","permalink":"https://uyouii.github.io/tags/coderead/"}]},{"title":"剑指offer题解","slug":"剑指offer题解","date":"2017-12-21T13:15:39.000Z","updated":"2019-08-02T03:28:18.918Z","comments":true,"path":"2017/12/21/剑指offer题解/","link":"","permalink":"https://uyouii.github.io/2017/12/21/剑指offer题解/","excerpt":"","text":"剑指offer上的一些算法题解。 1 ~ 10 Problems01 赋值运算符函数题目：123求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。 12345678910111213141516171819202122class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int result = 0; int index = 10; while (index / 10 &lt;= n) &#123; int res = n / index, rem = n % index; if(res &gt;= 1) result += res * index / 10; if (rem &gt;= 2 * index / 10) &#123; result += index / 10; &#125; else if(rem &gt;= index / 10 )&#123; result += rem - (index / 10) + 1; &#125; index *= 10; &#125; return result; &#125;&#125;; 03 数组中重复的数字题目：123在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组&#123;2, 3, 1, 0, 2, 5, 3&#125;，那么对应的输出是重复的数字2或者3。 123456789101112131415bool duplicate(int numbers[], int length, int* duplication) &#123; if (!numbers || length &lt;= 0) return false; for (int i = 0; i &lt; length; i++) &#123; while (numbers[i] != i) &#123; if (numbers[i] == numbers[numbers[i]]) &#123; *duplication = numbers[i]; return true; &#125; swap(numbers[i], numbers[numbers[i]]); &#125; &#125; return false;&#125; 04 二维数组中的查找题目：123在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 12345678910111213141516171819202122//每次比较右上角的元素和target的关系，选择剔除行或者列//如果该数字等于要查找的数字，则查找过程结束//如果该数字中大于要查找的数字，则剔除这个字所在的列//如果这个字小于要查找的数字，则提出这个字所在的行bool Find(int* matrix, int rows, int columns, int number) &#123; if (!matrix || rows &lt;= 0 || columns &lt;= 0) return false; int index, r = 0, c = columns - 1; while (r &lt; rows &amp;&amp; c &gt;= 0) &#123; index = r * columns + c; if (matrix[index] == number) return true; else if (matrix[index] &lt; number) &#123; ++r; &#125; else if (matrix[index] &gt; number) &#123; --c; &#125; &#125; return false;&#125; 05 替换空格题目：1请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;。例如输入“We are happy.”，则输出“We%20are%20happy.”。 12345678910111213141516171819202122232425262728293031//先遍历一遍字符串得到其中空格的数量//然后从后面开始替换，时间复杂度O(n),空间复杂度O(1)//length 为字符串的总容量void ReplaceBlank(char string[], int length) &#123; if (!string || length &lt;= 0) return; int blankNum = 0; int oldl = 0; for (; string[oldl] != '\\0'; oldl++) &#123; if (string[oldl] == ' ') ++blankNum; &#125; int newLength = oldl + 2 * blankNum; if (newLength &gt; length) return; int l1 = newLength - 1, l2 = oldl - 1; while (l2 &gt;= 0) &#123; if (string[l2] != ' ') &#123; string[l1--] = string[l2--]; &#125; else &#123; string[l1--] = '0'; string[l1--] = '2'; string[l1--] = '%'; --l2; &#125; &#125;&#125; 06 从尾到头打印链表题目：1输入一个链表的头结点，从尾到头反过来打印出每个结点的值。 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; if (!head) return &#123;&#125;; ListNode* node = head; vector&lt;int&gt; result; while (node) &#123; result.push_back(node-&gt;val); node = node-&gt;next; &#125; reverse(result.begin(), result.end()); return result; &#125;&#125;; 07 重建二叉树题目：123输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列&#123; 1,2,4,7,3,5,6,8 &#125;和中序遍历序列&#123; 4,7,2,1,5,3,8,6 &#125;，则重建二叉树并返回。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre, vector&lt;int&gt; vin) &#123; if (pre.size() == 0 || vin.size() == 0 || pre.size() != vin.size()) return NULL; return createTree(pre, 0, pre.size() - 1, vin, 0, vin.size() - 1); &#125; TreeNode* createTree(vector&lt;int&gt;&amp; pre, int p_begin, int p_end, vector&lt;int&gt;&amp; vin, int v_begin, int v_end) &#123; if (p_begin == p_end) &#123; return new TreeNode(pre[p_begin]); &#125; if (p_begin &gt; p_end) return NULL; int v_head; for (v_head = v_begin; v_head &lt;= v_end; v_head++) &#123; if (vin[v_head] == pre[p_begin]) break; &#125; TreeNode* head = new TreeNode(vin[v_head]); if (v_head &gt; v_begin) &#123; int l = v_head - v_begin; head-&gt;left = createTree(pre, p_begin + 1, p_begin + l, vin, v_begin, v_head - 1); &#125; if (v_head &lt; v_end) &#123; int l = v_end - v_head; head-&gt;right = createTree(pre, p_end - l + 1, p_end, vin, v_head + 1, v_end); &#125; return head; &#125;&#125;; 08 二叉树的下一个节点题目：12给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 123456789101112131415161718192021class Solution &#123;public: TreeLinkNode* GetNext(TreeLinkNode* pNode)&#123; if (!pNode) return NULL; if (pNode-&gt;right) &#123; TreeLinkNode* node = pNode-&gt;right; while (node-&gt;left) node = node-&gt;left; return node; &#125; else &#123; TreeLinkNode* node = pNode; while (node-&gt;next &amp;&amp; node-&gt;next-&gt;right == node) node = node-&gt;next; return node-&gt;next; &#125; &#125;&#125;; 09 用两个栈实现队列题目：12用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 12345678910111213141516171819202122232425262728293031323334353637//很厉害//一个push栈，一个pop栈class Solution&#123;public: void push(int node); int pop();private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;;void Solution::push(int node) &#123; this-&gt;stack1.push(node);&#125;int Solution::pop() &#123; int result = 0; if (this-&gt;stack2.size() &gt; 0) &#123; result = stack2.top(); this-&gt;stack2.pop(); &#125; else &#123; while (stack1.size() &gt; 0) &#123; stack2.push(stack1.top()); stack1.pop(); &#125; if (stack2.size() &gt; 0) &#123; result = stack2.top(); stack2.pop(); &#125; &#125; return result;&#125; 10 斐波那契数列题目：12大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n &lt;= 39 123456789101112131415class Solution &#123;private: vector&lt;int&gt; fibArray;public: int Fibonacci(int n) &#123; if (n == 0 || n == 1) return n; fibArray = vector&lt;int&gt;(n + 1, 0); fibArray[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; fibArray[i] = fibArray[i - 1] + fibArray[i - 2]; &#125; return fibArray[n]; &#125;&#125;; 11 ~ 20 Problems11 旋转数组的最小数字题目：1234把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组&#123; 3,4,5,1,2 &#125;为&#123; 1,2,3,4,5 &#125;的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 12345678910111213141516class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; int begin = 0, end = rotateArray.size() - 1; while (begin &lt; end &amp;&amp; rotateArray[begin] &gt;= rotateArray[end]) &#123; int mid = (begin + end) / 2; if (rotateArray[mid] &gt;= rotateArray[end]) &#123; begin = mid + 1; &#125; else if (rotateArray[mid] &lt; rotateArray[end]) &#123; end = mid; &#125; &#125; return rotateArray[begin]; &#125;&#125;; 12 矩阵中的路径题目：12345请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; int rows, cols; vector&lt;vector&lt;bool&gt;&gt; mark;public: bool hasPath(char* matrix, int rows, int cols, char* str) &#123; if (!matrix || rows &lt;= 0 || cols &lt;= 0) return false; this-&gt;mark = vector&lt;vector&lt;bool&gt;&gt;(rows, vector&lt;bool&gt;(cols, false)); this-&gt;rows = rows; this-&gt;cols = cols; char* c = matrix; bool result = false; for (int i = 0; i &lt; strlen(matrix); i++) &#123; if (matrix[i] == *str) &#123; result = found(matrix, str, i / cols, i % cols); &#125; if (result) break; &#125; return result; &#125;private: bool found(char* matrix, char* str, int x,int y) &#123; if (*str == '\\0') return true; if (x &lt; 0 || x &gt;= rows || y &lt; 0 || y &gt;= cols) return false; int index = x * cols + y; bool result = false; if (!mark[x][y] &amp;&amp; matrix[index] == *str) &#123; mark[x][y] = true; if (!result) result = found(matrix, str + 1, x - 1, y); if (!result) result = found(matrix, str + 1, x + 1, y); if (!result) result = found(matrix, str + 1, x, y - 1); if (!result) result = found(matrix, str + 1, x, y + 1); mark[x][y] = false; &#125; return result; &#125;&#125;; 13 机器人的运动范围题目:123456地上有一个m行和n列的方格。一个机器人从坐标0, 0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35, 37），因为3 + 5 + 3 + 7 = 18。但是，它不能进入方格（35, 38），因为3 + 5 + 3 + 8 = 19。请问该机器人能够达到多少个格子？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123;public: int movingCount(int threshold, int rows, int cols) &#123; if (threshold &lt; 0) return 0; vector&lt;bool&gt; check(rows * cols, 0); queue&lt;int&gt; search; search.push(0); check[0 ] = true; int result = 1; while (search.size() &gt; 0) &#123; int point = search.front(); int x = point / cols, y = point % cols; search.pop(); if (x &gt; 0 &amp;&amp; count(x - 1, y) &gt; threshold) &#123; check[point - cols] = true; &#125; else if (x &gt; 0 &amp;&amp; !check[point - cols]) &#123; search.push(point - cols); check[point - cols] = true; ++result; &#125; if (x &lt; rows - 1 &amp;&amp; count(x + 1, y) &gt; threshold) &#123; check[point + cols] = true; &#125; else if (x &lt; rows - 1 &amp;&amp; !check[point + cols]) &#123; search.push(point + cols); check[point + cols] = true; ++result; &#125; if (y &gt; 0 &amp;&amp; count(x, y - 1) &gt; threshold) &#123; check[point - 1] = true; &#125; else if (y &gt; 0 &amp;&amp; !check[point - 1]) &#123; search.push(point - 1); check[point - 1] = true; ++result; &#125; if (y &lt; cols - 1 &amp;&amp; count(x, y + 1) &gt; threshold) &#123; check[point + 1] = true; &#125; else if (y &lt; cols - 1 &amp;&amp; !check[point + 1]) &#123; search.push(point + 1); check[point + 1] = true; ++result; &#125; &#125; return result; &#125;private: int count(int rows, int cols) &#123; int result = 0; while (rows &gt; 0) &#123; result += rows % 10; rows /= 10; &#125; while (cols &gt; 0) &#123; result += cols % 10; cols /= 10; &#125; return result; &#125;&#125;; 14 剪绳子题目：123给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]*k[1]*…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。 123456789101112131415161718//如果不知道结论的话可以用动态规划的方法实现//结论：如果剩下的长度仍大于等于5，则尽可能的减成长度为3的绳子//如果小于5，则不变int maxProductAfterCutting(int length) &#123; if (length &lt;= 0) return 0; if (length &lt;= 4) return length; int time3 = length / 3; int rem = length % 3; if (rem == 1) &#123; return 4 * (int)(pow(3, time3 - 1)); &#125; if (rem == 0) return (int)(pow(3, time3)); else return (int)(pow(3, time3)) * rem;&#125; 15 二进制中1的个数题目：1输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 12345678910111213141516//直接将n右移可能会因为n为负数造成死循环//正常解法是用一个flat每次左移和原来的数进行&amp;运算//这里采用一种新解法//n &amp; (n - 1) 相当于将一个数最右边的1变成0class Solution &#123;public: int NumberOf1(int n) &#123; int count = 0; while (n) &#123; n = n &amp; (n - 1); ++count; &#125; return count; &#125;&#125;; 16 数值的整数次方法题目：1给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 12345678910111213141516171819202122232425class Solution &#123;public: double Power(double base, int exponent) &#123; if (exponent == 0) return 1; bool flag = false; if (exponent &lt; 0) &#123; flag = true; exponent = -exponent; &#125; double result = 1.0; double temp = base; while (exponent &gt; 0) &#123; if (exponent &amp; 1) &#123; result *= temp; &#125; exponent &gt;&gt;= 1; temp *= temp; &#125; if (flag) &#123; result = 1 / result; &#125; return result; &#125;&#125;; 18 删除链表中重复的节点题目：123在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 12345678910111213141516171819202122232425262728class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; if (!pHead) return pHead; ListNode* head = new ListNode(0); head-&gt;next = pHead; ListNode* node = head, *tem; while (node) &#123; if (node-&gt;next &amp;&amp; node-&gt;next-&gt;next &amp;&amp; node-&gt;next-&gt;val == node-&gt;next-&gt;next-&gt;val) &#123; int val = node-&gt;next-&gt;val; while (node-&gt;next &amp;&amp; node-&gt;next-&gt;val == val) &#123; tem = node-&gt;next; node-&gt;next = node-&gt;next-&gt;next; delete tem; &#125; &#125; //需要注意! else &#123; node = node-&gt;next; &#125; &#125; pHead = head-&gt;next; delete head; return pHead; &#125;&#125;; 19 正则表达死匹配题目：1234请实现一个函数用来匹配包括&apos;.&apos;和&apos;*&apos;的正则表达式。模式中的字符&apos;.&apos;表示任意一个字符，而&apos;*&apos;表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: bool match(char* str, char* pattern) &#123; if (!str &amp;&amp; !pattern) return true; int M = strlen(str); int N = strlen(pattern); vector&lt;vector&lt;bool&gt;&gt; check(M + 1, vector&lt;bool&gt;(N + 1, false)); check[0][0] = true; for (int k = 1; k &lt;= N; k++) &#123; check[0][k] = (k &gt;= 2 &amp;&amp; pattern[k - 1] == '*' &amp;&amp; check[0][k - 2]); &#125; for (int i = 1; i &lt;= M; i++) &#123; for (int j = 1; j &lt;= N; j++) &#123; if (pattern[j - 1] == '.') &#123; check[i][j] = check[i - 1][j - 1]; &#125; else if (pattern[j - 1] == '*') &#123; if (j &gt;= 2 &amp;&amp; pattern[j - 2] == '.') &#123; for (int k = 0; k &lt;= i; k++) &#123; if (check[k][j - 2]) &#123; check[i][j] = true; break; &#125; &#125; &#125; else &#123; check[i][j] = check[i][j - 1] || (j &gt;= 2 &amp;&amp; (check[i - 1][j] || check[i - 1][j - 1]) &amp;&amp; (str[i - 1] == pattern[j - 2])) || (j &gt;= 2 &amp;&amp; check[i][j - 2]); &#125; &#125; else&#123; check[i][j] = check[i - 1][j - 1] &amp;&amp; (str[i - 1] == pattern[j - 1]); &#125; &#125; &#125; //for (int i = 0; i &lt;= M; i++) &#123; // for (int j = 0; j &lt;= N; j++) &#123; // cout &lt;&lt; check[i][j] &lt;&lt; \" \"; // &#125; // cout &lt;&lt; endl; //&#125; return check[M][N]; &#125;&#125;; 21 ~ 30 Problems21 调整数组顺序使奇数位于偶数前面题目：123输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 123456789101112131415161718class Solution &#123;public: void reOrderArray(vector&lt;int&gt;&amp; array) &#123; if (array.size() == 0) return; vector&lt;int&gt; orderArray(array); int begin = 0, end = orderArray.size() - 1; for (int i = 0; i &lt; orderArray.size(); i++) &#123; if (orderArray[i] &amp; 1) &#123; array[begin++] = orderArray[i]; &#125; &#125; for (int i = orderArray.size() - 1; i &gt;= 0; i--) &#123; if (!(orderArray[i] &amp; 1)) array[end--] = orderArray[i]; &#125; &#125;&#125;; 22 链表中倒数第k个节点题目:1输入一个链表，输出该链表中倒数第k个结点。 12345678910111213141516171819class Solution &#123;public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; if (k &lt;= 0 || !pListHead) return NULL; ListNode* node = pListHead; ListNode* lastKNode = pListHead; int number = 0; while (node) &#123; if (number &gt;= k) lastKNode = lastKNode-&gt;next; node = node-&gt;next; number++; &#125; if (k &gt; number) return NULL; return lastKNode; &#125;&#125;; 23 链表中环的入口点题目：1一个链表中包含环，请找出该链表的环的入口结点。 12345678910111213141516171819202122232425class Solution &#123;public: ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (!pHead) return pHead; ListNode *fast = pHead, *slow = pHead; while (fast) &#123; if (!fast-&gt;next || !fast-&gt;next-&gt;next) return NULL; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) break; &#125; ListNode *entrance = pHead; while (entrance != slow) &#123; entrance = entrance-&gt;next; slow = slow-&gt;next; &#125; return entrance; &#125;&#125;; 24 反转链表题目：1输入一个链表，反转链表后，输出链表的所有元素。 1234567891011121314151617class Solution &#123;public: ListNode* ReverseList(ListNode* pHead) &#123; if (!pHead || !pHead-&gt;next) return pHead; ListNode *p1 = pHead, *p2 = pHead-&gt;next, *p3 = pHead-&gt;next-&gt;next; while (p2) &#123; p2-&gt;next = p1; p1 = p2; p2 = p3; if (p3) p3 = p3-&gt;next; &#125; pHead-&gt;next = NULL; return p1; &#125;&#125;; 25 合并两个排序的链表题目：1输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) &#123; if (!pHead1) return pHead2; if (!pHead2) return pHead1; ListNode *node1 = pHead1, *node2 = pHead2, *node; ListNode *head = new ListNode(0); node = head; while (node1 &amp;&amp; node2) &#123; if (node1-&gt;val &lt;= node2-&gt;val) &#123; node-&gt;next = node1; node1 = node1-&gt;next; &#125; else &#123; node-&gt;next = node2; node2 = node2-&gt;next; &#125; node = node-&gt;next; &#125; if (node1) &#123; node-&gt;next = node1; &#125; if (node2) &#123; node-&gt;next = node2; &#125; node = head-&gt;next; delete head; return node; &#125;&#125;; 26 树的子结构题目：1输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) &#123; if (!pRoot2 || !pRoot1) return false; queue&lt;TreeNode*&gt; nodeQueue; nodeQueue.push(pRoot1); while (nodeQueue.size() &gt; 0) &#123; TreeNode* top = nodeQueue.front(); if (top-&gt;val == pRoot2-&gt;val &amp;&amp; check(top, pRoot2)) return true; nodeQueue.pop(); if (top-&gt;left) nodeQueue.push(top-&gt;left); if (top-&gt;right) nodeQueue.push(top-&gt;right); &#125; return false; &#125;private: bool check(TreeNode* node1, TreeNode* node2) &#123; if (!node1 &amp;&amp; !node2) return true; if (!node1 || !node2) return false; if (node1-&gt;val != node2-&gt;val) return false; bool result = true; if (node2-&gt;left) &#123; result *= check(node1-&gt;left, node2-&gt;left); &#125; if (node2-&gt;right) &#123; result *= check(node1-&gt;right, node2-&gt;right); &#125; return result; &#125;&#125;; 27 2叉树的镜像题目：1234567891011121314操作给定的二叉树，将其变换为源二叉树的镜像。输入描述 :二叉树的镜像定义：源二叉树 8 / \\ 6 10 / \\ / \\5 7 9 11镜像二叉树 8 / \\ 10 6 / \\ / \\11 9 7 5 123456789101112131415class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (!pRoot) return; TreeNode* tem = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = tem; if (pRoot-&gt;left) Mirror(pRoot-&gt;left); if (pRoot-&gt;right) Mirror(pRoot-&gt;right); &#125;&#125;; 28 对称的二叉树题目：12请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 123456789101112131415161718192021class Solution &#123;public: bool isSymmetrical(TreeNode* pRoot) &#123; if (!pRoot) return true; return isMirror(pRoot-&gt;left, pRoot-&gt;right); &#125;private: bool isMirror(TreeNode* node1, TreeNode* node2) &#123; if (!node1 &amp;&amp; !node2) return true; if (!node1 || !node2) return false; if (node1-&gt;val != node2-&gt;val) return false; return isMirror(node1-&gt;left, node2-&gt;right) &amp;&amp; isMirror(node1-&gt;right, node2-&gt;left); &#125;&#125;; 30 包含min函数的栈题目：1定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。 1234567891011121314151617181920212223class Solution &#123;public: void push(int value) &#123; if (minValue &gt; value) minValue = value; minStack.push(minValue); dataStack.push(value); &#125; void pop() &#123; dataStack.pop(); minStack.pop(); &#125; int top() &#123; return dataStack.top(); &#125; int min() &#123; return minStack.top(); &#125;private: int minValue = INT_MAX; stack&lt;int&gt; minStack; stack&lt;int&gt; dataStack;&#125;; 31 ~ 40 Problems31 栈的压入和弹出序列题目：1234输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1, 2, 3, 4, 5是某栈的压入顺序，序列4，5, 3, 2, 1是该压栈序列对应的一个弹出序列，但4, 3, 5, 1, 2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 12345678910111213141516171819202122class Solution &#123;public: bool IsPopOrder(vector&lt;int&gt; pushV, vector&lt;int&gt; popV) &#123; if (pushV.size() == 0) return true; int index1 = 0, index2 = 0; stack&lt;int&gt; dataStack; while (index1 &lt; pushV.size()) &#123; do &#123; if (index1 &gt;= pushV.size() || index2 &gt;= popV.size()) break; dataStack.push(pushV[index1]); &#125; while (pushV[index1++] != popV[index2]); while (dataStack.size() &gt; 0 &amp;&amp; dataStack.top() == popV[index2]) &#123; dataStack.pop(); index2++; &#125; &#125; return dataStack.size() == 0; &#125;&#125;; 32 从上到下打印二叉树题目：1从上往下打印出二叉树的每个节点，同层节点从左至右打印。 12345678910111213141516171819202122//层序遍历二叉树本质上是广度优先遍历二叉树class Solution &#123;public: vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123; if (!root) return &#123;&#125;; vector&lt;int&gt;result; queue&lt;TreeNode*&gt; levelQueue; levelQueue.push(root); while (levelQueue.size() &gt; 0) &#123; TreeNode* node = levelQueue.front(); levelQueue.pop(); if (node-&gt;left) levelQueue.push(node-&gt;left); if (node-&gt;right) levelQueue.push(node-&gt;right); result.push_back(node-&gt;val); &#125; return result; &#125;&#125;; 题目：1从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; if (pRoot == NULL) return &#123;&#125;; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; curruntLevel; int currunt = 1; queue&lt;TreeNode*&gt; nodeQueue; nodeQueue.push(pRoot); while (nodeQueue.size() &gt; 0) &#123; TreeNode* node = nodeQueue.front(); nodeQueue.pop(); if (node-&gt;left) nodeQueue.push(node-&gt;left); if (node-&gt;right) nodeQueue.push(node-&gt;right); curruntLevel.push_back(node-&gt;val); currunt--; if (currunt == 0) &#123; currunt = nodeQueue.size(); result.push_back(curruntLevel); curruntLevel = vector&lt;int&gt;(); &#125; &#125; return result; &#125;&#125;; 题目：12请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 1234567891011121314151617181920212223242526272829303132333435363738394041//其实copy操作可以省去，用一个二维的数组和一个bool量实现class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; if (pRoot == NULL) return &#123;&#125;; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;TreeNode*&gt; level1; vector&lt;TreeNode*&gt; level2; vector&lt;int&gt; curruntLevel; level1.push_back(pRoot); bool currunt = true; while (level1.size() &gt; 0) &#123; for (int i = 0; i &lt; level1.size(); i++) &#123; if (level1[i]-&gt;left) &#123; level2.push_back(level1[i]-&gt;left); &#125; if (level1[i]-&gt;right) level2.push_back(level1[i]-&gt;right); &#125; if (currunt) &#123; for (int i = 0; i &lt; level1.size(); i++) &#123; curruntLevel.push_back(level1[i]-&gt;val); &#125; &#125; else &#123; for (int i = level1.size() - 1; i &gt;= 0; i--) &#123; curruntLevel.push_back(level1[i]-&gt;val); &#125; &#125; level1 = level2; level2 = vector&lt;TreeNode*&gt;(); result.push_back(curruntLevel); curruntLevel = vector&lt;int&gt;(); currunt = !currunt; &#125; return result; &#125;&#125;; 33 二叉树的后续遍历序列12输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes, 否则输出No。假设输入的数组的任意两个数字都互不相同。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; if (sequence.size() == 0) return false; return justify(sequence, 0, sequence.size() - 1); &#125;private: bool justify(vector&lt;int&gt;&amp;sequence, int begin, int end) &#123; if (begin == end) return true; int top = sequence[end]; int firstLarge; for (firstLarge = begin; firstLarge &lt; end; firstLarge++) &#123; if (sequence[firstLarge] &gt; top) break; &#125; for (int i = firstLarge; i &lt; end; i++) &#123; if (sequence[i] &lt; top) return false; &#125; if (firstLarge == begin) &#123; return justify(sequence, begin, end - 1); &#125; else if (firstLarge == end) &#123; return justify(sequence, begin, end - 1); &#125; else &#123; return justify(sequence, begin, firstLarge - 1) &amp;&amp; justify(sequence, firstLarge, end - 1); &#125; &#125;&#125;; 34 二叉树中和为某一值的路径12输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root, int expectNumber) &#123; if (!root) return &#123;&#125;; this-&gt;expectNumber = expectNumber; vector&lt;int&gt; pathNumbers; find(pathNumbers, root, 0); return this-&gt;paths; &#125;private: vector&lt;vector&lt;int&gt;&gt; paths; int expectNumber; void find(vector&lt;int&gt;&amp; pathNumbers,TreeNode* node,int total) &#123; pathNumbers.push_back(node-&gt;val); total += node-&gt;val; if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; if (total == this-&gt;expectNumber) &#123; this-&gt;paths.push_back(pathNumbers); &#125; &#125; else &#123; if (node-&gt;left) &#123; find(pathNumbers, node-&gt;left, total); &#125; if (node-&gt;right) &#123; find(pathNumbers, node-&gt;right, total); &#125; &#125; if (pathNumbers.size() &gt; 0) &#123; total -= pathNumbers.back(); pathNumbers.pop_back(); &#125; &#125;&#125;; 35 复杂链表的复制123输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 123456789101112131415161718192021222324252627282930313233343536373839404142434445struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;&#125;;class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead) &#123; if (!pHead) return NULL; RandomListNode* node = pHead; while (node) &#123; RandomListNode *newNode = new RandomListNode(node-&gt;label); newNode-&gt;next = node-&gt;next; node-&gt;next = newNode; node = newNode-&gt;next; &#125; node = pHead; while (node) &#123; if (node-&gt;random) &#123; node-&gt;next-&gt;random = node-&gt;random-&gt;next; &#125; else node-&gt;next-&gt;random = NULL; node = node-&gt;next-&gt;next; &#125; RandomListNode* newHead = new RandomListNode(0), *newNode; newNode = newHead; node = pHead; while (node) &#123; newNode-&gt;next = node-&gt;next; node-&gt;next = node-&gt;next-&gt;next; newNode = newNode-&gt;next; node = node-&gt;next; &#125; newNode = newHead-&gt;next; delete newHead; return newNode; &#125;&#125;; 36 二叉搜索树与双向链表1输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 1234567891011121314151617181920212223242526272829class Solution &#123;public: TreeNode* Convert(TreeNode* pRootOfTree) &#123; if (!pRootOfTree) return NULL; change(pRootOfTree); while (lagetestNode-&gt;left) lagetestNode = lagetestNode-&gt;left; return lagetestNode; &#125;private: //TreeNode* smallestNode; TreeNode* lagetestNode = NULL; void change(TreeNode* node) &#123; if (node-&gt;left) &#123; change(node-&gt;left); &#125; node-&gt;left = lagetestNode; if (lagetestNode) &#123; lagetestNode-&gt;right = node; &#125; lagetestNode = node; if (node-&gt;right) &#123; change(node-&gt;right); &#125; &#125;&#125;; 37 序列化二叉树1请实现两个函数，分别用来序列化和反序列化二叉树 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: char* Serialize(TreeNode *root) &#123; vector&lt;int&gt; values; Serial(root, values); stringstream ss; for (int i = 0; i &lt; values.size(); i++) &#123; if (values[i] == -1) &#123; ss &lt;&lt; '$'; &#125; else &#123; ss &lt;&lt; values[i]; &#125; ss &lt;&lt; ','; &#125; return (char*)ss.str().c_str(); &#125; TreeNode* Deserialize(char *str) &#123; &#125;private: void Serial(TreeNode* node, vector&lt;int&gt;&amp; values) &#123; if (!node) &#123; values.push_back(-1); return; &#125; values.push_back(node-&gt;val); Serial(node-&gt;left, values); Serial(node-&gt;right, values); &#125;&#125;; 39 数组中出现次数超过一半的数字题目：123数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组&#123; 1,2,3,2,2,2,5,4,2 &#125;。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if (numbers.size() &lt;= 0) return INT_MAX; if (numbers.size() == 1) return numbers[0]; int result = numbers[0], times = 1; for (int i = 1; i &lt; numbers.size(); i++) &#123; if (numbers[i] != result) &#123; --times; if (times == 0) &#123; result = numbers[i]; times = 1; &#125; &#125; else &#123; times++; &#125; &#125; return CheckHalf(result, numbers) ? result : 0; &#125;private: bool CheckHalf(int number, vector&lt;int&gt;&amp; numbers) &#123; int times = 0; for (int i = 0; i &lt; numbers.size(); i++) &#123; if (numbers[i] == number) &#123; times++; &#125; &#125; return times &gt; numbers.size() / 2; &#125;&#125;; 40 最小的k个数题目：12输入n个整数，找出其中最小的K个数。例如输入4, 5, 1, 6, 2, 7, 3, 8这8个数字，则最小的4个数字是1, 2, 3, 4, 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; if (k &lt;= 0 || k &gt; input.size()) return this-&gt;result; FindSmallestK(input, k, 0, input.size() - 1); return this-&gt;result; &#125;private: vector&lt;int&gt; result; void FindSmallestK(vector&lt;int&gt;&amp; numbers, int k, int begin, int end) &#123; if (k == 0 || begin &gt; end) return; if (end - begin + 1 &lt;= k) &#123; for (int i = begin; i &lt;= end; i++) &#123; this-&gt;result.push_back(numbers[i]); &#125; return; &#125; int num = numbers[end]; int b = begin, e = end - 1; while (b &lt; e) &#123; while (b &lt; end &amp;&amp; numbers[b] &lt;= num) ++b; while (e &gt; begin &amp;&amp; numbers[e] &gt; num) --e; if (b &lt; e) swap(numbers[b], numbers[e]); &#125; if(numbers[b] &gt; numbers[end]) swap(numbers[b], numbers[end]); if (b == end) &#123; FindSmallestK(numbers, k, begin, end - 1); &#125; else if (b - begin + 1 &lt;= k) &#123; k -= b - begin + 1; for (int i = begin; i &lt;= b; i++) &#123; result.push_back(numbers[i]); &#125; FindSmallestK(numbers, k, b + 1, end); &#125; else &#123; FindSmallestK(numbers, k, begin, b); &#125; &#125; &#125;; 41 ~ 50 Problems42 连续子数组的最大和题目：1234HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后, 他又发话了:在古老的一维模式识别中, 常常需要计算连续子向量的最大和, 当向量全为正数的时候, 问题很好解决。但是, 如果向量中包含负数, 是否应该包含某个负数, 并期望旁边的正数会弥补它呢？例如 : &#123;6, -3, -2, 7, -15, 1, 2, 2&#125;, 连续子向量的最大和为8(从第0个开始, 到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1) 123456789101112131415161718192021class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; if (array.size() == 0) return 0; int max = INT_MIN, sum = 0; int begin = 0, end = 0; while (end &lt; array.size()) &#123; sum += array[end]; if (sum &gt; max) max = sum; if (sum &lt;= 0) &#123; begin = end + 1; sum = 0; &#125; end++; &#125; return max; &#125;&#125;; 43 1~n整数中1出现的次数题目：123求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。 12345678910111213141516171819202122class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int result = 0; int index = 10; while (index / 10 &lt;= n) &#123; int res = n / index, rem = n % index; if(res &gt;= 1) result += res * index / 10; if (rem &gt;= 2 * index / 10) &#123; result += index / 10; &#125; else if(rem &gt;= index / 10 )&#123; result += rem - (index / 10) + 1; &#125; index *= 10; &#125; return result; &#125;&#125;;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://uyouii.github.io/categories/algorithm/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://uyouii.github.io/tags/c/"},{"name":"algorithm","slug":"algorithm","permalink":"https://uyouii.github.io/tags/algorithm/"}]},{"title":"LeetCode  算法题解","slug":"LeetCode-算法题解","date":"2017-12-21T10:37:00.000Z","updated":"2019-08-02T03:28:18.914Z","comments":true,"path":"2017/12/21/LeetCode-算法题解/","link":"","permalink":"https://uyouii.github.io/2017/12/21/LeetCode-算法题解/","excerpt":"","text":"LeetCode 上的算法题的一些个人方法。 不多说，直接上代码。 1 ~ 20 problems1 Two Sum难度：Easy123456789101112class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for (int i = 0; i &lt; nums.size(); i++) &#123; for (int j = i + 1; j &lt; nums.size(); j++) &#123; if (nums[i] + nums[j] == target) &#123; return&#123; i,j &#125;; &#125; &#125; &#125; &#125;&#125;; 2 Add Two Numbers难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode * l3 = new ListNode(0); ListNode* l = l3; ListNode* last; while (l1 != NULL &amp;&amp; l2 != NULL) &#123; if (l-&gt;val + l1-&gt;val + l2-&gt;val &lt; 10) &#123; l-&gt;val += l1-&gt;val + l2-&gt;val; l-&gt;next = new ListNode(0); &#125; else if (l-&gt;val + l1-&gt;val + l2-&gt;val &gt;= 10) &#123; l-&gt;next = new ListNode((l-&gt;val + l1-&gt;val + l2-&gt;val) / 10); l-&gt;val = (l-&gt;val + l1-&gt;val + l2-&gt;val) % 10; &#125; last = l; l = l-&gt;next; l1 = l1-&gt;next; l2 = l2-&gt;next; &#125; if (l1 == NULL) &#123; while (l2 != NULL) &#123; if (l-&gt;val + l2-&gt;val &lt; 10) &#123; l-&gt;val += l2-&gt;val; l-&gt;next = new ListNode(0); &#125; else if (l-&gt;val + l2-&gt;val &gt;= 10) &#123; l-&gt;next = new ListNode((l-&gt;val + l2-&gt;val) / 10); l-&gt;val = (l-&gt;val + l2-&gt;val) % 10; &#125; last = l; l = l-&gt;next; l2 = l2-&gt;next; &#125; &#125; if (l2 == NULL) &#123; while (l1 != NULL) &#123; if (l-&gt;val + l1-&gt;val &lt; 10) &#123; l-&gt;val += l1-&gt;val; l-&gt;next = new ListNode(0); &#125; else if (l-&gt;val + l1-&gt;val &gt;= 10) &#123; l-&gt;next = new ListNode((l-&gt;val + l1-&gt;val) / 10); l-&gt;val = (l-&gt;val + l1-&gt;val) % 10; &#125; last = l; l = l-&gt;next; l1 = l1-&gt;next; &#125; &#125; if (l-&gt;val == 0) last-&gt;next = NULL; return l3; &#125;&#125;; 3 Longest Substring Without Repeating Characters难度：Medium1234567891011121314151617181920212223242526272829class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; bool exist[128]; for (int i = 0; i &lt; 128; i++) &#123; exist[i] = false; &#125; int length = 0, max = 0; for (int i = 0; i &lt; s.length(); i++) &#123; for (int j = i; j &lt; s.length(); j++) &#123; char c = s[j]; if (exist[c]) &#123; break; &#125; else &#123; exist[c] = true; length++; &#125; &#125; for (int i = 0; i &lt; 128; i++) &#123; exist[i] = false; &#125; if (length &gt; max) max = length; length = 0; &#125; return max; &#125;&#125;; 4 Median of Two Sorted Arrays.cpp难度：Hard12345678910111213141516171819202122232425262728293031class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int l1 = (nums1.size() + nums2.size() + 1) &gt;&gt; 1; int l2 = (nums1.size() + nums2.size() + 2) &gt;&gt; 1; cout &lt;&lt; l1 &lt;&lt; \" \" &lt;&lt; l2 &lt;&lt; endl; return (getkth(nums1, 0, nums1.size(), nums2, 0, nums2.size(), l1) + getkth(nums1, 0, nums1.size(), nums2, 0, nums2.size(), l2)) / 2.0; &#125;private: int getkth(vector&lt;int&gt;&amp; nums1, int begin1, int l1, vector&lt;int&gt;&amp; nums2, int begin2, int l2, int k) &#123; if (l1 &gt; l2) return getkth(nums2, begin2, l2, nums1, begin1, l1, k); if (l1 == 0) return nums2[begin2 + k - 1]; if (k == 1) return min(nums1[begin1], nums2[begin2]); int i = min(l1, k / 2), j = min(l2, k / 2); if (nums1[begin1 + i - 1] &gt; nums2[begin2 + j - 1]) &#123; return getkth(nums1, begin1, l1, nums2, begin2 + j, l2 - j, k - j); &#125; else &#123; return getkth(nums1, begin1 + i, l1 - i, nums2, begin2, l2, k - i); &#125; &#125;&#125;; 5 Longest Palindromic Substring难度：Medium123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: //动态规划 string longestPalindrome(string s) &#123; if (s.length() == 1) return s; const int MAX = 1000; int resultLength = 0; string result; bool P[MAX][MAX] = &#123;&#125;; int length, begin; for (length = 1; length &lt;= s.length(); length++) &#123; for (begin = 0; begin + length &lt;= s.length(); begin++) &#123; if (length == 1) &#123; P[begin][begin + length - 1] = true; if (resultLength &lt; 1) &#123; resultLength = 1; result = s[begin]; &#125; &#125; else if (length == 2) &#123; if (s[begin] == s[begin + length - 1]) &#123; P[begin][begin + length - 1] = true; if (resultLength &lt; 2) &#123; resultLength = 2; result = s.substr(begin, length); &#125; &#125; &#125; else if (P[begin + 1][begin + length - 2] &amp;&amp; s[begin] == s[begin + length - 1]) &#123; P[begin][begin + length - 1] = true; if (resultLength &lt; length) &#123; resultLength = length; result = s.substr(begin, length); &#125; &#125; &#125; &#125; return result; &#125;&#125;; 6 ZigZag Conversion难度：Medium12345678910111213141516171819202122232425262728class Solution &#123;public: string convert(string s, int numRows) &#123; if (numRows == 1) return s; vector&lt;string&gt; Data; for (int i = 0; i &lt; numRows; i++) &#123; string data; Data.push_back(data); &#125; int M = numRows * 2 - 2; for (int i = 0; i &lt; s.length(); i++) &#123; int num = i % M; if (num &lt; numRows) &#123; Data[num].push_back(s[i]); &#125; else &#123; int n = numRows - (num - numRows) - 2; Data[n].push_back(s[i]); &#125; &#125; string result = \"\"; for (int i = 0; i &lt; numRows; i++) &#123; result += Data[i]; &#125; return result; &#125;&#125;; 7 Reverse Integer难度：Easy12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int reverse(int x) &#123; if (x == 0) return 0; int length = getLength(x); bool isnegative = x &lt; 0; if (x &lt; 0) x = -x; int last = x % 10; int result = 0; int oldresult = result; while (x &gt; 0) &#123; result = result * 10 + x % 10; x = x / 10; &#125; if (result &lt; 0) return 0; int M = 1; for (int i = 0; i &lt; length - 1; i++) &#123; M *= 10; &#125; if (result / M != last) return 0; if (isnegative) return -result; return result; &#125;private: int getLength(int x) &#123; int length = 0; if (x &lt; 0) x = -x; while (x &gt; 0) &#123; x = x / 10; length++; &#125; return length; &#125;&#125;; 8 String to Integer(atoi)难度：Medium1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123;public: int myAtoi(string str) &#123; string s = deleteSpace(str); if (s.empty() || s.length() == 0) return 0; bool isNegative = false; if (s[0] == '-') &#123; isNegative = true; s.erase(0, 1); &#125; else if (s[0] == '+') &#123; s.erase(0, 1); &#125; if (!isdigit(s[0])) return 0; int i = 0; while (i &lt; s.length()) &#123; if (!isdigit(s[i])) break; i++; &#125; s = s.substr(0,i); if (s.length() &gt; 10) &#123; return isNegative ? INT_MIN : INT_MAX; &#125; long Number = 0; for (int i = 0; i &lt; s.length(); i++) &#123; Number = Number * 10 + s[i] - '0'; &#125; if (isNegative) &#123; Number = -Number; return Number &lt; INT_MIN ? INT_MIN : Number; &#125; else &#123; return Number &gt; INT_MAX ? INT_MAX : Number; &#125; return Number; &#125;private: string deleteSpace(string str) &#123; int i = 0; while (i &lt; str.length() &amp;&amp; isspace(str[i])) &#123; i++; &#125; if (i == str.length()) return \"\"; string s = \"\"; while (i &lt; str.length() &amp;&amp; !isspace(str[i])) &#123; s.push_back(str[i]); i++; &#125; return s; &#125;&#125;; 9 Palindrome Number难度：Easy123456789101112131415class Solution &#123;public: bool isPalindrome(int x) &#123; if (x == 0) return true; if (x &lt; 0) x = -x; int m = 0, n = x; while (n &gt; 0) &#123; m = m * 10 + n % 10; n /= 10; &#125; return m == x; &#125;&#125;; 10 Regular Expression Matching难度：Hard1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: bool isMatch(string s, string p) &#123; int sSize = s.length(); int pSize = p.length(); bool ** Checked = new bool*[sSize + 1]; for (int i = 0; i &lt; sSize + 1; i++) &#123; Checked[i] = new bool[pSize + 1]; &#125; Checked[0][0] = true; Checked[0][1] = false; for (int i = 1; i &lt;= sSize; i++) &#123; Checked[i][0] = false; &#125; for (int j = 2; j &lt;= pSize; j++) &#123; if (j == 2) &#123; if (p[1] == '*' &amp;&amp; p[0] != '*') Checked[0][2] = true; else Checked[0][2] = false; &#125; else Checked[0][j] = p[j-1] == '*' ? Checked[0][j-1] || Checked[0][j-2] : false; //cout &lt;&lt; \"[\" &lt;&lt; 0 &lt;&lt; \"][\" &lt;&lt; j &lt;&lt; \"]=\" &lt;&lt; Checked[0][j] &lt;&lt; endl; &#125; for (int i = 1; i &lt;= sSize; i++) &#123; for (int j = 1; j &lt;= pSize; j++) &#123; if (p[j-1] != '*') &#123; Checked[i][j] = Checked[i - 1][j - 1] &amp;&amp; (s[i-1] == p[j-1] || p[j-1] == '.'); //cout &lt;&lt; \"[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; j &lt;&lt; \"]=\" &lt;&lt; Checked[i][j] &lt;&lt; endl; &#125; else &#123; if (Checked[i][j - 1]) &#123; Checked[i][j] = true; &#125; else if(j &gt;= 2 &amp;&amp; Checked[i][j-2]) &#123; Checked[i][j] = true; //cout &lt;&lt; \"[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; j &lt;&lt; \"]=\" &lt;&lt; Checked[i][j] &lt;&lt; endl; &#125; else &#123; Checked[i][j] = Checked[i - 1][j] &amp;&amp; (s[i-1] == p[j - 2] || p[j-2] == '.'); //cout &lt;&lt; \"[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; j &lt;&lt; \"]=\" &lt;&lt; Checked[i][j] &lt;&lt; endl; &#125; &#125; &#125; &#125; bool result = Checked[sSize][pSize]; for (int i = 0; i &lt; sSize; i++) &#123; delete[] Checked[i]; &#125; delete[] Checked; return result; &#125;&#125;; 11 Container With Most Water难度：Medium123456789101112131415161718192021222324class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int begin = 0, end = height.size() - 1; int volume = 0; int v = 0; do &#123; v = (end - begin) * min(height[begin], height[end]); if (volume &lt; v) volume = v; if (height[begin] &lt; height[end]) &#123; begin++; &#125; else end--; &#125; while (begin &lt; end); return volume; &#125;private: int min(int n1, int n2) &#123; return n1 &lt; n2 ? n1 : n2; &#125;&#125;; 12 Integer to Roman难度：Medium1234567891011121314151617class Solution &#123;public: string intToRoman(int num) &#123; string table[4][10] = &#123; &#123; \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\" &#125;, &#123; \"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\" &#125;, &#123; \"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\" &#125;, &#123; \"\", \"M\", \"MM\", \"MMM\" &#125; &#125;; string result; int n = 0; while (num &gt; 0) &#123; result = table[n++][num % 10] + result; num /= 10; &#125; return result; &#125;&#125;; 13 Roman to Integer难度：Easy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: int romanToInt(string s) &#123; int result = 0, i = 0; while (i &lt; s.length()) &#123; switch (s[i]) &#123; case 'M': if (i &gt; 0 &amp;&amp; s[i - 1] == 'C') result += 800; else result += 1000; break; case 'C': if (i &gt; 0 &amp;&amp; s[i - 1] == 'X') result += 80; else result += 100; break; case 'D': &#123; if (i - 1 &gt;= 0 &amp;&amp; s[i - 1] == 'C') result += 300; else result += 500; break; case 'X': if (i &gt; 0 &amp;&amp; s[i - 1] == 'I') result += 8; else result += 10; break; case 'L': if (i &gt; 0 &amp;&amp; s[i - 1] == 'X') result += 30; else result += 50; break; case 'V': if (i &gt; 0 &amp;&amp; s[i - 1] == 'I') result += 3; else result += 5; break; case 'I': result += 1; break; &#125; &#125; i++; &#125; return result; &#125;&#125;; 14 Longest Common Prefix难度：Easy1234567891011121314151617181920212223242526class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if (strs.size() == 0) return \"\"; string s = strs[0]; for (int i = 1; i &lt; strs.size(); i++) &#123; s = commonPrefix(s, strs[i]); &#125; return s; &#125;private: string commonPrefix(string s1, string s2) &#123; string s; if (s1.length() == 0 || s2.length() == 0) return \"\"; int i = 0; while (i &lt; s1.length() &amp;&amp; i &lt; s2.length()) &#123; if (s1[i] == s2[i]) s.push_back(s1[i]); else return s; i++; &#125; return s; &#125;&#125;; 15 3Sum难度：Medium123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) &#123; if (num.size() &lt; 3) return&#123;&#125;; sort(num.begin(), num.end()); vector&lt;vector&lt;int&gt;&gt; result; if (num[num.size() - 1] &lt; 0 || num[0] &gt; 0) return result; vector&lt;int&gt; triple = &#123; 0,0,0 &#125;; for (int i = 0; i &lt; num.size(); i++) &#123; if (num[i] &gt; 0) break; int begin = i + 1; int end = num.size() - 1; while (begin &lt; end) &#123; int sum = num[begin] + num[end]; if (sum + num[i] &lt; 0) &#123; begin++; &#125; else if (sum + num[i] &gt; 0) &#123; end--; &#125; else &#123; triple[0] = num[i]; triple[1] = num[begin]; triple[2] = num[end]; result.push_back(triple); while (begin &lt; end &amp;&amp; num[begin] == triple[1]) begin++; while (begin &lt; end &amp;&amp; num[end] == triple[2]) end--; &#125; &#125; while (i + 1 &lt; num.size() &amp;&amp; num[i + 1] == num[i]) &#123; i++; &#125; &#125; return result; &#125;&#125;; 16 3Sum Closet难度：Medium12345678910111213141516171819202122232425262728class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int minCloset = INT_MAX; int result; for (int i = 0; i &lt; nums.size(); i++) &#123; int begin = i + 1, end = nums.size() - 1; while (begin &lt; end) &#123; int sum = nums[i] + nums[begin] + nums[end]; if (abs(sum - target) &lt; minCloset) &#123; minCloset = abs(sum - target); result = sum; &#125; if (sum - target &lt; 0) &#123; begin++; &#125; else if (sum - target &gt; 0) &#123; end--; &#125; else &#123; return result; &#125; &#125; &#125; return result; &#125;&#125;; 17 Letter Combinations of a Phone Number难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; if (digits.size() == 0) return&#123;&#125;; vector&lt;string&gt; result; vector&lt;string&gt; Data = &#123; \" \",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\" &#125;; for (int i = 0; i &lt; digits.size(); i++) &#123; if (result.size() == 0) &#123; if (Data[(digits[i] - '0')].size() &gt; 0) &#123; for (int j = 0; j &lt; Data[(digits[i] - '0')].size(); j++) &#123; string s; s.push_back(Data[(digits[i] - '0')][j]); result.push_back(s); &#125; &#125; &#125; else &#123; if (Data[(digits[i] - '0')].size() &gt; 0) &#123; int n = result.size(); for (int k = 0; k &lt; Data[(digits[i] - '0')].size() - 1; k++) &#123; for (int j = 0; j &lt; n; j++) &#123; result.push_back(result[j]); &#125; &#125; for (int k = 0; k &lt; Data[(digits[i] - '0')].size(); k++) &#123; for (int j = n * k; j &lt; n* (k + 1); j++) &#123; result[j].push_back(Data[(digits[i] - '0')][k]); &#125; &#125; &#125; &#125; &#125; return result; &#125; &#125;; 18 4Sum难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.size() &lt; 4) return&#123;&#125;; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; result; int len = nums.size(); vector&lt;int&gt; four = &#123; INT_MIN,INT_MIN,INT_MIN,INT_MIN &#125;; for (int first = 0; first &lt; len - 3; first++) &#123; for (int second = first + 1; second &lt; len - 2; second++) &#123; int begin = second + 1, end = len - 1; while (begin &lt; end) &#123; if (nums[first] + nums[second] + nums[begin] + nums[end] &lt; target) &#123; begin++; &#125; else if (nums[first] + nums[second] + nums[begin] + nums[end] &gt; target) &#123; end--; &#125; else &#123; four[0] = nums[first]; four[1] = nums[second]; four[2] = nums[begin]; four[3] = nums[end]; result.push_back(four); do &#123; begin++; &#125; while (begin &lt; end &amp;&amp; nums[begin] == four[2]); do &#123; end--; &#125; while (begin &lt; end &amp;&amp; nums[end] == four[3]); &#125; &#125; while (second &lt; len - 2 &amp;&amp; nums[second + 1] == nums[second]) second++; &#125; while (first &lt; len - 3 &amp;&amp; nums[first + 1] == nums[first]) first++; &#125; return result; &#125;&#125;; 19 Remove Nth Node From End of List难度：Medium12345678910111213141516171819202122232425262728293031class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; int N = getNum(head); if (N &lt; n) return NULL; int x = N - n; if (x == 0) &#123; head = head-&gt;next; &#125; else &#123; ListNode* p = head; ListNode* parent = head; while (x--) &#123; parent = p; p = p-&gt;next; &#125; parent-&gt;next = p-&gt;next; &#125; return head; &#125; int getNum(ListNode* head) &#123; int n = 0; ListNode* p = head; while (p != NULL) &#123; p = p-&gt;next; n++; &#125; return n; &#125;&#125;; 20 Valid Parentheses难度：Easy12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: bool isValid(string s) &#123; vector&lt;char&gt; stack = &#123;'a'&#125;; for (int i = 0; i &lt; s.length(); i++) &#123; switch (s[i]) &#123; case '[': stack.push_back(s[i]); break; case '(': stack.push_back(s[i]); break; case '&#123;': stack.push_back(s[i]); break; case ']': if (stack[stack.size() - 1] != '[') return false; else stack.pop_back(); break; case ')': if (stack[stack.size() - 1] != '(') return false; else stack.pop_back(); break; case '&#125;': if (stack[stack.size() - 1] != '&#123;') return false; else stack.pop_back(); break; default: break; &#125; &#125; if (stack.size() &gt; 1) return false; return true; &#125;&#125;; 21 ~ 40 Problems21 Merge Two Sorted Lists难度：Easy123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode * head = NULL; ListNode * l = NULL; if (l1 == NULL) return l2; if (l2 == NULL) return l1; if (l1-&gt;val &lt; l2-&gt;val) &#123; head = l1; l1 = l1-&gt;next; &#125; else &#123; head = l2; l2 = l2-&gt;next; &#125; l = head; while (l1 != NULL &amp;&amp; l2 != NULL) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; l-&gt;next = l1; l = l-&gt;next; l1 = l1-&gt;next; &#125; else &#123; l-&gt;next = l2; l = l-&gt;next; l2 = l2-&gt;next; &#125; &#125; if (l1 != NULL) &#123; l-&gt;next = l1; &#125; if (l2 != NULL) &#123; l-&gt;next = l2; &#125; return head; &#125;&#125;; 22 Generate Parentheses难度：Medium123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; if (n == 0) return&#123;&#125;; int n1 = n, n2 = n; vector&lt;string&gt; result; addString(result, \"\", n1, n2); return result; &#125; void addString(vector&lt;string&gt;&amp; result, string s ,int n1, int n2) &#123; if (n1 == 0) &#123; while (n2 &gt; 0) &#123; s.push_back(')'); n2--; &#125; result.push_back(s); return; &#125; else if (n2 &lt;= n1) &#123; s.push_back('('); addString(result, s, n1 - 1, n2); &#125; else &#123; string s1 = s; s1.push_back('('); string s2 = s; s2.push_back(')'); addString(result, s1, n1 - 1, n2); addString(result, s2, n1, n2 - 1); &#125; &#125;&#125;; 23 Merge k Sorted Lists难度：Hard123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; if (lists.size() == 0) return NULL; else if (lists.size() == 1) return lists[0]; ListNode* l = lists[0]; for (int i = 1; i &lt; lists.size(); i++) &#123; l = mergeTwoLists(l, lists[i]); &#125; return l; &#125; ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == NULL) return l2; if (l2 == NULL) return l1; ListNode* head; ListNode* l; if (l1-&gt;val &lt; l2-&gt;val) &#123; head = l1; l1 = l1-&gt;next; &#125; else &#123; head = l2; l2 = l2-&gt;next; &#125; l = head; while (l1 != NULL &amp;&amp; l2 != NULL) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; l-&gt;next = l1; l = l-&gt;next; l1 = l1-&gt;next; &#125; else &#123; l-&gt;next = l2; l = l-&gt;next; l2 = l2-&gt;next; &#125; &#125; if (l1 != NULL) l-&gt;next = l1; if (l2 != NULL) l-&gt;next = l2; return head; &#125;&#125;; 24 Swap Nodes in Pairs难度：Medium1234567891011121314151617181920212223242526272829303132class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if (head == NULL) return NULL; ListNode *l1, *l2, *l3, *l; l1 = head; l2 = head-&gt;next; if (l2 == NULL) return head; l3 = l2-&gt;next; l = NULL; head = l2; do &#123; l2-&gt;next = l1; l1-&gt;next = l3; if (l != NULL) &#123; l-&gt;next = l2; &#125; l = l1; l1 = l3; if (l1 == NULL) break; l2 = l1-&gt;next; if (l2 == NULL) break; l3 = l2-&gt;next; &#125; while (1); return head; &#125;&#125;; 25 Reverse Nodes in k-Group难度：Hard12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if (k &lt;= 1) return head; ListNode *begin, *end = head, *next, *result = head; ListNode *lastend; bool first = true; begin = head; while (begin != NULL) &#123; lastend = end; end = begin; int i = 0; for (i = 0; i &lt; k - 1; i++) &#123; if (end-&gt;next == NULL) break; end = end-&gt;next; &#125; if (i != k - 1) return result; next = end-&gt;next; reverse(begin, end); end-&gt;next = next; if (first) &#123; result = begin; first = false; &#125; else &#123; lastend-&gt;next = begin; &#125; begin = next; &#125; return result; &#125;private: void reverse(ListNode* &amp;head, ListNode* &amp;end) &#123; if (head == NULL || head == end) return; ListNode* l1 = head; ListNode* l2 = head; ListNode* l3 = head-&gt;next; while (l2 != end) &#123; l1 = l2; l2 = l3; l3 = l3-&gt;next; l2-&gt;next = l1; &#125; end = head; head = l2; &#125;&#125;; 26 Reverse Duplciates from Sorted Array难度：Easy12345678910111213141516class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 0; int length = 0; int i = 0; while (i &lt; nums.size()) &#123; length++; while (i + 1 &lt; nums.size() &amp;&amp; nums[i] == nums[i + 1]) nums.erase(nums.begin() + i); i++; &#125; return length; &#125;&#125;; 27 Remove Element难度：Easy1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; if (nums.size() == 0) return 0; int warp = nums.size() - 1; int i = 0; for (i = 0; i &lt;= warp; i++) &#123; if (nums[i] == val) &#123; warp = findLast(nums, val, warp); if (warp == -1) return 0; else if (warp &lt;= i) return i; int tem = nums[warp]; nums[warp] = nums[i]; nums[i] = tem; warp--; &#125; &#125; return i; &#125;private: int findLast(vector&lt;int&gt;&amp; nums, int val, int n) &#123; for (int i = n; i &gt;= 0; i--) &#123; if (nums[i] != val) return i; &#125; return -1; &#125;&#125;; 28 Implement strStr()难度：Easy123456789101112131415161718class Solution &#123;public: int strStr(string haystack, string needle) &#123; //return haystack.find(needle); solution 1 if (haystack.size() &lt; needle.size()) return -1; for (int i = 0; i &lt;= haystack.size() - needle.size(); i++) &#123; int j = 0; int num = i; while (haystack[num] == needle[j]) &#123; num++; j++; &#125; if (j &gt;= needle.size()) return i; &#125; return -1; &#125;&#125;; 29 Divide Two Integers难度：Medium12345678910111213141516171819202122232425262728293031class Solution &#123;public: int divide(int dividend, int divisor) &#123; if (!divisor) return INT_MAX; if (divisor == 1) return dividend; if (divisor == -1) &#123; if (dividend == INT_MIN) return INT_MAX; else return -dividend; &#125; bool s1 = dividend &lt; 0; bool s2 = divisor &lt; 0; unsigned int nom = s1 ? -dividend : dividend; unsigned int den = s2 ? -divisor : divisor; unsigned int rem = 0; unsigned int quot = 0; for (int i = 31; i &gt;= 0; --i) &#123; rem &lt;&lt;= 1; rem |= (nom &gt;&gt; i) &amp; 1; if (rem &gt;= den) &#123; rem -= den; quot |= (1 &lt;&lt; i); &#125; &#125; return s1^s2 ? -quot : quot; &#125;&#125;; 30 Substring With Concatenation of All Words难度：Hard12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; if (words.size() == 0 || s.size() == 0) return&#123;&#125;; vector&lt;int&gt; result; vector&lt;bool&gt; ready(words.size(), false); int n = words[0].length(), N = words.size(); if (n == 0) return&#123;&#125;; if (n*N &gt; s.size()) return&#123;&#125;; for (int begin = 0; begin &lt;= (int)(s.size() - n * N); begin++) &#123; string tem = s.substr(begin, n); if (findStr(words, ready, tem)) &#123; int n1 = begin + n; if (n1 &lt;= (int)(s.size() - n)) &#123; tem = s.substr(n1, n); while (n1 &lt;= s.size() - n &amp;&amp; findStr(words, ready, tem)) &#123; n1 = n1 + n; tem = s.substr(n1, n); &#125; &#125; if (isFindAll(ready)) &#123; result.push_back(begin); &#125; ready = vector&lt;bool&gt;(words.size(), false); &#125; &#125; return result; &#125; bool findStr(vector&lt;string&gt;&amp; words, vector&lt;bool&gt;&amp; ready, string str) &#123; for (int i = 0; i &lt; words.size(); i++) &#123; if (!ready[i] &amp;&amp; words[i] == str) &#123; ready[i] = true; return true; &#125; &#125; return false; &#125; bool isFindAll(vector&lt;bool&gt;&amp; ready) &#123; for (int i = 0; i &lt; ready.size(); i++) &#123; if (ready[i] == false) return false; &#125; return true; &#125;&#125;; 31 Next Permutation难度：Medium1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return; if (isLagerest(nums,0)) changeToSmallest(nums, 0); else &#123; for (int i = nums.size() - 1; i &gt;= 0; --i) &#123; if (isLagerest(nums, i)) continue; else &#123; int x = nums[i]; int j; for (j = i + 1; j &lt; nums.size() - 1; j++) &#123; if (nums[j + 1] &lt;= x) &#123; nums[i] = nums[j]; nums[j] = x; changeToSmallest(nums, i + 1); return; &#125; &#125; nums[i] = nums[j]; nums[j] = x; changeToSmallest(nums, i + 1); return; &#125; &#125; &#125; &#125; void changeToSmallest(vector&lt;int&gt;&amp; nums, int begin) &#123; sort(nums.begin() + begin, nums.end()); &#125; bool isLagerest(vector&lt;int&gt;&amp; nums, int begin) &#123; if (nums.size() == 1) return true; if (begin &gt;= nums.size()) return false; for (int i = begin; i &lt; nums.size()- 1; i++) &#123; if (nums[i] &lt; nums[i + 1]) return false; &#125; return true; &#125;&#125;; 32 Longest Valid Parentheses难度：Hard1234567891011121314151617181920212223242526272829class Solution &#123;public: int longestValidParentheses(string s) &#123; vector&lt;bool&gt; isDouble(s.size(), 0); vector&lt;int&gt; nums1; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == '(') nums1.push_back(i); if (s[i] == ')') &#123; if (nums1.size() &gt; 0) &#123; isDouble[nums1[nums1.size() - 1]] = true; isDouble[i] = true; nums1.pop_back(); &#125; &#125; &#125; int begin = 0, end = 0, max = 0; while (begin &lt; s.size()) &#123; end = begin; while (end &lt; s.size() &amp;&amp; isDouble[end]) &#123; end++; &#125; if (end - begin &gt; max) max = end - begin; begin = end + 1; &#125; return max; &#125;&#125;; 33 Search in Rotated Sorted Array难度：Medium1234567891011121314151617181920212223242526class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.size() == 0) return -1; int min = 0; while (min &lt; nums.size() - 1 &amp;&amp; nums[min + 1] &gt; nums[min]) min++; min++; int N = nums.size(); int n = N / 2, num, left = 0, right = N; num = (n + min) % N; while (left &lt;= right) &#123; if (nums[num] &gt; target) &#123; right = n - 1; &#125; else if (nums[num] &lt; target) &#123; left = n + 1; &#125; else return num; n = (left + right) / 2; num = (n + min) % N; &#125; return -1; &#125;&#125;; 34 Search for a Range难度：Medium1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; result = &#123; -1,-1 &#125;; int right = foundRightIndex(nums, target, 0, nums.size() - 1); if (right &lt; 0 || nums[right] != target) return result; int left = foundLeftIndex(nums, target, 0, right); result[0] = left; result[1] = right; return result; &#125;private: //binary search, found two index int foundRightIndex(vector&lt;int&gt;&amp; nums, int target, int left, int right) &#123; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (nums[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; return right; &#125; int foundLeftIndex(vector&lt;int&gt;&amp; nums, int target, int left, int right) &#123; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (nums[mid] &lt; target) left = mid + 1; else right = mid - 1; &#125; return left; &#125;&#125;; 35 Search Insert Position难度：Easy123456789101112131415161718192021222324class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.size() == 0) return 0; return foudRightIndex(nums, target); &#125; int foudRightIndex(vector&lt;int&gt;&amp; nums, int target) &#123; int mid, left, right; left = 0; right = nums.size() - 1; while (left &lt;= right) &#123; mid = (left + right) / 2; if (nums[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; if (right &lt; 0) return 0; else if (nums[right] == target) return right; else return right + 1; &#125;&#125;; 36 Valid Sudoku难度：Medium12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] == '.') continue; if (!isValid(board,i,j)) return false; &#125; &#125; return true; &#125;private: bool isValid(vector&lt;vector&lt;char&gt;&gt;&amp; board, int m, int n) &#123; for (int i = 0; i &lt; 9; i++) &#123; if (i != m &amp;&amp; board[i][n] == board[m][n]) return false; if (i != n &amp;&amp; board[m][i] == board[m][n]) return false; &#125; for (int i = m / 3 * 3; i &lt; m / 3 * 3 + 3; i++) &#123; for (int j = n / 3 * 3; j &lt; n / 3 * 3 + 3; j++) &#123; if (i == m &amp;&amp; n == j) continue; if (board[i][j] == board[m][n]) return false; &#125; &#125; return true; &#125;&#125;; 37 Sudoku Solver难度：Hard123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; fillSudoku(board, 0); &#125;private: bool fillSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x) &#123; if (x == 81) return true; int m = x / 9, n = x % 9; if (board[m][n] != '.') return fillSudoku(board, x + 1); for (int k = 1; k &lt;= 9; k++) &#123; board[m][n] = k + '0'; if (isValid(board, m, n) &amp;&amp; fillSudoku(board, x + 1)) return true; board[m][n] = '.'; &#125; return false; &#125; bool isValid(vector&lt;vector&lt;char&gt;&gt;&amp; board, int m, int n) &#123; for (int i = 0; i &lt; 9; i++) &#123; if (i != m &amp;&amp; board[i][n] == board[m][n]) return false; if (i != n &amp;&amp; board[m][i] == board[m][n]) return false; &#125; for (int i = m / 3 * 3; i &lt; m / 3 * 3 + 3; i++) &#123; for (int j = n / 3 * 3; j &lt; n / 3 * 3 + 3; j++) &#123; if (i == m &amp;&amp; n == j) continue; if (board[i][j] == board[m][n]) return false; &#125; &#125; return true; &#125;&#125;; 38 Count and Say难度：Easy12345678910111213141516171819202122class Solution &#123;public: string countAndSay(int n) &#123; string s1 = \"1\"; for (int i = 1; i &lt; n; i++) &#123; string s2; int j = 0; while (j &lt; s1.size()) &#123; char c = s1[j]; int num = 0; while (j &lt; s1.size() &amp;&amp; s1[j] == c) &#123; num++; j++; &#125; s2.push_back(num + '0'); s2.push_back(c); &#125; s1 = s2; &#125; return s1; &#125;&#125;; 39 Combination Sum难度：Medium1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; temp; getResult(candidates, target, 0, result, temp); return result; &#125; void getResult(vector&lt;int&gt;&amp; candidates, int target, int begin, vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; temp) &#123; if (begin == candidates.size()) return; int num = candidates[begin]; getResult(candidates, target, begin + 1, result, temp); int i = 0; int oldtarget = target; while (target - num &gt; 0) &#123; i++; target -= num; temp.push_back(num); getResult(candidates, target, begin + 1, result, temp); &#125; if (target - num == 0) &#123; temp.push_back(num); result.push_back(temp); &#125; &#125;&#125;; 40 Comination Sum II难度：Medium1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; if (candidates.size() == 0) return&#123;&#125;; sort(candidates.begin(), candidates.end()); vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; temp; getNumber(candidates, target, result, 0, temp); return result; &#125;private: void getNumber(vector&lt;int&gt;&amp; candidates, int target, vector&lt;vector&lt;int&gt;&gt;&amp; result, int begin, vector&lt;int&gt; temp) &#123; if (begin &gt;= candidates.size()) return; if (target &lt; candidates[begin]) return; int num = candidates[begin]; if (target == num) &#123; temp.push_back(num); result.push_back(temp); return; &#125; int n = begin; while (n &lt; candidates.size() &amp;&amp; candidates[n] == num) n++; getNumber(candidates, target, result, n, temp); temp.push_back(num); getNumber(candidates, target - num, result, begin + 1, temp); &#125;&#125;; 41 ~ 60 Problems41 First Missing Positive难度：Hard12345678910111213141516171819202122class Solution &#123;public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 1; int n = nums.size(); for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] != i + 1 &amp;&amp; nums[i] &gt; 0 &amp;&amp; nums[i] &lt; n &amp;&amp; nums[i] != nums[nums[i]- 1]) &#123; int temp = nums[i]; nums[i] = nums[temp - 1]; nums[temp - 1] = temp; i--; &#125; &#125; int i = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] != i + 1) return i + 1; &#125; return nums.size() + 1; &#125;&#125;; 42 Trapping Rain Water难度：Hard1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; if (height.size() == 0) return 0; vector&lt;int&gt; storage(height.size(),0); int begin = 0, end = 0; while (begin &lt; height.size()) &#123; end = foundNextTaller(height, begin); int h = height[begin] &gt; height[end] ? height[end] : height[begin]; for (int i = begin; i &lt;= end; i++) &#123; storage[i] = h; &#125; begin = end; if (begin == height.size() - 1) break; &#125; int trap = 0; for (int i = 0; i &lt; height.size(); i++) &#123; if(storage[i] &gt; height[i]) trap += storage[i] - height[i]; &#125; return trap; &#125;private: int foundNextTaller(vector&lt;int&gt;&amp; height, int begin) &#123; if (begin == height.size() - 1) return begin; int h = height[begin]; int end = begin + 1; int maxHeight = 0, end2 = end; while (end &lt; height.size()) &#123; if (height[end] &gt;= h) return end; if (height[end] &gt; maxHeight) &#123; maxHeight = height[end]; end2 = end; &#125; end++; &#125; return end2; &#125;&#125;; 43 Multiply Strings难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123;public: string multiply(string num1, string num2) &#123; string result = \"0\"; if (num1.size() &gt; num2.size()) &#123; string tem = num1; num1 = num2; num2 = tem; &#125; string num = num2; for (int i = num1.size() - 1; i &gt;= 0; i--) &#123; int n = num1[i] - '0'; if (n &gt; 0) &#123; for (int j = 0; j &lt; n; j++) &#123; result = Add(result, num); &#125; &#125; num.push_back('0'); &#125; return result; &#125;private: string Add(string &amp;num1, string &amp;num2) &#123; int l = num1.size() &gt; num2.size() ? num2.size() : num1.size(); string result; int n1 = 0, n2 = 0; for (int i = 0; i &lt; l; i++) &#123; int x1 = num1[num1.size() - i - 1] - '0'; int x2 = num2[num2.size() - i - 1] - '0'; n2 = (n1 + x1 + x2) &gt;= 10 ? 1 : 0; n1 = (n1 + x1 + x2) &gt;= 10 ? ((n1 + x1 + x2) - 10) : (n1 + x1 + x2); result = (char)('0' + n1) + result; n1 = n2; &#125; if (num1.size() &gt; l) &#123; for (int i = 0; i &lt; num1.size() - l; i++) &#123; int x1 = num1[num1.size() - l - i - 1] - '0'; n2 = (n1 + x1) &gt;= 10 ? 1 : 0; n1 = (n1 + x1) &gt;= 10 ? ((n1 + x1) - 10) : (n1 + x1) ; result = (char)('0' + n1) + result; n1 = n2; &#125; &#125; if (num2.size() &gt; 1) &#123; for (int i = 0; i &lt; num2.size() - l; i++) &#123; int x2 = num2[num2.size() - l - i - 1] - '0'; n2 = (n1 + x2) &gt;= 10 ? 1 : 0; n1 = (n1 + x2) &gt;= 10 ? ((n1 + x2) - 10) : (n1 + x2); result = (char)('0' + n1) + result; n1 = n2; &#125; &#125; if(n1 &gt; 0) result = '1' + result; return result; &#125;&#125;; 44 Wildcard Matching难度：Hard12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool isMatch(string s, string p) &#123; bool *f[2]; int lens = s.size(), lenp = p.size(); f[0] = new bool[lenp + 1], f[1] = new bool[lenp + 1]; f[0][0] = true; for (int i = 1; i &lt;= lenp; ++i) if (p[i - 1] == '*') f[0][i] = f[0][i - 1]; else f[0][i] = false; int now = 0; for (int i = 1; i &lt;= lens; ++i) &#123; now ^= 1, f[now][0] = false; for (int j = 1; j &lt;= lenp; ++j) switch (p[j - 1]) &#123; case '*': f[now][j] = f[now ^ 1][j - 1] | f[now ^ 1][j] | f[now][j - 1]; break; case '?': f[now][j] = f[now ^ 1][j - 1]; break; default: f[now][j] = f[now ^ 1][j - 1] &amp; (s[i - 1] == p[j - 1]); break; &#125; &#125; return f[now][lenp]; &#125;&#125;; 45 Jump Game II难度：Hard1234567891011121314151617181920212223class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt;= 1) return 0; int start = 0; int end = 0; int nextend = 0; int times = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; nextend = nextend &gt; (i + nums[i]) ? nextend : (i + nums[i]); if (nextend &gt;= nums.size() - 1) return times + 1; if (i == end) &#123; times++; end = nextend; &#125; &#125; return times; &#125;&#125;; 46 Permutations难度：Medium12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; if (nums.size() == 0) return result; getpermute(result, nums, 0); return result; &#125; void getpermute(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; nums, int k) &#123; if (k == nums.size()) result.push_back(nums); for (int i = k; i &lt; nums.size(); i++) &#123; swap(nums[k], nums[i]); getpermute(result, nums, k + 1); &#125; &#125;&#125;; 47 Permutations II难度：Medium123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return&#123;&#125;; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; result; get(result, nums, 0); return result; &#125; void get(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; nums, int begin) &#123; if (begin == nums.size() - 1) &#123; result.push_back(nums); return; &#125; for (int i = begin; i &lt; nums.size(); i++) &#123; if ( i != begin &amp;&amp; nums[begin] == nums[i]) continue; swap(nums[i], nums[begin]); get(result, nums, begin + 1); &#125; &#125;&#125;; 48 Rotate Image难度：Medium12345678910111213141516171819202122232425class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.size() == 0) return; int N = matrix.size(); for (int m = 0; m &lt; N / 2; m++) &#123; for (int n = m; n &lt; N - 1 - m; n++) &#123; swap(matrix[m][n], matrix[n][N - 1 - m]); swap(matrix[m][n], matrix[N - 1 - m][N - 1 - n]); swap(matrix[m][n], matrix[N - 1 - n][m]); /*int tem[4]; tem[0] = matrix[m][n]; tem[1] = matrix[n][N - 1 - m]; tem[2] = matrix[N - 1 - m][N - 1 - n]; tem[3] = matrix[N - 1 - n][m]; matrix[m][n] = tem[3]; matrix[n][N - 1 - m] = tem[0]; matrix[N - 1 - m][N - 1 - n] = tem[1]; matrix[N - 1 - n][m] = tem[2];*/ &#125; &#125; &#125;&#125;; 49 Group Anagrams难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; if (strs.size() == 0) return&#123;&#125;; vector&lt;string&gt; sortedStrs; for (int i = 0; i &lt; strs.size(); i++) &#123; string str = strs[i]; sort(str.begin(), str.end()); sortedStrs.push_back(str); &#125; vector&lt;vector&lt;string&gt;&gt; result; map&lt;string, vector&lt;string&gt;&gt; style; for (int i = 0; i &lt; sortedStrs.size(); i++) &#123; if (style.size() &gt; 0 &amp;&amp; style.find(sortedStrs[i]) != style.end()) &#123; style[sortedStrs[i]].push_back(strs[i]); &#125; else style.insert(&#123; sortedStrs[i], &#123; strs[i] &#125; &#125;); &#125; for (auto p = style.begin(); p != style.end(); p++) &#123; result.push_back(p-&gt;second); &#125; /*for (int i = 0; i &lt; sortedStrs.size(); i++) &#123; for (int j = 0; j &lt; sortedStrs.size() - 1 - i; j++) &#123; if (sortedStrs[j] &gt; sortedStrs[j + 1]) &#123; swap(sortedStrs[j], sortedStrs[j + 1]); swap(strs[j], strs[j + 1]); &#125; &#125; &#125; int begin = 0; while (begin &lt; sortedStrs.size()) &#123; int end = begin; while (end + 1 &lt; sortedStrs.size() &amp;&amp; sortedStrs[end] == sortedStrs[end + 1]) &#123; end++; &#125; vector&lt;string&gt; line; for (int i = begin; i &lt;= end; i++) &#123; line.push_back(strs[i]); &#125; result.push_back(line); begin = end + 1; &#125;*/ return result; &#125;&#125;; 50 Pow(x,n)难度：Medium1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: double myPow(double x, int n) &#123; if (n == 0) return 1; if (x == 1) return 1; if (x == -1) if (n % 2 == 0) return 1; else return -1; bool negative = false; if (n &lt; 0) &#123; if (n == INT_MIN) return 0; negative = true; n = -n; &#125; string num = TenToTwo(n); double result = 1; for (int i = 0; i &lt; num.size(); i++) &#123; if (num[i] == '1') &#123; result = result * result * x; &#125; else result = result * result; &#125; if (negative) result = 1 / result; return result; &#125; string TenToTwo(int n) &#123; string result; while (n &gt; 0) &#123; if (n &amp; 1) result = \"1\" + result; else result = \"0\" + result; n /= 2; &#125; return result; &#125;&#125;; 51 N-Queens难度：Hard1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; if (n == 0) return&#123;&#125;; vector&lt;string&gt; block = &#123; (unsigned int)n,string((unsigned int)n,'.') &#125;; vector&lt;bool&gt; checkRow(n, false); vector&lt;bool&gt; checkColumn(n, false); vector&lt;bool&gt; checkDiagonal1(n * 2, false); vector&lt;bool&gt; checkDiagonal2(n * 2, false); vector&lt;vector&lt;string&gt;&gt; result; getResult(result, 0, checkColumn, checkDiagonal1,checkDiagonal2, block); return result; &#125;private: void getResult(vector&lt;vector&lt;string&gt;&gt;&amp; result, int row, vector&lt;bool&gt;&amp; column, vector&lt;bool&gt;&amp; diagonal1, vector&lt;bool&gt;&amp; diagonal2, vector&lt;string&gt;&amp; block) &#123; if (row &gt;= block.size()) &#123; result.push_back(block); return; &#125; int n = column.size(); for (int i = 0; i &lt; n; i++) &#123; int k = row - i + n; int w = row + i ; if (column[i] == false &amp;&amp; diagonal1[k] == false &amp;&amp; diagonal2[w] == false) &#123; column[i] = true; diagonal1[k] = true; diagonal2[w] = true; block[row][i] = 'Q'; getResult(result, row + 1, column, diagonal1,diagonal2, block); column[i] = false; diagonal1[k] = false; diagonal2[w] = false; block[row][i] = '.'; &#125; &#125; &#125;&#125;; 52 N-Queens II难度：Hard1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int totalNQueens(int n) &#123; if (n == 0) return&#123;&#125;; vector&lt;bool&gt; checkRow(n, false); vector&lt;bool&gt; checkColumn(n, false); vector&lt;bool&gt; checkDiagonal1(n * 2, false); vector&lt;bool&gt; checkDiagonal2(n * 2, false); int result = 0; getResult(result, 0, checkColumn, checkDiagonal1, checkDiagonal2,n); return result; &#125;private: void getResult(int&amp; result, int row, vector&lt;bool&gt;&amp; column, vector&lt;bool&gt;&amp; diagonal1, vector&lt;bool&gt;&amp; diagonal2,int N) &#123; if (row &gt;= N) &#123; result++; return; &#125; int n = column.size(); for (int i = 0; i &lt; n; i++) &#123; int k = row - i + n; int w = row + i; if (column[i] == false &amp;&amp; diagonal1[k] == false &amp;&amp; diagonal2[w] == false) &#123; column[i] = true; diagonal1[k] = true; diagonal2[w] = true; getResult(result, row + 1, column, diagonal1, diagonal2, N); column[i] = false; diagonal1[k] = false; diagonal2[w] = false; &#125; &#125; &#125;&#125;; 53 Maximum Subarray难度：Easy123456789101112131415161718192021222324class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 0; int begin = 0, end = begin, maxSum = INT_MIN; while (begin &lt; nums.size()) &#123; if (nums[begin] &gt; maxSum) maxSum = nums[begin]; int sum = 0; end = begin; while (end &lt; nums.size()) &#123; sum += nums[end]; if (sum &gt; maxSum) maxSum = sum; if (sum &lt; 0) break; end++; &#125; begin = end + 1; &#125; return maxSum; &#125;&#125;; 54 Jump Game难度：Medium123456789101112131415class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int maxLength = 0; for (int i = 0; i &lt; nums.size() - 1; i++) &#123; if (maxLength &lt; i) return false; if (maxLength &lt; i + nums[i]) maxLength = i + nums[i]; &#125; if (maxLength &lt; nums.size() - 1) return false; return true; &#125;&#125;; 55 Spiral Matrix难度：Medium123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(); if (m == 0) return&#123;&#125;; int n = matrix[0].size(); vector&lt;int&gt; result; int min = m &lt; n ? m : n; int loop = min / 2; for (int k = 0; k &lt; loop; k++) &#123; for (int i = k; i &lt; n - k; i++) &#123; result.push_back(matrix[k][i]); &#125; result.pop_back(); for (int i = k; i &lt; m - k; i++) &#123; result.push_back(matrix[i][n - k - 1]); &#125; result.pop_back(); for (int i = n - k - 1; i &gt;= k; i--) &#123; result.push_back(matrix[m - k - 1][i]); &#125; result.pop_back(); for (int i = m - k - 1; i &gt;= k; i--) &#123; result.push_back(matrix[i][k]); &#125; result.pop_back(); &#125; if (m &lt;= n &amp;&amp; m % 2) &#123; for (int i = m / 2; i &lt; n - m / 2; i++) &#123; result.push_back(matrix[m / 2][i]); &#125; &#125; else if (n &lt; m &amp;&amp; n % 2) &#123; for (int i = n / 2; i &lt; m - n / 2; i++) &#123; result.push_back(matrix[i][n / 2]); &#125; &#125; return result; &#125;&#125;; 56 Merge Intervals难度：Medium12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; if (intervals.size() == 0) return&#123;&#125;; map&lt;int,int&gt; list; vector&lt;Interval&gt; result; for (int i = 0; i &lt; intervals.size(); i++) &#123; if (list.size() == 0 || list.find(intervals[i].start) == list.end()) &#123; list.insert(&#123; intervals[i].start, intervals[i].end &#125;); &#125; else &#123; if (list[intervals[i].start] &lt; intervals[i].end) &#123; list[intervals[i].start] = intervals[i].end; &#125; &#125; &#125; for (auto p = list.begin(); p != list.end(); p++) &#123; if (result.size() != 0 &amp;&amp; result.back().end &gt;= p-&gt;first) &#123; if(result.back().end &lt; p-&gt;second) result.back().end = p-&gt;second; &#125; else &#123; Interval x(p-&gt;first, p-&gt;second); result.push_back(x); &#125; &#125; return result; &#125;&#125;; 57 Insert Interval难度：Hard1234567891011121314151617181920212223class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; temp = intervals; temp.push_back(newInterval); sort(temp.begin(), temp.end(), [](Interval a, Interval b) &#123; return a.start &lt; b.start; &#125; ); vector&lt;Interval&gt; result; for (int i = 0; i &lt; temp.size(); i++) &#123; if (result.size() != 0 &amp;&amp; temp[i].start &lt;= result.back().end) &#123; if (temp[i].end &gt; result.back().end) result.back().end = temp[i].end; &#125; else &#123; result.push_back(temp[i]); &#125; &#125; return result; &#125;&#125;; 58 Length of Last Word难度：Easy12345678910111213141516class Solution &#123;public: int lengthOfLastWord(string s) &#123; if (s.size() == 0) return 0; int length = 0; int i = s.size() - 1; while (i &gt;= 0 &amp;&amp; s[i] == ' ') i--; while (i &gt;= 0 &amp;&amp; s[i] != ' ') &#123; i--; length++; &#125; return length; &#125;&#125;; 59 Spiral Matrix II难度：Medium123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; if (n &lt;= 0) return&#123;&#125;; vector&lt;vector&lt;int&gt;&gt; result(n, vector&lt;int&gt;(n, 0)); int x = 1; for (int i = 0; i &lt; n / 2; i++) &#123; for (int k = i; k &lt; n - i; k++) &#123; result[i][k] = x++; &#125; x--; for (int k = i; k &lt; n - i; k++) &#123; result[k][n - i - 1] = x++; &#125; x--; for (int k = n - i - 1; k &gt;= i; k--) &#123; result[n - i - 1][k] = x++; &#125; x--; for (int k = n - i - 1; k &gt;= i + 1; k--) &#123; result[k][i] = x++; &#125; &#125; if (n % 2) &#123; result[n / 2][n / 2] = x; &#125; return result; &#125;&#125;; 60 Permutation Sequence难度：Medium1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: string getPermutation(int n, int k) &#123; if (n == 0) return \"\"; vector&lt;bool&gt; exist(n + 1, true); int f = getFactorial(n); int k2 = k; string result; for (int i = n; i &gt;= 1; i--) &#123; f = f / i; int num = (k2 - 1) / f + 1; int x = 1; while (num &gt; 1) &#123; if (exist[x]) num--; x++; &#125; while (!exist[x]) x++; exist[x] = false; result += (char)(x + '0'); k2 = (k2 - 1) % f + 1; &#125; return result; &#125;private: int getFactorial(int n) &#123; int result = 1; for (int i = 2; i &lt;= n; i++) &#123; result *= i; &#125; return result; &#125;&#125;; 61 ~ 80 Problems61 Rotate List难度：Medium1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if (head == NULL) return head; int n = 0; ListNode* p1 = head; while (p1 != NULL) &#123; p1 = p1-&gt;next; n++; &#125; k = k % n; if (k == 0) return head; ListNode *tail = head, *p = head; int num = 0; while (p-&gt;next != NULL) &#123; p = p-&gt;next; num++; if (num &gt; k) tail = tail-&gt;next; &#125; p-&gt;next = head; ListNode* nhead = tail-&gt;next; tail-&gt;next = NULL; return nhead; &#125;&#125;; 62 Unique Paths难度：Medium1234567891011121314151617181920class Solution &#123;public: int uniquePaths(int m, int n) &#123; if (m &lt;= 1 || n &lt;= 1) return 1; vector&lt;vector&lt;int&gt;&gt; path(2, vector&lt;int&gt;(n, 0)); bool now = 0; for (int i = 0; i &lt; n; i++) &#123; path[0][i] = 1; &#125; for (int i = 1; i &lt; m; i++) &#123; now = !now; path[now][0] = 1; for (int j = 1; j &lt; n; j++) &#123; path[now][j] = path[!now][j] + path[now][j - 1]; &#125; &#125; return path[now][n - 1]; &#125;&#125;; 63 Unique Paths ||难度：Medium12345678910111213141516171819202122232425262728class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(); if (m &lt;= 0) return 0; int n = obstacleGrid[0].size(); if (n &lt;= 0) return 0; int line = 0; vector&lt;vector&lt;int&gt;&gt; path(2, vector&lt;int&gt;(n, 0)); bool now = 0; path[now][0] = obstacleGrid[line][0] == 0 ? 1 : 0;; for (int i = 1; i &lt; n; i++) &#123; path[now][i] = obstacleGrid[line][i] == 0 ? path[now][i-1]: 0; &#125; for (int i = 1; i &lt; m; i++) &#123; line++; now = !now; path[now][0] = obstacleGrid[line][0] == 0 ? path[!now][0] : 0; for (int j = 1; j &lt; n; j++) &#123; path[now][j] = obstacleGrid[line][j] == 0 ? path[!now][j] + path[now][j - 1] : 0; &#125; &#125; return path[now][n - 1]; &#125;&#125;; 64 Minimum Path Sum难度：Medium12345678910111213141516171819202122232425262728class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); if (m &lt;= 0) return 0; int n = grid[0].size(); if (n &lt;= 0) return 0; vector&lt;vector&lt;int&gt;&gt; pathSum(2, vector&lt;int&gt;(n, 0)); bool now = 0; int line = 0; pathSum[0][0] = grid[0][0]; for (int j = 0; j &lt; n; j++) &#123; pathSum[now][j] = grid[line][j] + pathSum[now][j-1]; &#125; for (line = 1; line &lt; m; line++) &#123; now = !now; pathSum[now][0] = grid[line][0] + pathSum[!now][0]; for (int j = 1; j &lt; n; j++) &#123; pathSum[now][j] = min(pathSum[!now][j], pathSum[now][j - 1]) + grid[line][j]; &#125; &#125; return pathSum[now][n - 1]; &#125;&#125;; 65 Valid Number难度：Hard123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution &#123;public: bool isNumber(string s) &#123; if (s.size() == 0) return false; int begin = 0; int end = s.size() - 1; while (begin &lt; s.size() &amp;&amp; isspace(s[begin])) begin++; if (s[begin] == '-' || s[begin] == '+') begin++; while (end &gt;= 0 &amp;&amp; isspace(s[end])) end--; if (begin &gt; end) return false; int p = begin; bool haspoint = false; bool afterE = false; bool hasPulse = false;; bool hasSub = false; while (p &lt;= end) &#123; char c = s[p]; switch (c) &#123; case '+': if (!afterE || p == end || hasPulse) return false; hasPulse = true; break; case '-': if (!afterE || p == end || hasSub) return false; hasSub = true; break; case '.': if (afterE) return false; if (p == begin) &#123; if (p == end) return false; else if (s[p + 1] == 'e') return false; &#125; if (!haspoint) &#123; haspoint = true; &#125; else return false; break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': break; case 'e': if (afterE) return false; if (p == end || p == begin) return false; //if (isZero(s.substr(begin, p - begin))) //return false; afterE = true; break; default: return false; break; &#125; p++; &#125; return true; &#125;&#125;; 66 Plus One难度：Easy123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; int n = digits.size(); vector&lt;int&gt; tem = digits; int i = n - 1; while (i &gt;= 0) &#123; if (tem[i] == 9) tem[i] = 0; else &#123; tem[i] += 1; break; &#125; i--; &#125; if (i &lt; 0) &#123; vector&lt;int&gt; result(n + 1, 0); result[0] = 1; return result; &#125; return tem; &#125;&#125;; 67 Add Binary难度：Easy12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: string addBinary(string a, string b) &#123; if (a.size() == 0) return b; else if (b.size() == 0) return a; int now = 0, next = 0; string result; int n1 = a.size() - 1, n2 = b.size() - 1; while (n1 &gt;= 0 &amp;&amp; n2 &gt;= 0) &#123; now = (a[n1] - '0' + b[n2] - '0' + next) &amp; 1; next = ((a[n1] - '0' + b[n2] - '0' + next) &gt;&gt; 1) &amp; 1; result = (char)('0' + now) + result; n1--; n2--; &#125; while (n1 &gt;= 0) &#123; now = (a[n1] - '0' + next) &amp; 1; next = ((a[n1] - '0' + next) &gt;&gt; 1) &amp; 1; result = (char)('0' + now) + result; n1--; &#125; while (n2 &gt;= 0) &#123; now = (b[n2] - '0' + next) &amp; 1; next = ((b[n2] - '0' + next) &gt;&gt; 1) &amp; 1; result = (char)('0' + now) + result; n2--; &#125; if (next &gt; 0) result = '1' + result; return result; &#125;&#125;; 68 Text Justification难度：Hard12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) &#123; int n = words.size(); if (n == 0 || maxWidth == 0) return&#123;\"\"&#125;; vector&lt;string&gt; result; int begin = 0; while (begin &lt; words.size()) &#123; int end = begin; int length = 0; while (end &lt; words.size() &amp;&amp; length + words[end].size() &lt;= maxWidth - end + begin) &#123; length += words[end].size(); end++; &#125; if (end == words.size()) &#123; string str; for (int i = begin; i &lt; end; i++) &#123; if (i != end - 1) &#123; str += words[i] + ' '; &#125; else str += words[i]; &#125; if(str.size() &lt; maxWidth) str += string(maxWidth - str.size(),' '); result.push_back(str); &#125; else &#123; int NSpace = maxWidth - length; int average = (end - begin - 1) == 0 ? 0 : NSpace / (end - begin - 1); int extra = (end - begin - 1) == 0 ? 0 : NSpace % (end - begin - 1); string str; for (int i = begin; i &lt; end; i++) &#123; if (i != end - 1) &#123; if (i &lt; begin + extra) &#123; str += words[i] + string(average + 1, ' '); &#125; else str += words[i] + string(average, ' '); &#125; else str += words[i]; &#125; if (str.size() &lt; maxWidth) str += string(maxWidth - str.size(), ' '); result.push_back(str); &#125; begin = end; &#125; return result; &#125;&#125;; 69 Sqrt(x)难度：Easy1234567891011121314151617181920212223242526class Solution &#123;public: int mySqrt(int x) &#123; if (x == 0) return 0; int begin = 1, end = x; int mid; while (begin &lt;= end) &#123; mid = (begin + end) / 2; int y = x / mid; if (mid == y) return mid; else if (mid &lt; y) &#123; if ((mid + 1) * (mid + 1) &gt; x) return mid; else &#123; begin = mid + 1; &#125; &#125; else if (mid &gt; y) &#123; end = mid - 1; &#125; &#125; return min(begin,end); &#125;&#125;; 70 Climbing Stairs难度：Easy12345678910111213141516class Solution &#123;public: int climbStairs(int n) &#123; if (n == 1) return 1; //vector&lt;int&gt; stepNum = vector&lt;int&gt;(n + 1, 0); int a = 1, b = 1, c; for (int i = 2; i &lt;= n; i++) &#123; c = a + b; a = b; b = c; &#125; return c; &#125;&#125;; 71 Simplify Path难度：Medium1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: string simplifyPath(string path) &#123; vector&lt;string&gt; s; s.push_back(\"/\"); int begin = 0, end; while (begin &lt; path.size()) &#123; if (path[begin] == '/') &#123; begin++; continue; &#125; end = begin; while (end &lt; path.size() &amp;&amp; path[end] != '/') end++; string str = path.substr(begin, end - begin); if (str == \".\") &#123; &#125; else if (str == \"..\") &#123; if(s.size() &gt; 1) s.pop_back(); &#125; else s.push_back(str); begin = end + 1; &#125; if (s.size() == 1) return \"/\"; string result; for (int i = 1; i &lt; s.size(); i++) &#123; result += \"/\" + s[i]; &#125; return result; &#125;&#125;; 72 Edit Distance难度：Hard123456789101112131415161718192021222324252627282930class Solution &#123;public: int minDistance(string word1, string word2) &#123; if (word1.size() == 0) return word2.size(); else if (word2.size() == 0) return word1.size(); int m = word1.size(), n = word2.size(); vector&lt;vector&lt;int&gt;&gt; check(2, vector&lt;int&gt;(n+ 1, 0)); bool now = 0; int line = 0; for (int i = 0; i &lt;= n; i++) &#123; check[now][i] = i; &#125; for (int line = 1; line &lt;= m; line++) &#123; now = !now; check[now][0] = line; for (int i = 1; i &lt;= n; i++) &#123; if (word1[line - 1] == word2[i -1]) &#123; check[now][i] = min(min(check[!now][i - 1], check[now][i - 1] + 1), check[!now][i] + 1); &#125; else check[now][i] = min(min(check[!now][i - 1] + 1, check[now][i - 1] + 1), check[!now][i] + 1); &#125; &#125; return check[now][n]; &#125;&#125;; 73 Set Marix Zeros难度：Medium123456789101112131415161718192021222324252627class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.size() == 0) return; vector&lt;int&gt; row,column; for (int i = 0; i &lt; matrix.size(); i++) &#123; for (int j = 0; j &lt; matrix[0].size(); j++) &#123; if (matrix[i][j] == 0) &#123; row.push_back(i); column.push_back(j); &#125; &#125; &#125; for (int i = 0; i &lt; row.size(); i++) &#123; for (int j = 0; j &lt; matrix[0].size(); j++) &#123; matrix[row[i]][j] = 0; &#125; &#125; for (int i = 0; i &lt; column.size(); i++) &#123; for (int j = 0; j &lt; matrix.size(); j++) &#123; matrix[j][column[i]] = 0; &#125; &#125; &#125;&#125;; 74 Search a 2D Matrix难度：Medium12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int row = matrix.size(); if (row == 0) return false; int column = matrix[0].size(); int length = row * column; int begin = 0, end = length - 1, mid; while (begin &lt;= end) &#123; mid = (begin + end) / 2; int x = getNumber(matrix, mid); if (x &gt; target) &#123; end = mid - 1; &#125; else if (x &lt; target) &#123; begin = mid + 1; &#125; else return true; &#125; return false; &#125;private: int getNumber(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int length) &#123; int r = length / (matrix[0].size()); int c = length % (matrix[0].size()); return matrix[r][c]; &#125;&#125;; 75 Sort Colors难度：Medium12345678910111213141516171819202122232425class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int begin = 0, end = n - 1; while (begin &lt; end) &#123; while (begin &lt; n &amp;&amp; nums[begin] == 0) begin++; while (end &gt;= 0 &amp;&amp; nums[end] != 0) end--; if(begin &lt; end) swap(nums[begin], nums[end]); &#125; begin = 0, end = n - 1; while (begin &lt; end) &#123; while (begin &lt; n &amp;&amp; nums[begin] != 2) begin++; while (end &gt;= 0 &amp;&amp; nums[end] == 2) end--; if (begin &lt; end) swap(nums[begin], nums[end]); &#125; &#125;&#125;; 76 Minimum Window Substring难度：Hard1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string minWindow(string s, string t) &#123; if (s.size() &lt; t.size()) return \"\"; int digit[128] = &#123;&#125;; bool exist[128] = &#123;&#125;; for (int i = 0; i &lt; t.size(); i++) &#123; digit[t[i]]++; exist[t[i]] = true; &#125; int remender = t.size(); int begin = 0, end = -1; int rb = -1, re = -1; while (end &lt; (int)s.size()) &#123; if (remender == 0) &#123; if (re == -1 || end - begin + 1 &lt; re - rb + 1) &#123; re = end; rb = begin; &#125; if (exist[s[begin]]) &#123; if (digit[s[begin]] &gt;= 0) remender++; digit[s[begin]]++; &#125; begin++; &#125; else &#123; end++; if (exist[s[end]]) &#123; if (digit[s[end]] &gt; 0) remender--; digit[s[end]]--; &#125; &#125; &#125; if (rb == -1) return \"\"; else return s.substr(rb, re - rb + 1); &#125;&#125;; 77 Combinations难度：Medium12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; if (k &lt;= 0) return&#123;&#125;; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; list; getResult(result, list, k, 1, n); return result; &#125; void getResult(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; list,int k,int num,int n) &#123; if (list.size() == k) &#123; result.push_back(list); return; &#125; for (int i = num; i &lt;= n; i++) &#123; list.push_back(i); getResult(result, list, k, i+1, n); list.pop_back(); &#125; &#125;&#125;; 78 Subsets难度：Medium1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; list; getList(result, list, nums, 0); return result; &#125; void getList(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; list,vector&lt;int&gt;&amp; nums, int num) &#123; result.push_back(list); for (int i = num; i &lt; nums.size(); i++) &#123; list.push_back(nums[i]); getList(result, list, nums, i + 1); list.pop_back(); &#125; &#125;&#125;; 79 Word Search难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (board.size() == 0) return false; vector&lt;vector&lt;bool&gt;&gt; check(board.size(), vector&lt;bool&gt;(board[0].size(), 0)); for (int i = 0; i &lt; board.size(); i++) &#123; for (int j = 0; j &lt; board[0].size(); j++) &#123; if (board[i][j] == word[0]) &#123; check[i][j] = true; if (depthSearch(board, check, word, 1, i, j)) return true; check[i][j] = false; &#125; &#125; &#125; return false; &#125;private: bool depthSearch(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;bool&gt;&gt;&amp; check, string&amp; word, int k, int x, int y) &#123; if (k == word.size()) return true; if (x &gt; 0) &#123; if (board[x - 1][y] == word[k] &amp;&amp; !check[x - 1][y] ) &#123; check[x - 1][y] = true; if (depthSearch(board, check, word, k + 1, x - 1, y)) return true; check[x - 1][y] = false; &#125; &#125; if (x &lt; board.size() - 1) &#123; if (board[x + 1][y] == word[k] &amp;&amp; !check[x + 1][y]) &#123; check[x + 1][y] = true; if (depthSearch(board, check, word, k + 1, x + 1, y)) return true; check[x + 1][y] = false; &#125; &#125; if (y &gt; 0) &#123; if (board[x][y - 1] == word[k] &amp;&amp; !check[x][y - 1]) &#123; check[x][y - 1] = true; if (depthSearch(board, check, word, k + 1, x, y - 1)) return true; check[x][y - 1] = false; &#125; &#125; if (y &lt; board[0].size() - 1) &#123; if (board[x][y + 1] == word[k] &amp;&amp; !check[x][y + 1]) &#123; check[x][y + 1] = true; if (depthSearch(board, check, word, k + 1, x, y + 1)) return true; check[x][y + 1] = false; &#125; &#125; return false; &#125;&#125;; 80 Remove Duplicates from Sorted Array II难度：Medium12345678910111213141516class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt;= 2) return nums.size(); int length = 2; for (int i = 2; i &lt; nums.size(); i++) &#123; if (nums[length - 2] != nums[i]) &#123; length++; if (i &gt; length - 1) swap(nums[i], nums[length - 1]); &#125; &#125; return length; &#125;&#125;; 81 ~ 100 Problems81 Search in Rotated Sorted Array II难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.size() == 0) return false; int begin = 0, end = nums.size() - 1, mid; int min = getMin(nums); while (begin &lt;= end) &#123; mid = (begin + end) / 2; int x = nums[(mid + min) % nums.size()]; if (x &gt; target) &#123; end = mid - 1; &#125; else if (x &lt; target) begin = mid + 1; else return true; &#125; return false; &#125;private: int getMin(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 1 || nums.back() &gt; nums[0]) return 0; int begin = 0, end = nums.size() - 1, mid; while (begin &lt;= end) &#123; mid = (begin + end) / 2; if (mid &gt; 0 &amp;&amp; nums[mid] &lt; nums[mid - 1]) return mid; if (nums[mid] &gt; nums[end]) &#123; begin = mid + 1; &#125; else if (nums[mid] &lt; nums[begin]) &#123; end = mid - 1; &#125; else if (nums[end] == nums[begin]) end--; else break; &#125; if (begin &gt; 0 &amp;&amp; nums[begin] &lt; nums[begin - 1]) return begin; else return end + 1; &#125;&#125;; 82 Remove Duplicates from Sorted List II难度：Medium123456789101112131415161718192021222324252627class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (head == NULL) return NULL; ListNode *mhead = new ListNode(0); mhead-&gt;next = head; ListNode *low = head, *far = head; ListNode *oldlow = mhead; int old = far-&gt;val; while (far != NULL) &#123; if (far-&gt;next != NULL &amp;&amp; far-&gt;val == far-&gt;next-&gt;val) &#123; old = far-&gt;val; while (far != NULL &amp;&amp; far-&gt;val == old) far = far-&gt;next; &#125; else &#123; low-&gt;val = far-&gt;val; oldlow = low; low = low-&gt;next; far = far-&gt;next; &#125; &#125; oldlow-&gt;next = NULL; return low == head ? NULL : head; &#125;&#125;; 83 Remove Duplicates from Sorted List难度：Easy123456789101112131415161718class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (head == NULL) return NULL; ListNode *far = head, *low = head, *oldlow; while (far != NULL) &#123; while (far-&gt;next != NULL &amp;&amp; far-&gt;val == far-&gt;next-&gt;val) far = far-&gt;next; low-&gt;val = far-&gt;val; oldlow = low; low = low-&gt;next; far = far-&gt;next; &#125; oldlow-&gt;next = NULL; return head; &#125;&#125;; 84 Largest Rectangle in Histogram难度：Hard12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; if (heights.size() == 0) return 0; int n = heights.size(); int maxA = 0; vector&lt;int&gt; left(n, 0); vector&lt;int&gt; right(n, 0); //left left[0] = 0; for (int i = 1; i &lt; n; i++) &#123; if (heights[i] &gt; heights[i - 1]) left[i] = 0; else &#123; int m = i - 1; while (m &gt;= 0 &amp;&amp; heights[m] &gt;= heights[i]) m -= left[m] + 1; left[i] = i - m - 1; &#125; &#125; //right right[n - 1] = 0; for (int i = n - 2; i &gt;= 0; i--) &#123; if (heights[i] &gt; heights[i + 1]) right[i] = 0; else &#123; int m = i + 1; while (m &lt; n &amp;&amp; heights[m] &gt;= heights[i]) m += right[m] + 1; right[i] = m - i - 1; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; int a = heights[i] * (left[i] + right[i] + 1); if (a &gt; maxA) maxA = a; &#125; return maxA; &#125;&#125;; 85 Maximal Rectangle难度：Hard123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution &#123;public: int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if (matrix.size() == 0) return 0; vector&lt;vector&lt;int&gt;&gt; height(matrix.size(), vector&lt;int&gt;(matrix[0].size(), 0)); for (int j = 0; j &lt; matrix[0].size(); j++) &#123; height[0][j] = matrix[0][j] - '0'; &#125; for (int i = 1; i &lt; matrix.size(); i++) &#123; for (int j = 0; j &lt; matrix[0].size(); j++) &#123; if (matrix[i][j] == '0') &#123; height[i][j] = 0; &#125; else height[i][j] = 1 + height[i - 1][j]; &#125; &#125; int maxR = 0; for (int i = 0; i &lt; matrix.size(); i++) &#123; int x = largestRectangleArea(height[i]); if (x &gt; maxR) maxR = x; &#125; return maxR; &#125;private: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; if (heights.size() == 0) return 0; int n = heights.size(); int maxA = 0; vector&lt;int&gt; left(n, 0); vector&lt;int&gt; right(n, 0); //left left[0] = 0; for (int i = 1; i &lt; n; i++) &#123; if (heights[i] &gt; heights[i - 1]) left[i] = 0; else &#123; int m = i - 1; while (m &gt;= 0 &amp;&amp; heights[m] &gt;= heights[i]) m -= left[m] + 1; left[i] = i - m - 1; &#125; &#125; //right right[n - 1] = 0; for (int i = n - 2; i &gt;= 0; i--) &#123; if (heights[i] &gt; heights[i + 1]) right[i] = 0; else &#123; int m = i + 1; while (m &lt; n &amp;&amp; heights[m] &gt;= heights[i]) m += right[m] + 1; right[i] = m - i - 1; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; int a = heights[i] * (left[i] + right[i] + 1); if (a &gt; maxA) maxA = a; &#125; return maxA; &#125;&#125;; 86 Partition List难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; if (head == NULL) return NULL; /* vector&lt;int&gt; v1; vector&lt;int&gt; v2; ListNode* p = head; while (p != NULL) &#123; if (p-&gt;val &lt; x) v1.push_back(p-&gt;val); else v2.push_back(p-&gt;val); p = p-&gt;next; &#125; p = head; for (int i = 0; i &lt; v1.size(); i++) &#123; p-&gt;val = v1[i]; p = p-&gt;next; &#125; for (int i = 0; i &lt; v2.size(); i++) &#123; p-&gt;val = v2[i]; p = p-&gt;next; &#125; return head;*/ ListNode l1(0); ListNode l2(0); ListNode* p1 = &amp;l1; ListNode* p2 = &amp;l2; while (head != NULL) &#123; if (head-&gt;val &lt; x) &#123; p1-&gt;next = head; p1 = p1-&gt;next; &#125; else &#123; p2-&gt;next = head; p2 = p2-&gt;next; &#125; head = head-&gt;next; &#125; p2-&gt;next = NULL; head = l1.next; if (head == NULL) &#123; return l2.next; &#125; else &#123; p1-&gt;next = l2.next; &#125; return head; &#125;&#125;; 87 Scramble String难度：Hard123456789101112131415161718192021222324252627282930class Solution &#123;public: bool isScramble(string s1, string s2) &#123; if (s1.size() != s2.size()) return false; if (s1.size() == 0) return true; int n = s1.size(); vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; check(n + 1, vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(n, 0))); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; check[1][i][j] = s1[i] == s2[j]; &#125; &#125; for (int l = 1; l &lt;= n; l++) &#123; for (int i = 0; i + l &lt;= n; i++) &#123; for (int j = 0; j + l &lt;= n; j++) &#123; for (int k = 1; k &lt; l; k++) &#123; check[l][i][j] = check[l][i][j] || (check[k][i][j + l - k] &amp;&amp; check[l - k][i + k][j]) || (check[k][i][j] &amp;&amp; check[l - k][i + k][j + k]); &#125; &#125; &#125; &#125; return check[n][0][0]; &#125;&#125;; 88 Merge Sorted Array难度：Easy12345678910111213141516171819class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; vector&lt;int&gt; nums(nums1.size(), 0); int i = 0, j = 0, k = 0; while (i &lt; m &amp;&amp; j &lt; n) &#123; if (nums1[i] &lt; nums2[j]) nums[k++] = nums1[i++]; else nums[k++] = nums2[j++]; &#125; while (i &lt; m) &#123; nums[k++] = nums1[i++]; &#125; while (j &lt; n) &#123; nums[k++] = nums2[j++]; &#125; nums1 = nums; &#125;&#125;; 89 Gray Code难度：Medium12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; if (n == 0) return&#123;&#125;; vector&lt;int&gt; result = &#123; 0,1 &#125;; if (n == 1) return result; result.push_back(3); result.push_back(2); for (int i = 3; i &lt;= n; i++) &#123; int num = result.size() / 2; for (int j = 0; j &lt; num; j++) &#123; result.push_back(result[j] + (3 &lt;&lt; (i - 2))); &#125; for (int j = num - 1; j &gt;= 0; j--) &#123; result.push_back(result[j] + (2 &lt;&lt; (i - 2))); &#125; &#125; return result; &#125;&#125;; 90 Subsets II难度：Medium12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return&#123; &#123;&#125; &#125;; sort(nums.begin(), nums.end()); int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; result; result.push_back(&#123;&#125;); int newnum = 1, samenum = 1; for (int i = 0; i &lt; n; i++) &#123; if (i == 0 || nums[i] != nums[i - 1]) &#123; newnum = result.size(); //ÖØ¸´Ö®Ç°µÄresultÖÐµÄ¸öÊý samenum = 1; //ÖØÖÃÖØ¸´¸öÊý int k = result.size(); for (int j = 0; j &lt; k; j++) &#123; result.push_back(result[j]); result.back().push_back(nums[i]); &#125; &#125; else &#123; samenum++; //ÖØ¸´µÄ¸öÊý for (int j = 0; j &lt; newnum; j++) &#123; result.push_back(result[j]); for (int m = 0; m &lt; samenum; m++) &#123; result.back().push_back(nums[i]); &#125; &#125; &#125; &#125; return result; &#125;&#125;; 91 Decode Ways难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: int numDecodings(string s) &#123; if (s.size() == 0 || s[0] == '0') return 0; vector&lt;int&gt; f(s.size(),0); f[0] = 1; if (s.size() == 1) return 1; if (s[1] == '0') &#123; if (s[0] == '1' || s[0] == '2') f[1] = 1; else return 0; &#125; else &#123; if (s[0] == '1') f[1] = 2; else if (s[0] == '2') &#123; if (s[1] &gt;= '1' &amp;&amp; s[1] &lt;= '6') f[1] = 2; else f[1] = 1; &#125; else f[1] = 1; &#125; for (int i = 2; i &lt; s.size(); i++) &#123; if (s[i] == '0') &#123; if (s[i - 1] == '1' || s[i - 1] == '2') f[i] = f[i - 2]; else return 0; &#125; else &#123; if (s[i - 1] == '1') &#123; f[i] = f[i - 1] + f[i - 2]; &#125; else if (s[i -1] == '2' &amp;&amp; (s[i] &gt;= '1' &amp;&amp; s[i] &lt;= '6')) f[i] = f[i - 1] + f[i - 2]; else f[i] = f[i - 1]; &#125; &#125; return f[s.size()- 1]; &#125;&#125;; 92 Reverse Linked List II难度：Medium12345678910111213141516171819202122232425262728293031class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; if (m == n) return head; ListNode* h = new ListNode(0); h-&gt;next = head; int num = 1; ListNode* p = h; while (num &lt; m) &#123; num++; p = p-&gt;next; &#125; ListNode* n1 = p; p = p-&gt;next; ListNode *p2 = p-&gt;next, *p3 = p2-&gt;next; ListNode* n2 = p; while (num &lt; n) &#123; p2-&gt;next = p; p = p2; p2 = p3; if(p3) p3 = p3-&gt;next; num++; &#125; n2-&gt;next = p2; n1-&gt;next = p; p = h-&gt;next; return h-&gt;next; &#125;&#125;; 93 Restore IP Address难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; int n = s.size(); if (s.size() &lt; 4) return&#123;&#125;; int N = s.size(); vector&lt;string&gt; result; for (int i = 1; i &lt;= 3; i++) &#123; if (!isvaild(s.substr(0, i))) continue; for (int j = 1; j &lt;= 3; j++) &#123; if (!isvaild(s.substr(i, j))) continue; for (int m = 1; m &lt;= 3; m++) &#123; int n = N - i - j - m; if (n &gt; 3 || n &lt;= 0) continue; if (!isvaild(s.substr(i + j, m))) continue; if (!isvaild(s.substr(i + j + m, n))) continue; result.push_back(s.substr(0, i) + \".\" + s.substr(i, j) + \".\" + s.substr(i + j, m) + \".\" + s.substr(i + j + m, n)); &#125; &#125; &#125; return result; &#125;private: bool isvaild(string str) &#123; if (str.size() == 1) return true; if (str[0] == '0') return false; if (str.size() &lt; 3) return true; if (str[0] &gt; '2') return false; else if (str[0] == '2') &#123; if (str[1] &gt; '5') return false; else if (str[1] == '5') &#123; if (str[2] &gt; '5') return false; &#125; &#125; return true; &#125;&#125;; 94 Binary Tree Inorder Traversal难度：Medium123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; if (root == NULL) return&#123;&#125;; vector&lt;int&gt; result; inorderTraversal(result, root); return result; &#125;private: void inorderTraversal(vector&lt;int&gt;&amp; result, TreeNode* node) &#123; if (node == NULL) return; if (node-&gt;left != NULL) inorderTraversal(result, node-&gt;left); result.push_back(node-&gt;val); if (node-&gt;right != NULL) inorderTraversal(result, node-&gt;right); &#125;&#125;; 95 Unique Binary Search Trees II难度：Medium123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123;public: vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if (n &lt;= 0) return&#123;&#125;; vector&lt;TreeNode*&gt; result; TreeNode* node = new TreeNode(1); result.push_back(node); for (int i = 2; i &lt;= n; i++) &#123; int n = result.size(); for (int k = 0; k &lt; n; k++) &#123; TreeNode * p = result[k]; int num = 0; while (p != NULL) &#123; TreeNode * p2 = copyTree(result[k]); TreeNode * p3 = p2; for (int j = 0; j &lt; num; j++) p3 = p3-&gt;right; TreeNode* right = p3-&gt;right; p3-&gt;right = new TreeNode(i); p3-&gt;right-&gt;left = right; result.push_back(p2); p = p-&gt;right; num++; &#125; p = new TreeNode(i); p-&gt;left = result[k]; result[k] = p; &#125; &#125; return result; &#125;private: TreeNode* copyTree(TreeNode* root) &#123; if (root == NULL) return NULL; TreeNode* node = new TreeNode(root-&gt;val); copy(root, node); return node; &#125; void copy(TreeNode* node1, TreeNode* node2) &#123; if (node1-&gt;left != NULL) &#123; node2-&gt;left = new TreeNode(node1-&gt;left-&gt;val); copy(node1-&gt;left, node2-&gt;left); &#125; if (node1-&gt;right != NULL) &#123; node2-&gt;right = new TreeNode(node1-&gt;right-&gt;val); copy(node1-&gt;right, node2-&gt;right); &#125; &#125;&#125;; 96 Unique Binary Search Trees难度：Medium123456789101112131415161718192021222324252627282930class Solution &#123;public: int numTrees(int n) &#123; if (n == 0) return 0; vector&lt;int&gt; result; result.push_back(1); result.push_back(1); for (int i = 2; i &lt;= n; i++) &#123; result.push_back(0); int num, oldnum; for (int j = 1; j &lt;= i; j++) &#123; num = result[j]; for (int k = j + 1; k &lt;= i; k++) &#123; result[j] += result[k]; &#125; if (j &gt; 1) result[j] += oldnum; oldnum = num; &#125; &#125; int r = 0; for (int i = 1; i &lt;= n; i++) r += result[i]; return r; &#125;&#125;; 97 Interleaving String难度：Hard1234567891011121314151617181920212223242526272829303132class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if (s1.size() == 0) return s2 == s3; if (s2.size() == 0) return s1 == s3; if (s1.size() + s2.size() != s3.size()) return false; vector&lt;vector&lt;bool&gt;&gt; check(s1.size() + 1, vector&lt;bool&gt;(s2.size() + 1, false)); check[0][0] = true; for (int i = 1; i &lt;= s1.size(); i++) &#123; check[i][0] = check[i - 1][0] &amp;&amp; (s1[i - 1] == s3[i - 1]); &#125; for (int j = 1; j &lt;= s2.size(); j++) &#123; check[0][j] = check[0][j - 1] &amp;&amp; (s2[j - 1] == s3[j - 1]); &#125; int i = 0, j = 0; for (int l = 1; l &lt;= s3.size(); l++) &#123; for (i = 1; i &lt;= s1.size() &amp;&amp; i &lt;= l; i++) &#123; j = l - i; if (j &gt; s2.size() || j &lt;= 0 ) continue; if (s1[i - 1] == s3[l - 1]) check[i][j] = check[i][j] || check[i - 1][j] ; if (s2[j - 1] == s3[l - 1]) check[i][j] = check[i][j] || check[i][j - 1]; &#125; &#125; return check[s1.size()][s2.size()]; &#125;&#125;; 98 Validate Binary Search Tree难度：Medium123456789101112131415161718192021222324class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; return judgeTree(root, INT_MIN, INT_MAX); &#125;private: bool judgeTree(TreeNode* node, int min, int max) &#123; if (node == NULL) return true; if (node-&gt;val &lt; min || node-&gt;val &gt; max) return false; else if (node-&gt;val == INT_MIN) &#123; if (node-&gt;left) return false; &#125; else if (node-&gt;val == INT_MAX) &#123; if (node-&gt;right) return false; &#125; return judgeTree(node-&gt;left, min, node-&gt;val - 1) &amp;&amp; judgeTree(node-&gt;right, node-&gt;val + 1, max); &#125;&#125;; 99 Recover Binary Search Tree难度：Hard1234567891011121314151617181920212223242526272829303132class Solution &#123;public: TreeNode* first = NULL, *second = NULL, *prev = NULL; void recoverTree(TreeNode* root) &#123; if (root == NULL) return; mid(root); if (first &amp;&amp; second) &#123; int tem = first-&gt;val; first-&gt;val = second-&gt;val; second-&gt;val = tem; &#125; &#125;private: void mid(TreeNode* node) &#123; if (node == NULL) return; mid(node-&gt;left); if (prev) &#123; if (node-&gt;val &lt;= prev-&gt;val) &#123; second = node; if (!first) first = prev; &#125; &#125; prev = node; mid(node-&gt;right); &#125;&#125;; 100 Same Tree难度：Easy12345678910111213141516171819202122class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if (p == NULL || q == NULL) return p == q; return isSame(p, q); &#125;private: bool isSame(TreeNode* p, TreeNode* q) &#123; if (p == NULL || q == NULL) return p == q; if (p-&gt;val != q-&gt;val) return false; return isSame(p-&gt;left, q-&gt;left) &amp;&amp; isSame(p-&gt;right, q-&gt;right); &#125;&#125;; 101 ~ 120 Problems101 Symmetric Tree难度：Easy123456789101112131415161718192021class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if (root == NULL) return true; return isMirror(root-&gt;left, root-&gt;right); &#125;private: bool isMirror(TreeNode* node1, TreeNode* node2) &#123; if (!node1 || !node2) return node1 == node2; if (node1-&gt;val != node2-&gt;val) return false; return isMirror(node1-&gt;left, node2-&gt;right) &amp;&amp; isMirror(node1-&gt;right, node2-&gt;left); &#125;&#125;; 102 Binary Tree Level Order Traversal难度：Medium1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; if (root == NULL) return&#123;&#125;; queue&lt;TreeNode*&gt; q1; q1.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (q1.size() &gt; 0) &#123; int n = q1.size(); vector&lt;int&gt; tem; for (int i = 0; i &lt; n; i++) &#123; tem.push_back(q1.front()-&gt;val); if (q1.front()-&gt;left) q1.push(q1.front()-&gt;left); if (q1.front()-&gt;right) q1.push(q1.front()-&gt;right); q1.pop(); &#125; result.push_back(tem); &#125; return result; &#125;&#125;; 103 Bianry Tree Zigzag Level Order Traversal难度：Medium123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; if (root == NULL) return&#123;&#125;; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;TreeNode*&gt; q1; bool order = true; q1.push_back(root); while (q1.size() &gt; 0) &#123; vector&lt;TreeNode*&gt; q2; for (int i = 0; i &lt; q1.size(); i++) &#123; if (q1[i]-&gt;left) q2.push_back(q1[i]-&gt;left); if (q1[i]-&gt;right) q2.push_back(q1[i]-&gt;right); &#125; vector&lt;int&gt; tem; if (order) &#123; for (int i = 0; i &lt; q1.size(); i++) &#123; tem.push_back(q1[i]-&gt;val); &#125; &#125; else &#123; for (int i = q1.size() - 1; i &gt;= 0; i--) &#123; tem.push_back(q1[i]-&gt;val); &#125; &#125; order = !order; result.push_back(tem); q1 = q2; &#125; return result; &#125;&#125;; 104 Maximum Depth of Binary Tree难度：Easy1234567891011121314151617181920class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (root == NULL) return 0; mid(root, 1); return md; &#125;private: int md = 1; void mid(TreeNode* node, int height) &#123; if (node == NULL) return; if (height &gt; md) md = height; mid(node-&gt;left, height + 1); mid(node-&gt;right, height + 1); &#125;&#125;; 105 Construct Binary Tree from Preorder and Inorder Traversal难度：Medium1234567891011121314151617181920212223242526272829303132class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; if (preorder.size() == 0) return NULL; return getNode(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1); &#125;private: TreeNode* getNode(vector&lt;int&gt;&amp; preorder,int begin1, int end1, vector&lt;int&gt;&amp; inorder, int begin2, int end2) &#123; if (begin1 &gt; end1 || begin2 &gt; end2) return NULL; if (begin1 == end1) &#123; TreeNode* node = new TreeNode(preorder[begin1]); return node; &#125; int r = preorder[begin1]; int i; for (i = begin2; i &lt;= end2; i++) &#123; if (inorder[i] == r) break; &#125; int l = i - begin2; TreeNode* node = new TreeNode(preorder[begin1]); node-&gt;left = getNode(preorder, begin1 + 1, begin1 + l, inorder, begin2, begin2 + l - 1); node-&gt;right = getNode(preorder, begin1 + l + 1, end1, inorder, begin2 + l + 1, end2); return node; &#125;&#125;; 106 Construct Binary Tree from Inorder and Postorder Traversal难度：Medium1234567891011121314151617181920212223242526272829class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; if (inorder.size() == 0) return NULL; return getNode(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1); &#125;private: TreeNode* getNode(vector&lt;int&gt;&amp; inorder, int begin1, int end1, vector&lt;int&gt;&amp; postorder, int begin2, int end2) &#123; if (begin1 &gt; end1 || begin2 &gt; end2) return NULL; if (begin1 == end1) &#123; TreeNode* node = new TreeNode(inorder[begin1]); return node; &#125; int r = postorder[end2]; int l = 0; for (int i = begin1; i &lt;= end1; i++) &#123; if (inorder[i] == r) &#123; l = i - begin1; break; &#125; &#125; TreeNode* node = new TreeNode(postorder[end2]); node-&gt;left = getNode(inorder, begin1, begin1 + l - 1, postorder, begin2, begin2 + l - 1); node-&gt;right = getNode(inorder, begin1 + l + 1, end1, postorder, begin2 + l, end2 - 1); return node; &#125;&#125;; 107 Binary Tree Level Order Traversal II难度：Easy1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; if (root == NULL) return&#123;&#125;; vector&lt;vector&lt;int&gt;&gt; result; pre(result, 1, root); reverse(result.begin(), result.end()); return result; &#125;private: void pre(vector&lt;vector&lt;int&gt;&gt;&amp; result, int height, TreeNode* node) &#123; if (node == NULL) return; if (result.size() &lt; height) &#123; result.push_back(&#123; node-&gt;val &#125;); &#125; else &#123; result[height - 1].push_back(node-&gt;val); &#125; pre(result, height + 1, node-&gt;left); pre(result, height + 1, node-&gt;right); &#125;&#125;; 108 Convert Sorted Array to Binary Search Tree难度：Easy1234567891011121314151617181920212223class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return NULL; return getNode(nums, 0, nums.size() - 1); &#125;private: TreeNode* getNode(vector&lt;int&gt;&amp; nums, int begin, int end) &#123; if (begin &gt; end) return NULL; if (begin == end) &#123; TreeNode* node = new TreeNode(nums[begin]); return node; &#125; int l = (end - begin + 1) / 2; TreeNode* node = new TreeNode(nums[begin + l]); node-&gt;left = getNode(nums, begin, begin + l - 1); node-&gt;right = getNode(nums, begin + l + 1, end); return node; &#125;&#125;; 109 Convert Sorted List to Binary Search Tree难度：Medium12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: TreeNode* sortedListToBST(ListNode* head) &#123; if (head == NULL) return NULL; ListNode* p = head; while (p-&gt;next) p = p-&gt;next; return getNode(head, p); &#125;private: TreeNode* getNode(ListNode* begin, ListNode* end) &#123; if (!begin || end-&gt;val &lt; begin-&gt;val) return NULL; if (begin-&gt;val == end-&gt;val) &#123; TreeNode* node = new TreeNode(begin-&gt;val); return node; &#125; ListNode* mid = begin, *omid; ListNode* p = begin; while (1) &#123; if (p == NULL || p-&gt;val &gt;= end-&gt;val) break; p = p-&gt;next-&gt;next; omid = mid; mid = mid-&gt;next; &#125; TreeNode* node = new TreeNode(mid-&gt;val); node-&gt;left = getNode(begin, omid); node-&gt;right = getNode(mid-&gt;next, end); return node; &#125;&#125;; 110 Balanced Binary Tree难度：Easy123456789101112131415161718192021222324class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; return getHeight(root) &gt;= 0; &#125;private: int getHeight(TreeNode* node) &#123; if (node == NULL) return 0; int hl = 0, hr = 0; hl = getHeight(node-&gt;left); if (hl &lt; 0) return -1; hr = getHeight(node-&gt;right); if (hr &lt; 0) return -1; if (hr - hl &gt; 1 || hl - hr &gt; 1) return -1; return max(hr, hl) + 1; &#125;&#125;; 111 Minimum Depth of Binary Tree难度：Easy12345678910111213141516171819class Solution &#123;public: int minDepth(TreeNode* root) &#123; if (root == NULL) return 0; dfs(root,1); return minh; &#125;private: int minh = INT_MAX; void dfs(TreeNode* node, int h) &#123; if (node-&gt;left) dfs(node-&gt;left,h+1); if (node-&gt;right) dfs(node-&gt;right, h + 1); if (!node-&gt;left &amp;&amp; !node-&gt;right) minh = min(h, minh); &#125;&#125;; 112 Path Sum难度：Easy123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if (root == NULL) return false; this-&gt;sum = sum; dfs(root); return exist; &#125;private: int sum; int s = 0; bool exist = false; void dfs(TreeNode* node) &#123; if (!exist) &#123; s += node-&gt;val; if (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; s == sum) exist = true; else &#123; if (node-&gt;left) dfs(node-&gt;left); if (node-&gt;right) dfs(node-&gt;right); &#125; s -= node-&gt;val; &#125; &#125;&#125;; 113 Path Sum II难度：Medium12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; if (root == NULL) return&#123;&#125;; this-&gt;sum = sum; getPath(root); return result; &#125;private: vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; result; int sum; int s = 0; void getPath(TreeNode* node) &#123; s += node-&gt;val; path.push_back(node-&gt;val); if (s == sum &amp;&amp; !node-&gt;left &amp;&amp; !node-&gt;right) result.push_back(path); if (node-&gt;left) getPath(node-&gt;left); if (node-&gt;right) getPath(node-&gt;right); s -= node-&gt;val; path.pop_back(); &#125;&#125;; 114 Flatten Bianry Tree to Linked List难度：Medium123456789101112131415161718192021222324252627282930class Solution &#123;public: void flatten(TreeNode* root) &#123; if (root) conn(root); &#125;private: TreeNode* conn(TreeNode* node) &#123; if (!node-&gt;left &amp;&amp; !node-&gt;right) return node; TreeNode *lp = node-&gt;left, *rp = node-&gt;right; if (node-&gt;left) lp = conn(node-&gt;left); if (node-&gt;right) rp = conn(node-&gt;right); if (lp) &#123; lp-&gt;right = node-&gt;right; node-&gt;right = node-&gt;left; node-&gt;left = NULL; &#125; if (rp) return rp; else return lp; &#125;&#125;; 115 Distinct Subsequences难度：Hard123456789101112131415161718192021222324class Solution &#123;public: int numDistinct(string s, string t) &#123; if (s.size() &lt; t.size()) return 0; vector&lt;vector&lt;int&gt;&gt; data(t.size() + 1, vector&lt;int&gt;(s.size() + 1, 0)); for (int i = 0; i &lt;= s.size(); i++) data[0][i] = 1; for (int n = 1; n &lt;= t.size(); n++) &#123; for (int m = n; m &lt;= s.size(); m++) &#123; if (s[m - 1] == t[n - 1]) &#123; data[n][m] = data[n][m - 1] + data[n - 1][m - 1]; //s[m]¿ÉÒÔºÍt[n]Æ¥£¬Ò²¿ÉÒÔ²»ºÍt[n]Æ¥Åä &#125; else &#123; data[n][m] = data[n][m - 1]; //ÊÇs[m]²»ºÍt[n]Æ¥Åä &#125; &#125; &#125; return data[t.size()][s.size()]; &#125;&#125;; 116 Populating Next Right Pointers in Each Node难度：Medium123456789101112131415class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (root == NULL) return; if (root-&gt;left) &#123; root-&gt;left-&gt;next = root-&gt;right; if (root-&gt;next) &#123; root-&gt;right-&gt;next = root-&gt;next-&gt;left; &#125; &#125; connect(root-&gt;left); connect(root-&gt;right); &#125;&#125;; 117 Populating Next Right Pointers in Each Node II难度：Medium1234567891011121314151617181920212223242526272829303132class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (root == NULL) return; TreeLinkNode* p = root-&gt;next, *next = NULL; while (p &amp;&amp; !p-&gt;left &amp;&amp; !p-&gt;right) p = p-&gt;next; if (p) &#123; if (p-&gt;left) next = p-&gt;left; else if (p-&gt;right) next = p-&gt;right; &#125; if (root-&gt;left &amp;&amp; root-&gt;right) &#123; root-&gt;left-&gt;next = root-&gt;right; root-&gt;right-&gt;next = next; &#125; else if (root-&gt;right) &#123; root-&gt;right-&gt;next = next; &#125; else if (root-&gt;left) &#123; root-&gt;left-&gt;next = next; &#125; connect(root-&gt;right); connect(root-&gt;left); &#125;&#125;; 118 Pascal’s Triangle难度：Easy1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; if (numRows == 0) return&#123;&#125;; vector&lt;vector&lt;int&gt;&gt; result; result.push_back(&#123; 1 &#125;); if (numRows == 1) return result; result.push_back(&#123; 1,1 &#125;); for (int i = 2; i &lt; numRows; i++) &#123; vector&lt;int&gt; tem; tem.push_back(1); for (int j = 1; j &lt; result[i - 1].size(); j++) &#123; tem.push_back(result[i - 1][j - 1] + result[i - 1][j]); &#125; tem.push_back(1); result.push_back(tem); &#125; return result; &#125;&#125;; 119 Pcscal’s Triangle II难度：Easy123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;vector&lt;int&gt;&gt; result(2, vector&lt;int&gt;(1, 1)); result[1].push_back(1); bool now = false; if (rowIndex == 0) return result[now]; now = !now; if (rowIndex == 1) return result[now]; for (int i = 2; i &lt;= rowIndex; i++) &#123; result[!now] = vector&lt;int&gt;(1, 1); for (int j = 1; j &lt; result[now].size(); j++) &#123; result[!now].push_back(result[now][j - 1] + result[now][j]); &#125; result[!now].push_back(1); now = !now; &#125; return result[now]; &#125;&#125;; 120 Triangle难度：Medium123456789101112131415161718192021222324252627282930class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; int n = triangle.size(); if (n &lt;= 0) return 0; int l = triangle[n - 1].size(); vector&lt;vector&lt;int&gt;&gt; result(2, vector&lt;int&gt;(l, 0)); bool now = false; result[now] = triangle[0]; now = !now; for (int i = 1; i &lt; triangle.size(); i++) &#123; for (int j = 0; j &lt; triangle[i].size(); j++) &#123; if (j == 0) result[now][j] = result[!now][j] + triangle[i][j]; else if (j == triangle[i].size() - 1) result[now][j] = result[!now][j - 1] + triangle[i][j]; else result[now][j] = min(result[!now][j], result[!now][j - 1]) + triangle[i][j]; &#125; now = !now; &#125; int min = result[!now][0]; for (int i = 1; i &lt; result[!now].size(); i++) &#123; if (result[!now][i] &lt; min) min = result[!now][i]; &#125; return min; &#125;&#125;; 121 ~ 140 Problems121 Best Time to Buy and Sell Stock难度：Easy1234567891011121314151617181920212223class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.size() == 0) return 0; int profit = 0; int begin = 0, end = 0; while (end &lt; prices.size()) &#123; if (prices[end] &lt; prices[begin]) &#123; begin = end; &#125; else &#123; if (prices[end] - prices[begin] &gt; profit) &#123; profit = prices[end] - prices[begin]; &#125; &#125; end++; &#125; return profit; &#125;&#125;; 122 Best Time to Buy and Sell Stock II难度：Easy1234567891011121314151617181920212223242526class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.size() &lt;= 1) return 0; int profit = 0; int begin = 0, end = 1; int n = prices.size(); while (begin &lt; prices.size()) &#123; while (begin + 1 &lt; prices.size() &amp;&amp; prices[begin] &gt;= prices[begin + 1]) begin++; end = begin + 1; while (end + 1 &lt; prices.size() &amp;&amp; prices[end + 1] &gt;= prices[end]) end++; if (end &lt; prices.size() &amp;&amp; begin &lt; prices.size()) profit += prices[end] - prices[begin]; begin = end + 1; &#125; return profit; &#125;&#125;; 123 Best Time to Buy and Sell Stock III难度：Hard12345678910111213141516171819202122class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int buy1 = INT_MIN, sell1 = 0; int buy2 = INT_MIN, sell2 = 0; for (int price : prices) &#123; // µÚÒ»´Î¹ºÂò if (buy1 &lt; -price) buy1 = -price; // µÚÒ»´ÎÂô³öÈ¥µÄ¿ÉÄÜµÄ×î´óÀûÈó if (sell1 &lt; buy1 + price) sell1 = buy1 + price; //×¢ÒâµÚ¶þ´ÎµÄÀûÈóÒÑ¾­°üº¬µÚÒ»´ÎµÄÁË //Í¬Àí£¬µÚ¶þ´Î¹ºÂò,×¢ÒâÕâÀïÊÇ if (buy2 &lt; sell1 - price) buy2 = sell1 - price; //×îºóÒ»´Î if (sell2 &lt; buy2 + price) sell2 = buy2 + price; &#125; return sell2; &#125;&#125;; 124 Binary Tree Maximum Path Sum难度：Hard123456789101112131415161718192021222324252627class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; if (root == NULL) return 0; maxOnePath(root); return maxSum; &#125;private: int maxSum = INT_MIN; int maxOnePath(TreeNode* node) &#123; if (node == NULL) return 0; int n1 = maxOnePath(node-&gt;left); int n2 = maxOnePath(node-&gt;right); int x = 0; if (n1 &gt; 0) x += n1; if (n2 &gt; 0) x += n2; x += node-&gt;val; if (x &gt; maxSum) maxSum = x; if (n1 &lt;= 0 &amp;&amp; n2 &lt;= 0) return node-&gt;val; else return max(n1, n2) + node-&gt;val; &#125;&#125;; 125 Valid Palindrome难度：Easy1234567891011121314151617181920212223242526272829303132class Solution &#123;public: bool isPalindrome(string s) &#123; if (s.size() == 0) return true; int begin = 0, end = s.size() - 1; while (begin &lt; end) &#123; int c1, c2; while (begin &lt; end &amp;&amp; (c1 = getLow(s[begin])) &lt; 0) &#123; begin++; &#125; while (begin &lt; end &amp;&amp; (c2 = getLow(s[end])) &lt; 0) &#123; end--; &#125; if (c1 != c2 &amp;&amp; begin &lt; end) return false; begin++; end--; &#125; return true; &#125;private: int getLow(char c) &#123; if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') return c; else if (c &gt;= '0' &amp;&amp; c &lt;= '9') return c; else if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') return c + 32; else return -1; &#125;&#125;; 127 Word Ladder难度：Medium1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123;public: int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; if (wordList.size() == 0) return 0; int endnum = -1; for (int i = 0; i &lt; wordList.size(); i++) &#123; if (wordList[i] == endWord) &#123; endnum = i; break; &#125; &#125; if (endnum &lt; 0) return 0; int n = wordList.size(); vector&lt;vector&lt;bool&gt;&gt; trans(n, vector&lt;bool&gt;(n, 0)); vector&lt;bool&gt; already(n, 1); for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (couldTrans(wordList[i], wordList[j])) &#123; trans[i][j] = trans[j][i] = 1; &#125; &#125; &#125; int length = 2; set&lt;int&gt; find; for (int i = 0; i &lt; n; i++) &#123; if (couldTrans(beginWord, wordList[i])) &#123; if (i == endnum) return length; if (already[i]) &#123; find.insert(i); already[i] = false; &#125; &#125; &#125; while (find.size() &gt; 0) &#123; set&lt;int&gt; tem; length++; for (auto p = find.begin(); p != find.end(); p++) &#123; for (int i = 0; i &lt; n; i++) &#123; if (trans[*p][i]) &#123; if (already[i]) &#123; tem.insert(i); already[i] = false; if (i == endnum) return length; &#125; &#125; &#125; &#125; find = tem; &#125; return 0; &#125;private: bool couldTrans(string&amp; s1, string&amp; s2) &#123; if (s1.size() != s2.size()) return false; int n = s1.size(); int num = 0; for (int i = 0; i &lt; n; i++) &#123; if (s1[i] != s2[i]) &#123; num++; if (num &gt; 1) return false; &#125; &#125; return true; &#125;&#125;; 128 Longest Consecutive Sequence难度：Hard123456789101112131415161718192021222324class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 0; unordered_set&lt;int&gt; data(nums.begin(), nums.end()); int length = 1; for (int num : nums) &#123; if (data.find(num) == data.end()) continue; data.erase(num); int begin = num - 1, end = num + 1; while (data.find(begin) != data.end()) data.erase(begin--); while (data.find(end) != data.end()) data.erase(end++); length = max(length, end - begin - 1); &#125; return length; &#125;&#125;; 129 Sum Root to Leaf Numbers难度：Medium1234567891011121314151617181920212223class Solution &#123;public: int sum = 0; int sumNumbers(TreeNode* root) &#123; deepSearch(root,0); return sum; &#125; void deepSearch(TreeNode* node,int num) &#123; num = num * 10 + node-&gt;val; if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; sum += num; return; &#125; else &#123; if (node-&gt;left) deepSearch(node-&gt;left, num); if (node-&gt;right) deepSearch(node-&gt;right, num); &#125; &#125;&#125;; 130 Surrounded Regions难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if (board.size() == 0) return; for (int k = 0; k &lt; board[0].size(); k++) &#123; breadthSearch(0, k, board); &#125; for (int k = 0; k &lt; board[0].size(); k++) &#123; breadthSearch(board.size() - 1, k, board); &#125; for (int k = 0; k &lt; board.size(); k++) &#123; breadthSearch(k, 0, board); &#125; for (int k = 0; k &lt; board.size(); k++) &#123; breadthSearch(k, board[0].size() - 1, board); &#125; for (int i = 0; i &lt; board.size(); i++) &#123; for (int j = 0; j &lt; board[0].size(); j++) &#123; if (board[i][j] == 'Z') board[i][j] = 'O'; else board[i][j] = 'X'; &#125; &#125; &#125; void breadthSearch(int i, int j, vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if (board[i][j] == 'X' || board[i][j] == 'Z') return; board[i][j] = 'Z'; if (j &gt; 1) &#123; breadthSearch(i, j - 1, board); &#125; if (j &lt; board[0].size() - 1) &#123; breadthSearch(i, j + 1, board); &#125; if (i &gt; 1) &#123; breadthSearch(i - 1, j, board); &#125; if (i &lt; board.size() - 1) &#123; breadthSearch(i + 1, j, board); &#125; &#125;&#125;; 131 Palindrome Partitioning难度：Medium123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; if (s.size() == 0) return&#123;&#125;; check = vector&lt;vector&lt;bool&gt;&gt;(s.size(), vector&lt;bool&gt;(s.size(), 0)); for (int i = 0; i &lt; s.size(); i++) check[i][i] = true; for (int i = 0; i &lt; s.size() - 1; i++) check[i][i + 1] = s[i] == s[i + 1]; for (int l = 2; l &lt; s.size(); l++) &#123; for (int i = 0; i + l &lt; s.size(); i++) &#123; check[i][i + l] = check[i + 1][i + l - 1] &amp;&amp; (s[i] == s[i + l]); &#125; &#125; vector&lt;string&gt; tem; getResult(s, 0, tem); return result; &#125;private: vector&lt;vector&lt;bool&gt;&gt; check; vector&lt;vector&lt;string&gt;&gt; result; void getResult(string&amp; s, int begin, vector&lt;string&gt;&amp; tem) &#123; if (begin &gt;= s.size()) &#123; result.push_back(tem); return; &#125; for (int i = begin; i &lt; s.size(); i++) &#123; if (check[begin][i]) &#123; string str = s.substr(begin, i - begin + 1); tem.push_back(str); getResult(s, i + 1, tem); tem.pop_back(); &#125; &#125; &#125;&#125;; 132 Plaindrome Partitioning II难度：Hard1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int minCut(string s) &#123; if (s.size() == 0) return 0; check = vector&lt;vector&lt;bool&gt;&gt;(s.size(), vector&lt;bool&gt;(s.size(), 0)); for (int i = 0; i &lt; s.size(); i++) check[i][i] = true; for (int i = 0; i &lt; s.size() - 1; i++) check[i][i + 1] = s[i] == s[i + 1]; for (int l = 2; l &lt; s.size(); l++) &#123; for (int i = 0; i + l &lt; s.size(); i++) &#123; check[i][i + l] = check[i + 1][i + l - 1] &amp;&amp; (s[i] == s[i + l]); &#125; &#125; vector&lt;int&gt; cut(s.size(), 0); for (int i = 0; i &lt; s.size(); i++) &#123; if (check[0][i]) cut[i] = 0; else &#123; int m = INT_MAX; for (int j = 1; j &lt;= i; j++) &#123; if (check[j][i] &amp;&amp; m &gt; cut[j - 1] + 1) &#123; m = cut[j - 1] + 1; &#125; &#125; cut[i] = m; &#125; &#125; return cut[s.size() - 1]; &#125;private: vector&lt;vector&lt;bool&gt;&gt; check;&#125;; 133 Clone Graph难度：Medium1234567891011121314class Solution &#123;public: UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) &#123; if (!node) return NULL; if (mp.find(node) == mp.end()) &#123; mp[node] = new UndirectedGraphNode(node-&gt;label); for (UndirectedGraphNode* neigh : node-&gt;neighbors) mp[node]-&gt;neighbors.push_back(cloneGraph(neigh)); &#125; return mp[node]; &#125;private: unordered_map&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; mp;&#125;; 134 Gas Station难度：Medium12345678910111213141516171819202122232425262728class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; if (gas.size() == 0) return -1; if (gas.size() == 1) return gas[0] &gt;= cost[0] ? 0 : -1; int begin = 0, end = 0; int total = 0; total += gas[end] - cost[end]; end = end == gas.size() - 1 ? 0 : end + 1; while (begin != end) &#123; while (total &gt;= 0 &amp;&amp; begin != end) &#123; total += gas[end] - cost[end]; end = end == gas.size() - 1 ? 0 : end + 1; &#125; while (total &lt; 0 &amp;&amp; begin != end) &#123; begin = begin == 0 ? gas.size() - 1 : begin - 1; total += gas[begin] - cost[begin]; &#125; &#125; if (total &gt;= 0) return begin; else return -1; &#125;&#125;; 135 Candy难度：Hard123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int result = 0; if (ratings.size() == 0) return result; int begin = 0, end = 0; int now = 1, i = 0, high = 1; while (i &lt; ratings.size()) &#123; result += now; if (i + 1 &lt; ratings.size() &amp;&amp; ratings[i + 1] &gt; ratings[i]) &#123; begin = i + 1; end = begin; now += 1; high = now; &#125; else if (i + 1 &lt; ratings.size() &amp;&amp; ratings[i + 1] &lt; ratings[i]) &#123; now = 1; result += end - begin; if (now + end - begin &gt;= high) &#123; high += 1; result += 1; &#125; end = i + 1; &#125; else if (i + 1 &lt; ratings.size() &amp;&amp; ratings[i + 1] == ratings[i]) &#123; now = 1; begin = i + 1; end = begin; high = 1; &#125; i++; &#125; return result; &#125;&#125;; 136 Single Number难度：Easy12345678910class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int result = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; result ^= nums[i]; &#125; return result; &#125;&#125;; 137 Single Number II难度：Medium1234567891011121314151617class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int result = 0; for (int i = 0; i &lt; 32; i++) &#123; int tem = 1 &lt;&lt; i; int num = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] &amp; tem) num++; &#125; if (num % 3) result |= tem; &#125; return result; &#125;&#125;; 138 Copy List With Random Pointer难度：Medium123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; if (!head) return NULL; RandomListNode *node = head; while (node) &#123; RandomListNode *new_node = new RandomListNode(node-&gt;label); new_node-&gt;next = node-&gt;next; node-&gt;next = new_node; node = new_node-&gt;next; &#125; node = head; while (node) &#123; RandomListNode* new_node = node-&gt;next; new_node-&gt;random = node-&gt;random == NULL ? NULL : node-&gt;random-&gt;next; node = new_node-&gt;next; &#125; node = head; RandomListNode *new_head = node-&gt;next; RandomListNode* new_node = node-&gt;next; while (node) &#123; RandomListNode* next_node = new_node-&gt;next; node-&gt;next = next_node; new_node-&gt;next = next_node ? next_node-&gt;next : NULL; node = next_node; new_node = next_node ? next_node-&gt;next : NULL; &#125; return new_head; &#125;&#125;; 139 Word Break难度：Medium1234567891011121314151617181920class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; if (wordDict.size() &lt;= 0) return false; unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); vector&lt;bool&gt; check(s.size() + 1, false); check[0] = true; for (int i = 1; i &lt;= s.size(); i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (check[j] &amp;&amp; wordSet.find(s.substr(j, i - j)) != wordSet.end()) &#123; check[i] = true; break; &#125; &#125; &#125; return check[s.size()]; &#125;&#125;; 140 Word Break II难度：Hard123456789101112131415161718192021222324252627282930class Solution &#123; unordered_map&lt;string, vector&lt;string&gt;&gt; m; vector&lt;string&gt; combine(string word, vector&lt;string&gt; prev) &#123; for (int i = 0; i&lt;prev.size(); ++i) &#123; prev[i] += \" \" + word; &#125; return prev; &#125;public: vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; dict(wordDict.begin(), wordDict.end()); if (m.count(s)) return m[s]; //take from memory vector&lt;string&gt; result; if (dict.count(s)) &#123; //a whole string is a word result.push_back(s); &#125; for (int i = 1; i&lt;s.size(); ++i) &#123; string word = s.substr(i); if (dict.count(word)) &#123; string rem = s.substr(0, i); vector&lt;string&gt; prev = combine(word, wordBreak(rem, wordDict)); result.insert(result.end(), prev.begin(), prev.end()); &#125; &#125; m[s] = result; //memorize return result; &#125;&#125;; 141 ~ 160 Problems141 Linked List Cycle难度：Easy12345678910111213141516171819class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if (!head || !head-&gt;next || !head-&gt;next-&gt;next) return false; ListNode *p1 = head, *p2 = head; p1 = head-&gt;next; p2 = p1-&gt;next; while (p1 != p2) &#123; if (!p2 || !p2-&gt;next) return false; p2 = p2-&gt;next-&gt;next; p1 = p1-&gt;next; &#125; return true; &#125;&#125;; 142 Linked List Cycle II难度：Medium12345678910111213141516171819202122class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (!head || !head-&gt;next || !head-&gt;next-&gt;next) return NULL; ListNode* p1 = head-&gt;next, *p2 = head-&gt;next-&gt;next; while (p1 != p2) &#123; if (!p2 || !p2-&gt;next) return NULL; p1 = p1-&gt;next; p2 = p2-&gt;next-&gt;next; &#125; p1 = head; while (p1 != p2) &#123; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; return p1; &#125;&#125;; 143 Reorder List难度：Medium12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: void reorderList(ListNode* head) &#123; if (!head || !head-&gt;next || !head-&gt;next-&gt;next) return; ListNode *fast = head, *slow = head; while (fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next; if (!fast-&gt;next) break; fast = fast-&gt;next; &#125; ListNode* head2 = slow-&gt;next; ListNode* tail = fast; slow-&gt;next = NULL; ListNode *p1 = head2, *p2 = head2-&gt;next, *p3 = head2; while (p2) &#123; p3 = p2-&gt;next; p2-&gt;next = p1; p1 = p2; p2 = p3; &#125; head2-&gt;next = NULL; ListNode *m1 = head, *n1 = tail, *m2,*n2; while (m1 &amp;&amp; n1) &#123; m2 = m1-&gt;next; n2 = n1-&gt;next; m1-&gt;next = n1; n1-&gt;next = m2; m1 = m2; n1 = n2; &#125; &#125;&#125;; 144 Binary Tree Perorder Travelsal难度：Medium1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; if (!root) return&#123;&#125;; stack&lt;TreeNode*&gt; nodeStack; vector&lt;int&gt; result; TreeNode* node = root; while (node || nodeStack.size()) &#123; while (node) &#123; result.push_back(node-&gt;val); if (node-&gt;right) nodeStack.push(node-&gt;right); node = node-&gt;left; &#125; node = nodeStack.size() &gt; 0 ? nodeStack.top() : NULL; if (nodeStack.size() &gt; 0) nodeStack.pop(); &#125; return result; &#125;&#125;; 145 Binary Tree Postorder Travelsal难度：Medium1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; if (!root) return&#123;&#125;; stack&lt;TreeNode*&gt; *nodeStack = new stack&lt;TreeNode*&gt;(); vector&lt;int&gt; result; TreeNode* node = root; nodeStack-&gt;push(node); while (nodeStack-&gt;size() &gt; 0) &#123; if (node-&gt;right &amp;&amp; node-&gt;left) &#123; nodeStack-&gt;push(node-&gt;right); nodeStack-&gt;push(node-&gt;left); node = node-&gt;left; &#125; else if (node-&gt;left) &#123; nodeStack-&gt;push(node-&gt;left); node = node-&gt;left; &#125; else if (node-&gt;right) &#123; nodeStack-&gt;push(node-&gt;right); node = node-&gt;right; &#125; else &#123; result.push_back(node-&gt;val); if (nodeStack-&gt;size() &gt; 0) nodeStack-&gt;pop(); while (nodeStack-&gt;size() &gt; 0 &amp;&amp; (nodeStack-&gt;top()-&gt;left == node || nodeStack-&gt;top()-&gt;right == node)) &#123; result.push_back(nodeStack-&gt;top()-&gt;val); node = nodeStack-&gt;top(); nodeStack-&gt;pop(); &#125; if (nodeStack-&gt;size() &gt; 0) &#123; node = nodeStack-&gt;top(); &#125; &#125; &#125; return result; &#125;&#125;; 146 LRU Cache难度：Medium123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118class LRUCache &#123;public: Node* head; Node* tail; unordered_map&lt;int, Node*&gt; Map; int Cap; int nowCap = 0; LRUCache(int capacity) &#123; head = new Node(0,0); Cap = capacity; &#125; int get(int key) &#123; if (Map.find(key) != Map.end()) &#123; if (nowCap == 1) &#123; return Map[key]-&gt;value; &#125; Node* node = Map[key]; if (node == tail) &#123; tail = node-&gt;last; &#125; Node* first = node-&gt;last; Node* second = node-&gt;next; if (!second) &#123; first-&gt;next = NULL; &#125; else &#123; first-&gt;next = second; second-&gt;last = first; &#125; second = head-&gt;next; node-&gt;last = head; node-&gt;next = second; head-&gt;next = node; second-&gt;last = node; return Map[key]-&gt;value; &#125; else return -1; &#125; void put(int key, int value) &#123; if (Map.find(key) != Map.end()) &#123; if (nowCap == 1) &#123; Map[key]-&gt;value = value; return; &#125; Node* node = Map[key]; if (node == tail) &#123; tail = node-&gt;last; &#125; node-&gt;value = value; Node* first = node-&gt;last; Node* second = node-&gt;next; if (!second) &#123; first-&gt;next = NULL; &#125; else &#123; first-&gt;next = second; second-&gt;last = first; &#125; second = head-&gt;next; node-&gt;last = head; node-&gt;next = second; head-&gt;next = node; second-&gt;last = node; &#125; else &#123; if (nowCap &lt; Cap) &#123; nowCap++; Node* node = new Node(key, value); Node* first = head-&gt;next; head-&gt;next = node; node-&gt;last = head; if (first) &#123; node-&gt;next = first; first-&gt;last = node; &#125; if (nowCap == 1) &#123; tail = node; &#125; Map.insert(&#123; key,node &#125;); &#125; else &#123; Node* node = new Node(key, value); Node* first = head-&gt;next; head-&gt;next = node; node-&gt;last = head; if (nowCap == 1) &#123; delete tail; tail = node; return; &#125; else &#123; node-&gt;next = first; first-&gt;last = node; &#125; Map.erase(tail-&gt;key); tail = tail-&gt;last; delete tail-&gt;next; tail-&gt;next = NULL; Map.insert(&#123; key,node &#125;); &#125; &#125; &#125;&#125;; 147 Insertion Sort List难度：Medium123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if (head == NULL) return head; ListNode* title = new ListNode(0); ListNode* tail = title; ListNode* newHead = new ListNode(0); newHead-&gt;next = head; int min; ListNode* node = newHead; ListNode* minLast, *minNode; while (newHead-&gt;next) &#123; minLast = newHead; minNode = newHead-&gt;next; min = minNode-&gt;val; while (node-&gt;next) &#123; if (node-&gt;next-&gt;val &lt; min) &#123; minLast = node; minNode = node-&gt;next; min = node-&gt;next-&gt;val; &#125; node = node-&gt;next; &#125; minLast-&gt;next = minNode-&gt;next; tail-&gt;next = minNode; minNode-&gt;next = NULL; tail = tail-&gt;next; node = newHead; &#125; return title-&gt;next; &#125;&#125;;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://uyouii.github.io/categories/algorithm/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://uyouii.github.io/tags/c/"},{"name":"algorithm","slug":"algorithm","permalink":"https://uyouii.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"https://uyouii.github.io/tags/leetcode/"}]},{"title":"libevent 服务端客户端 简单实例","slug":"libevent-服务端客户端-简单实例","date":"2017-12-12T03:26:17.000Z","updated":"2019-08-02T03:28:18.916Z","comments":true,"path":"2017/12/12/libevent-服务端客户端-简单实例/","link":"","permalink":"https://uyouii.github.io/2017/12/12/libevent-服务端客户端-简单实例/","excerpt":"","text":"最近了解了下libevent，简单的实现了一个客户端服务端通信的demo，服务端会转发客户端发送的数据包给其他客户端，并测试每秒转发的数据量和数据包的个数。 包格式简单的定义了数据包头的格式，12个字节，包含三个变量，分别是targetID（目的地的id），sourceID（源id）和length（数据的长度，不包含header的长度）。 暂时client的id分配由服务器分配，客户端编号从1开始，id为0代表是服务器发送的原始消息，不是转发的其他客户端发送的数据。 数据发送客户端每隔一段时间发送一个数据包给其他客户端，服务器收到数据包后转发给其他客户端。 为了测试libevent的最大负载，现在设置只要客户端检测到write_buffer为空，则向其中填入SEND_TIMES个packet。 目前测试结果为再最大负载的情况下，多个client同时向服务器发送packet，平均结果为服务器每秒转发40000个packet 代码服务端12345678910111213141516171819202122#ifndef _MESSAGE_H_#define _MESSAGE_H_#include&lt;string&gt;using namespace std;typedef struct msg_header &#123; unsigned int targetID; unsigned int sourceID; unsigned int length;&#125; Header;void listener_cb(struct evconnlistener *, evutil_socket_t, struct sockaddr *, int socklen, void *);void conn_writecb(struct bufferevent *, void *);void conn_readcb(struct bufferevent *, void *);void conn_eventcb(struct bufferevent *, short, void *);unsigned int get_client_id(struct bufferevent*);string inttostr(int);void write_buffer(string&amp;, struct bufferevent*, Header&amp;);#endif // !_MESSAGE_H_ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;event2/bufferevent.h&gt; #include &lt;event2/buffer.h&gt; #include &lt;event2/listener.h&gt; #include &lt;event2/util.h&gt; #include &lt;event2/event.h&gt; #include &lt;vector&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include \"message.h\"using namespace std;#define PORT 1234#define HEADER_LENGTH 12#define BUFFER_SIZE (16 * 1024) #define READ_SIZE (16 * 1024)#define MAX_PACKET_SIZE 256#define TIME_INTERVAL 5000const char ip_address[] = \"127.0.0.1\";map&lt;unsigned int, bufferevent*&gt; ClientMap; //client id 对应的buffereventint conectNumber = 0;int dataSize = 0;int lastTime = 0;int receiveNumber = 0;int sendNumber = 0;int main(int argc, char **argv) &#123;#ifdef WIN32 WSAData wsaData; WSAStartup(MAKEWORD(2, 0), &amp;wsaData);#endif cout &lt;&lt; \"Server begin running!\" &lt;&lt; endl; struct sockaddr_in sin; memset(&amp;sin, 0, sizeof(sin)); sin.sin_family = AF_INET; sin.sin_addr.S_un.S_addr = inet_addr(ip_address); sin.sin_port = htons(PORT); struct evconnlistener *listener; struct event_base *base = event_base_new(); if (!base) &#123; cout &lt;&lt; \"Could not initialize libevent\" &lt;&lt; endl;; return 1; &#125; //默认情况下，链接监听器接收新套接字后，会将其设置为非阻塞的 listener = evconnlistener_new_bind(base, listener_cb, (void *)base, LEV_OPT_REUSEABLE | LEV_OPT_CLOSE_ON_FREE, -1, (struct sockaddr*)&amp;sin, sizeof(sin)); if (!listener) &#123; cout &lt;&lt; \"Could not create a listener\" &lt;&lt; endl; return 1; &#125; event_base_dispatch(base); evconnlistener_free(listener); event_base_free(base); return 0;&#125;void listener_cb(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *sa, int socklen, void *user_data) &#123; cout &lt;&lt; \"Detect an connection\" &lt;&lt; endl; struct event_base *base = (struct event_base *)user_data; struct bufferevent *bev; //BEV_OPT_CLOSE_ON_FREE close the file descriptor when this bufferevent is freed bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); if (!bev) &#123; cout &lt;&lt; \"Could not create a bufferevent\" &lt;&lt; endl; event_base_loopbreak(base); return; &#125; ClientMap[++conectNumber] = bev; //read write event bufferevent_setcb(bev, conn_readcb, NULL, conn_eventcb, NULL); bufferevent_enable(bev, EV_READ | EV_WRITE); //send a message to client when connect is succeeded string msg = \"connedted\"; Header header; header.sourceID = 0; header.targetID = conectNumber; header.length = msg.size(); write_buffer(msg, bev, header);&#125;void conn_writecb(struct bufferevent *bev, void *user_data) &#123; Sleep(2000); int len = 0; Header header; unsigned int toID = get_client_id(bev); string msg = \"hello client \" + inttostr(toID); header.targetID = toID; header.sourceID = 0; header.length = msg.size(); write_buffer(msg, bev, header);&#125;void conn_readcb(struct bufferevent *bev, void *user_data) &#123; struct evbuffer *input = bufferevent_get_input(bev); size_t sz = evbuffer_get_length(input); unsigned int sourceID = get_client_id(bev); while (sz &gt;= MAX_PACKET_SIZE) &#123; char msg[MAX_PACKET_SIZE] = &#123; 0 &#125;; char *ptr = msg; bufferevent_read(bev, ptr, HEADER_LENGTH); unsigned int len = ((Header*)ptr)-&gt;length; unsigned int targetID = ((Header*)ptr)-&gt;targetID; ((Header*)ptr)-&gt;sourceID = sourceID; ptr += HEADER_LENGTH; if (sz &lt; len + HEADER_LENGTH) &#123; break; &#125; bufferevent_read(bev, ptr, len); receiveNumber++; dataSize += len + HEADER_LENGTH; if (ClientMap.find(targetID) != ClientMap.end()) &#123; sendNumber++; bufferevent_write(ClientMap[targetID], msg, len + HEADER_LENGTH); &#125; else &#123; //can't find &#125; sz = evbuffer_get_length(input); &#125; //calculate the speed of data and packet clock_t nowtime = clock(); if (lastTime == 0) &#123; lastTime = nowtime; &#125; else &#123; cout &lt;&lt; \"client number: \" &lt;&lt; ClientMap.size() &lt;&lt; \" \"; cout &lt;&lt; \"data speed: \" &lt;&lt; (double)dataSize / (nowtime - lastTime) &lt;&lt; \"k/s \"; cout &lt;&lt; \"packet speed: receive \" &lt;&lt; (double)receiveNumber / (nowtime - lastTime) &lt;&lt; \"k/s \"; cout &lt;&lt; \"send \" &lt;&lt; (double)sendNumber / (nowtime - lastTime) &lt;&lt; \"k/s\" &lt;&lt; endl; if (nowtime - lastTime &gt; TIME_INTERVAL) &#123; dataSize = 0; lastTime = nowtime; receiveNumber = 0; sendNumber = 0; &#125; &#125;&#125;void conn_eventcb(struct bufferevent *bev, short events, void *user_data) &#123; if (events &amp; BEV_EVENT_EOF) &#123; cout &lt;&lt; \"Connection closed\" &lt;&lt; endl; &#125; else if (events &amp; BEV_EVENT_ERROR) &#123; cout &lt;&lt; \"Got an error on the connection: \" &lt;&lt; strerror(errno) &lt;&lt; endl; &#125; bufferevent_free(bev);&#125;unsigned int get_client_id(struct bufferevent* bev) &#123; for (auto p = ClientMap.begin(); p != ClientMap.end(); p++) &#123; if (p-&gt;second == bev) &#123; return p-&gt;first; &#125; &#125; return 0;&#125;void write_buffer(string&amp; msg, struct bufferevent* bev, Header&amp; header) &#123; char send_msg[BUFFER_SIZE] = &#123; 0 &#125;; char* ptr = send_msg; int len = 0; memcpy(ptr, &amp;header, sizeof(Header)); len += sizeof(Header); ptr += sizeof(Header); memcpy(ptr, msg.c_str(), msg.size()); len += msg.size(); bufferevent_write(bev, send_msg, len);&#125;string inttostr(int num) &#123; string result; bool neg = false; if (num &lt; 0) &#123; neg = true; num = -num; &#125; if (num == 0) &#123; result += '0'; &#125; else &#123; while (num &gt; 0) &#123; int rem = num % 10; result = (char)(rem + '0') + result; num /= 10; &#125; &#125; if (neg) &#123; result = '-' + result; &#125; return result;&#125; 客户端1234567891011121314151617181920#ifndef _MESSAGE_H_#define _MESSAGE_H_#include&lt;string&gt;using namespace std;typedef struct msg_header &#123; unsigned int targetID; unsigned int sourceID; unsigned int length;&#125; Header;void conn_writecb(struct bufferevent *, void *);void conn_readcb(struct bufferevent *, void *);void conn_eventcb(struct bufferevent *, short, void *);string inttostr(int);void write_buffer(string&amp;, struct bufferevent*, Header&amp;);#endif // !_MESSAGE_H_ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;event2/bufferevent.h&gt; #include &lt;event2/buffer.h&gt; #include &lt;event2/listener.h&gt; #include &lt;event2/util.h&gt; #include &lt;event2/event.h&gt; #include &lt;iostream&gt;#include &lt;string&gt;#include \"message.h\"using namespace std;#define PORT 1234#define BUFFER_SIZE (16 * 1024) #define READ_SIZE (16 * 1024)#define SEND_INTERVAL 0#define CLIENT_NUMBER 2#define SEND_TIMES 10#define MAX_PACKET_SIZE 1024#define HEADER_LENGTH 12#define DATA_LENGTH 1000const char ip_address[] = \"127.0.0.1\";int main() &#123; cout &lt;&lt; \"Client running\" &lt;&lt; endl;#ifdef WIN32 WSAData wsaData; WSAStartup(MAKEWORD(2, 0), &amp;wsaData);#endif struct sockaddr_in srv; memset(&amp;srv, 0, sizeof(srv)); srv.sin_addr.S_un.S_addr = inet_addr(ip_address); srv.sin_family = AF_INET; srv.sin_port = htons(PORT); struct event_base *base = event_base_new(); if (!base) &#123; cout &lt;&lt; \"Could not initialize libevent\" &lt;&lt; endl; return 1; &#125; struct bufferevent* bev = bufferevent_socket_new(base, -1,BEV_OPT_CLOSE_ON_FREE); bufferevent_setcb(bev, conn_readcb, conn_writecb, conn_eventcb, NULL); //连接，成功返回0，失败返回-1 int flag = bufferevent_socket_connect(bev, (struct sockaddr *)&amp;srv, sizeof(srv)); bufferevent_enable(bev, EV_READ | EV_WRITE); if (-1 == flag) &#123; cout &lt;&lt; \"Connect failed\" &lt;&lt; endl; return 1; &#125; event_base_dispatch(base); event_base_free(base); return 0;&#125;void conn_writecb(struct bufferevent *bev, void *user_data) &#123; //Sleep(SEND_INTERVAL); int len = 0; static int num[10] = &#123; 0 &#125;; unsigned int toID = rand() % CLIENT_NUMBER + 1; Header header; string msg(DATA_LENGTH - HEADER_LENGTH, '0'); header.targetID = toID; header.length = msg.size(); write_buffer(msg, bev, header);&#125;void write_buffer(string&amp; msg, struct bufferevent* bev, Header&amp; header) &#123; char send_msg[READ_SIZE] = &#123; 0 &#125;; char* ptr = send_msg; int len = 0; //多发几次，便于测试大量数据 for (int i = 0; i &lt; SEND_TIMES; i++) &#123; memcpy(ptr + len, &amp;header, sizeof(Header)); len += sizeof(Header); memcpy(ptr + len, msg.c_str(), msg.size()); len += msg.size(); &#125; bufferevent_write(bev, send_msg, len);&#125;void conn_readcb(struct bufferevent *bev, void *user_data) &#123; struct evbuffer *input = bufferevent_get_input(bev); size_t sz = evbuffer_get_length(input); //返回evbuffer储存的字节数 while (sz &gt;= MAX_PACKET_SIZE) &#123; char msg[MAX_PACKET_SIZE] = &#123; 0 &#125;; char *ptr = msg; bufferevent_read(bev, ptr, HEADER_LENGTH); unsigned int len = ((Header*)ptr)-&gt;length; unsigned int targetID = ((Header*)ptr)-&gt;targetID; unsigned int sourceID = ((Header*)ptr)-&gt;sourceID; ptr += HEADER_LENGTH; if (sz &lt; len + HEADER_LENGTH) &#123; break; &#125; bufferevent_read(bev, ptr, len); cout &lt;&lt; \"receive \" &lt;&lt; HEADER_LENGTH + strlen(ptr) &lt;&lt; \" bytes from client \" &lt;&lt; sourceID &lt;&lt; endl; sz = evbuffer_get_length(input); &#125;&#125;void conn_eventcb(struct bufferevent *bev, short events, void *user_data)&#123; if (events &amp; BEV_EVENT_EOF) &#123; cout &lt;&lt; \"Connection closed\" &lt;&lt; endl; &#125; else if (events &amp; BEV_EVENT_ERROR) &#123; cout &lt;&lt; \"Got an error on the connection: \" &lt;&lt; strerror(errno) &lt;&lt; endl; &#125; else if (events &amp; BEV_EVENT_CONNECTED) &#123; cout &lt;&lt; \"Connect succeed\" &lt;&lt; endl; string msg = \"connect to server\"; Header header; header.targetID = 0; header.length = msg.size(); write_buffer(msg, bev, header); return; &#125; bufferevent_free(bev);&#125;string inttostr(int num) &#123; string result; bool neg = false; if (num &lt; 0) &#123; neg = true; num = -num; &#125; if (num == 0) &#123; result += '0'; &#125; else &#123; while (num &gt; 0) &#123; int rem = num % 10; result = (char)(rem + '0') + result; num /= 10; &#125; &#125; if (neg) &#123; result = '-' + result; &#125; return result;&#125; 效果图片普通测试 服务器测试转发速度 客户端 client1： client2： 最大负载测试 服务器数据 测试统计libevent 测试结果，本地回环地址测试 接收的client个数 2，发送的client个数 4 packet speed代表每秒服务器转发的packet的个数 packet length packet speed data speed 20 bytes 66 k/s 1333 k/s 50 bytes 36.5 k/s 1800 k/s 100 bytes 20.0 k/s 2000 k/s 200 bytes 11.2 k/s 2200 k/s 300 bytes 8.3 k/s 2490 k/s 500 bytes 5.4 k/s 2700 k/s 800 bytes 3.45 k/s 2750 k/s 1000 bytes 2.65 k/s 2650 k/s","categories":[{"name":"network","slug":"network","permalink":"https://uyouii.github.io/categories/network/"}],"tags":[{"name":"network","slug":"network","permalink":"https://uyouii.github.io/tags/network/"},{"name":"libevent","slug":"libevent","permalink":"https://uyouii.github.io/tags/libevent/"},{"name":"c++","slug":"c","permalink":"https://uyouii.github.io/tags/c/"}]}]}