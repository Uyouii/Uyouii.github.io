{"meta":{"title":"Uyouii's Blogs","subtitle":"There are many things need to learn.","description":null,"author":"Uyouii","url":"https://uyouii.github.io"},"pages":[{"title":"All Tags","date":"2017-12-12T05:01:04.000Z","updated":"2017-12-12T05:02:08.532Z","comments":true,"path":"tags/index.html","permalink":"https://uyouii.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-12-12T05:04:45.000Z","updated":"2017-12-12T05:05:11.952Z","comments":true,"path":"categories/index.html","permalink":"https://uyouii.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"python2.7 深入理解","slug":"python2-7-深入理解","date":"2018-02-02T03:04:13.000Z","updated":"2018-02-02T03:07:56.500Z","comments":true,"path":"2018/02/02/python2-7-深入理解/","link":"","permalink":"https://uyouii.github.io/2018/02/02/python2-7-深入理解/","excerpt":"","text":"tuple 和 list的异同 tuple是不可变的，list是可变的。 tuple表示的是结构，list表示的是顺序。 list不能当作dict的key，tuple可以。 由于元组支持的操作比列表小，所以元组的操作相对于list会快上一点点。(除非有巨量的数据需要去处理，否则这一点不需要特别强调) tuple所谓的不可变指的是指向的位置不可变。如果tuple中含有一个list，这个list的内容是可以变化的，因为list本身在内存中的分配不是连续的。 while/else 和 for/else循环可以有一个else子句在循环迭代完整个列表(对于for)后或执行条件为false(对于while)时执行，但循环被break中止的情况下不会执行。 三元运算符value if condition else other_value e.g.12is_fat = Truestate = \"fat\" if is_fat else \"not fat\" 嵌套函数和闭包(Closure)函数不仅可以定义在模块的最外层，还可以定义在另一个函数的内部，像这种定义在函数里面的函数称之为嵌套函数。 嵌套函数可以访问到其外层作用域中声明的非局部变量。 闭包却可以即使脱离函数本身的作用范围，局部变量还是可以被访问得到。 闭包的定义：在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量， 则可能产生闭包。运行时，一旦外部的 函数被执行，一个闭包就形成了， 闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用。 闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。 在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。 注意：python闭包必须通过嵌套函数定义实现，但是嵌套函数不一定是闭包。 当一个函数在执行完以后，访问了嵌套作用域的局部变量，闭包就产生了。假如嵌套函数没有访问嵌套作用域的局部变量，它就不是闭包。 产生闭包必须具备三个条件： 需要定义嵌套函数 嵌套函数需要引用enclosing function中的变量 enclosing function需要返回嵌套函数 闭包的作用：闭包可以避免全局变量的使用，并且可以隐藏一些数据的格式。同时也可以提供面向对象的方法。 Python Closures 迭代器(Iterators)python中的迭代器是一个可以被迭代的对象，每次迭代返回一个数据元素。 python的迭代器对象必须要实现两个特殊的方法：__iter()__和__next()__，被称为iterator protocol 如果我们可以从一个对象获取iterator，则把这个对象成为iterable。很多python内置的容器都是可迭代的，像list, tuple, string。 可以通过next()函数人工的迭代遍历迭代器中所有的元素，当没有数据返回时，函数会抛出StopIteration异常。 一个更优雅的使用迭代器的方式是使用for循环，for可以迭代任何能够返回迭代器的对象。 for 的内部实现12for element in iterable: # do something with element 实际实现：123456789101112# create an iterator object from that iterableiter_obj = iter(iterable)# infinite loopwhile True: try: # get the next item element = next(iter_obj) # do something with element except StopIteration: # if StopIteration is raised, break from loop break for语句首先通过调用iter()创建了一个迭代器对象：iter_obj。 在循环内部通过调用next()函数去获取下一个元素。在所有元素都处理完之后，StopIteration被抛出，并在循环内部被捕获，并保证其他类型的异常不被捕获。 实现迭代器对象实现迭代器对象只需要实现两个方法：__iter()__和__next()__ __iter()__方法返回迭代器对象本身。如果需要的话，可以进行初始化的操作。 __next()__方法返回序列中的下一个元素。当达到最后一个元素的下一个调用时必须抛出StopIteration异常。 for example：123456789101112131415161718class PowTwo: \"\"\"Class to implement an iterator of powers of two\"\"\" def __init__(self, max = 0): self.max = max def __iter__(self): self.n = 0 return self def __next__(self): if self.n &lt;= self.max: result = 2 ** self.n self.n += 1 return result else: raise StopIteration Python Interators 生成器(Generators)生成器是创建迭代器的一种简单的方式。简单的说，生成器就是可以返回一个可迭代对象的函数（每次返回一个元素） 生成器的创建非常简单，只需要把函数定义中的return替换为yeild即可。 如果一个函数中包含了至少一个yeild语句，这个函数就是生成器。yeild和return都会从函数中返回值。 不同的是，return语句会终止整个函数的执行，yeild语句会暂停函数的执行并且储存函数的状态，在下一次成功调用后继续执行。 生成器函数和普通函数的异同： 生成器函数包含了一个或者多个yelid语句 当被调用时，生成器函数返回一个迭代器对象，但是函数不会立即开始执行。 __iter()__方法和__next()__方法会被自动的实现，所以可以调用next()函数获取下一个元素。 当函数执行yelid语句时，函数会被暂停执行，控制权会返还给调用者 局部变量和他们的状态在成功的调用之间会被保存 当函数结束时，StopIteration会在下一次的调用时被自动抛出。 每个生成器只能被调用一次，要重新开始生成器的调用可以创建一个新的生成器对象，像:a = my_gen() 可以直接在for循环中使用生成器 生成器表达式(Generator Expression)生成器表达式(generateor expression)的语法和列表推导式(list comprehension)的结构很像，只需要把方括号替换为圆括号。 generator expression和list comprehension最主要的区别就是list comprehension每次生成整个列表，但是generator expression每次生成一个元素。 genreator expression只有每次被调用的时候才会输出元素，所以generator expression比list comprehension在内存的使用上跟高效。 12345678910# Initialize the listmy_list = [1, 3, 6, 10]# square each term using list comprehension# Output: [1, 9, 36, 100][x**2 for x in my_list]# same thing can be done using generator expression# Output: &lt;generator object &lt;genexpr&gt; at 0x0000000002EBDAF8&gt;(x**2 for x in my_list) generator expression可以被函数调用，这种情况下圆括号可以省去。12&gt;&gt;&gt; sum(x**2 for x in my_list)146 Python Generators 装饰器(decorator)装饰器可以向已经写好的代码中添加功能，程序的一部分可以在编译时修改程序的另一部分。 everything in python are objects. python函数的一些特性： 同一个函数对象可以绑定不同的函数名称 函数可以作为参数传递给另一个函数(这些函数也被称为higher order functions) 函数可以把函数当作返回值 函数和方法被称为可调用的(called)。在python中任何实现__call__()方法的对象都称为可调用的(called)。 装饰器就是callable并返回callable的对象。 装饰器一般读取一个函数，为其添加功能然后返回。 12345678def make_pretty(func): def inner(): print(\"I got decorated\") func() return innerdef ordinary(): print(\"I am ordinary\") 12345678&gt;&gt;&gt; ordinary()I am ordinary&gt;&gt;&gt; # let's decorate this ordinary function&gt;&gt;&gt; pretty = make_pretty(ordinary)&gt;&gt;&gt; pretty()I got decoratedI am ordinary 可以使用@符号和装饰器名称一起使用，放在函数定义前，表示该函数使用该装饰器123@make_prettydef ordinary(): print(\"I am ordinary\") 等价于123def ordinary(): print(\"I am ordinary\")ordinary = make_pretty(ordinary) 带参数的装饰器需要保证inner function的参数和被修饰的函数参数保持一致。可以用一种通用的装饰器的实现方法：12345def works_for_all(func): def inner(*args, **kwargs): print(\"I can decorate any function\") return func(*args, **kwargs) return inner args是位置参数的元组，kwargs是默认参数的字典。 同一个函数可以被多个装饰器装饰多次（可以是同一个装饰器）。 Python Decorator 属性（Property）property example:123456789101112131415161718class Celsius(object): def __init__(self, temperature = 0): self.temperature = temperature def to_fahrenheit(self): return (self.temperature * 1.8) + 32 def get_temperature(self): print(\"Getting value\") return self._temperature def set_temperature(self, value): if value &lt; -273: raise ValueError(\"Temperature below -273 is not possible\") print(\"Setting value\") self._temperature = value temperature = property(get_temperature,set_temperature) 我们在最后一行创造了一个property对象：temperature。任何获取temperature值的代码会自动调用get_temperature()方法，而不是向__dict__中查找，任何给temperature赋值的代码会自动调用set_temperature()。 在python中，property()是一个内置的函数，创建和返回一个property对象。1property(fget=None, fset=None, fdel=None, doc=None) fget是获取属性的值的函数，fset是设置属性值的函数，fdel是删除属性的函数，doc是一个字符串（类似于注释）。 property对象有三个方法：gettter(),setter()和delete()用于设置fget,fset和del。1temperature = property(get_temperature,set_temperature) 可以等价于123456# make empty propertytemperature = property()# assign fgettemperature = temperature.getter(get_temperature)# assign fsettemperature = temperature.setter(set_temperature) 注意：python2中实现property时，需要继承object，否则setter无效。python3默认继承，所以没有问题。 使用装饰器实现property123456789101112131415161718class Celsius(object): def __init__(self, temperature = 0): self._temperature = temperature def to_fahrenheit(self): return (self.temperature * 1.8) + 32 @property def temperature(self): print(\"Getting value\") return self._temperature @temperature.setter def temperature(self, value): if value &lt; -273: raise ValueError(\"Temperature below -273 is not possible\") print(\"Setting value\") self._temperature = value Python Property 方法和函数的区别 function(函数) —— A series of statements which returns some value toa caller. It can also be passed zero or more arguments which may beused in the execution of the body. method(方法) —— A function which is defined inside a class body. If called as an attribute of an instance of that class, the method will get the instance object as its first argument (which isusually called self). 本质上，函数和方法的区别是：函数属于FunctionObject，而方法属于PyMethodObject。 e.g.123456789def aa(d, na=None, *kasd, **kassd): passclass A(object): def f(self): return 1a = A()print aaprint A.fprint a.f 结果：123&lt;function aa at 0x0000000004D995F8&gt;&lt;unbound method A.f&gt;&lt;bound method A.f of &lt;__main__.A object at 0x0000000004DB97F0&gt;&gt; Bound Method 和 Unbound Methodmethod还可以分为bound method和unbound method，bound method多了一个实例绑定的过程。 A.f是unbound method，a.f是bound method bound和unbound的判断依据就是，当方法真正执行时，有没有传入实例。 A.f(a)和a.f()用法的区别只在于，第一种需要认为传入实例才能调用，第二种虚拟机帮我们做好了传入实例的动作，两种方法本质上是等价的。 类方法(classmethod)和静态方法(statimethod) @classmethod means: when this method is called, we pass the class as the first argument instead of the instance of that class (as we normally do with methods). This means you can use the class and its properties inside that method rather than a particular instance. @staticmethod means: when this method is called, we don’t pass an instance of the class to it (as we normally do with methods). This means you can put a function inside a class but you can’t access the instance of that class (this is useful when your method does not use the instance). classmethod must have a reference to a class object as the first parameter, whereas staticmethod can have no parameters at all.","categories":[{"name":"learning python","slug":"learning-python","permalink":"https://uyouii.github.io/categories/learning-python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://uyouii.github.io/tags/python/"}]},{"title":"python2.7 基础知识","slug":"python2.7 基础知识","date":"2018-01-30T13:13:58.000Z","updated":"2018-02-02T03:08:03.043Z","comments":true,"path":"2018/01/30/python2.7 基础知识/","link":"","permalink":"https://uyouii.github.io/2018/01/30/python2.7 基础知识/","excerpt":"","text":"python 入门指南 数字 //运算符用于 floor division 而无论操作数是什么类型。 可以使用 ** 运算符计算幂乘方 字符串 使用 原始字符串，方法是在第一个引号前面加上一个 r，例如 r&#39;C:\\some\\name&#39; 字符串文本能够分成多行。一种方法是使用三引号：&quot;&quot;&quot;...&quot;&quot;&quot; 或者 &#39;&#39;&#39;...&#39;&#39;&#39;。行尾换行符会被自动包含到字符串中，但是可以在行尾加上 \\ 来避免这个行为。 字符串可以由 + 操作符连接(粘到一起)，可以由 * 表示重复 相邻的两个字符串文本自动连接在一起，只用于两个字符串文本，不能用于字符串表达式，如果想连接多个变量或者连接一个变量和一个字符串文本，使用 + 支持索引和切片。索引用于获得单个字符，切片 让你获得一个子字符串。 12345&gt;&gt;&gt; word = 'Python'&gt;&gt;&gt; word[0:2] # characters from position 0 (included) to 2 (excluded)'Py'&gt;&gt;&gt; word[2:5] # characters from position 2 (included) to 5 (excluded)'tho' Python字符串不可以被更改—它们是不可变的。因此，赋值给字符串索引的位置会导致错误。 内置函数 len() 返回字符串长度。 See also Sequence Types — str, unicode, list, tuple, bytearray, buffer, xrange字符串和下节描述的Unicode字符串是 序列类型 的例子，它们支持这种类型共同的操作。 String Methods字符串和Unicode字符串都支持大量的方法用于基本的转换和查找。 String Formatting这里描述了使用 str.format() 进行字符串格式化的信息。 String Formatting Operations这里描述了旧式的字符串格式化操作，它们在字符串和Unicode字符串是 % 操作符的左操作数时调用。 流程控制 在迭代过程中修改迭代序列不安全(只有在使用链表这样的可变序列时才会有这样的情况)。如果你想要修改你迭代的序列(例如：复制选择项)，你可以迭代它的复本。 需要迭代链表索引的话，可以结合使用 range() 和 len() 123a = [&apos;Mary&apos;, &apos;had&apos;, &apos;a&apos;, &apos;little&apos;, &apos;lamb&apos;]for i in range(len(a)): print i, a[i] 循环可以有一个else子句；它在循环迭代完整个列表(对于for)后或执行条件为false(对于while) 时执行，但循环被 break中止的情况下不会执行。 try语句的else子句在未出现异常时运行，循环的else子句在未出现break时运行。 函数 函数调用 会为函数局部变量生成一个新的符号表。确切地说，所有函数中的变量赋值都是将值存储在局部符号表。变量引用首先在局部符号表中查找，然后是包含函数的局部符号表，然后是全局符号表，最后是内置名字表。因此，全局变量不能在函数中直接赋值 (除非用global语句命名)，尽管他们可以被引用。 函数引用的实际参数在函数调用时引入局部符号表，因此，实参总是传值调用(这里的值总是一个对象引用，而不是该对象的值)。 没有 return 语句的函数确实会返回一个值： None。 函数默认值只被赋值一次。这使得当默认值是可变对象时会有所不同，比如列表、字典或者大多数类的实例。 def是一个可执行指令，只有def执行的时候才会计算默认默认参数的值 在函数调用中，关键字的参数必须跟随在位置参数的后面。 引入一个形如**name的参数时，它接收一个字典。形如*name的形式参数，它接收一个元组。 可以在调用函数时加一个*操作符来自动把参数列表拆开。使用 ** 操作符分拆关键字参数为字典。 列表方法1234567891011121314151617181920212223242526272829list.append(x)把一个元素添加到链表的结尾，相当于 a[len(a):] = [x]。list.extend(L)将一个给定列表中的所有元素都添加到另一个列表中，相当于 a[len(a):] = L。list.insert(i, x)在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引。例如 a.insert(0, x) 会插入到整个链表之前，而 a.insert(len(a), x) 相当于 a.append(x)。list.remove(x)删除链表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。list.pop([i])从链表的指定位置删除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从链表中被删除。\"方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号。\"list.index(x)返回链表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。list.count(x)返回 x 在链表中出现的次数。list.sort(cmp=None, key=None, reverse=False)对链表中的元素就地进行排序（参数可以用来自定义排序方法）。list.reverse()就地倒排链表中的元素。 函数式编程工具filter()filter(function, sequence)返回一个 sequence(序列)，包括了给定序列中所有调用 function(item) 后返回值为 true 的元素(如果可能的话，会返回相同的类型)。如果该序列 (sequence)是一个 str, unicode 或者 tuple，返回值必定是同一类型，否则，它总是 list。 map()map(function, sequence)为每一个元素依次调用 function(item) 并将返回值组成一个链表返回。 可以传入多个序列，函数也必须要有对应数量的参数，执行时会依次用各序列上对应的元素来调用函数(如果某些序列比其它的短，就用 None 来代替)。如果把 None 做为一个函数传入，则直接返回参数做为替代。 reduce()reduce(function, sequence)返回一个单值，它是这样构造的：首先以序列的前两个元素调用函数 function，再以返回值和第三个参数调用，依次执行下去。 如果序列中只有一个元素，就返回它，如果序列是空的，就抛出一个异常。 可以传入第三个参数作为初始值。如果序列是空的，就返回初始值，否则函数会先接收初始值和序列的第一个元素，然后是返回值和下一个元素，依此类推。 列表推导式列表推导式由包含一个表达式的括号组成，表达式后面跟随一个 for 子句，之后可以有零或多个 for 或 if 子句。结果是一个列表，由表达式依据其后面的 for 和 if 子句上下文计算而来的结果构成。 例如：12345678squares = [x**2 for x in range(10)]&gt;&gt;&gt; [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y][(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]&gt;&gt;&gt; from math import pi&gt;&gt;&gt; [str(round(pi, i)) for i in range(1, 6)]['3.1', '3.14', '3.142', '3.1416', '3.14159'] 列表推导式可以嵌套。 例如：12345678&gt;&gt;&gt; matrix = [... [1, 2, 3, 4],... [5, 6, 7, 8],... [9, 10, 11, 12],... ]&gt;&gt;&gt; [[row[i] for row in matrix] for i in range(4)][[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] del语句del语句可以从列表中按给定的索引而不是值来删除一个子项。它不同于有返回值的 pop() 方法。语句 del 还可以从列表中删除切片或清空整个列表(我们以前介绍过一个方法是将空列表赋值给列表的切片)。 del 也可以删除整个变量。 元组和序列一个元组由数个逗号分隔的值组成。 元组在输出时总是有括号的，以便于正确表达嵌套结构。在输入时可以有或没有括号，不过经常括号都是必须的(如果元组是一个更大的表达式的一部分)。 不能给元组的一个独立的元素赋值(尽管你可以通过联接和切割来模拟)。还可以创建包含可变对象的元组，例如链表。 元组是不可变的，通常包含不同种类的元素并通过分拆或索引访问（如果是 namedtuples，甚至可以通过属性）。列表是可变的，它们的元素通常是相同的类型并通过迭代访问。 构造包含零个或一个元素的元组：12&gt;&gt;&gt; empty = ()&gt;&gt;&gt; singleton = 'hello', # &lt;-- note trailing comma 可变参数(multiple assignment)其实只是元组封装和序列拆封的一个结合。 集合集合是一个无序不重复元素的集。集合对象还支持union(联合)，intersection(交)，difference(差)和 sysmmetric difference(对称差集)等数学运算。 大括号或set()函数可以用来创建集合。注意：想要创建空集合，你必须使用 set() 而不是 {}。后者用于创建空字典。 类似列表推导式，集合也有推导式语法：1&gt;&gt;&gt; a = &#123;x for x in 'abracadabra' if x not in 'abc'&#125; 字典字典以 关键字 为索引，关键字可以是任意不可变类型，通常用字符串或数值。如果元组中只包含字符串和数字，它可以作为关键字，如果它直接或间接地包含了可变对象，就不能当做关键字。 字典的主要操作是依据键来存储和析取值。也可以用del来删除键：值对(key:value)。 对一个字典执行keys()将返回一个字典中所有关键字组成的无序列表(如果你想要排序，只需使用 sorted())。 dict() 构造函数可以直接从 key-value 对中创建字典:1dict([('sape', 4139), ('guido', 4127), ('jack', 4098)]) 字典推导式可以从任意的键值表达式中创建字典:1&#123;x: x**2 for x in (2, 4, 6)&#125; 如果关键字都是简单的字符串，有时通过关键字参数指定 key-value 对更为方便:1dict(sape=4139, guido=4127, jack=4098) 模块模块可以包含执行语句，一般用来初始化模块，仅在第一次被导入的地方执行一次。 每个模块都有自己私有的符号表，被模块内所有的函数定义作为全局符号表使用。因此，模块的作者可以在模块内部使用全局变量，而无需担心它与某个用户的全局变量意外冲突。也可以引用模块函数的表示法访问模块的全局变量，modname.itemname。 出于性能考虑，每个模块在每个解释器会话中只导入一遍。因此，如果修改了模块，需要重启解释器或者如果想交互式的测试这么一个模块，可以用reload()重新加载，例如 reload(modulename)。 如果调用python module.py执行某个模块，此时改模块的__name__被设置为__main__。如果在模块后加入代码：12if __name__ == \"__main__\": pass 就可以让此文件像作为模块导入时一样作为脚本执行。此代码只有在模块作为 “main” 文件执行时才被调用。如果模块被导入，则不会执行这段代码。 当导入一个叫module的模块时，解释器现在当前的目录中搜索名为module.py的文件，如果没有找到的话，接着会到sys.path变量中给出的目录列表中查找。 sys.path变量的初始值： 输入脚本的目录(当前目录)。 环境变量PYTHONPATH表示的目录列表中搜索 Python 默认安装路径中搜索。 如果在name.py所在的目录下存在一个名为name.pyc的文件，它会被视为name模块的预编译(byte-compiled,二进制编译版本)，对于引用了大量标准模块的短程序，可以提高启动速度。用于创建name.pyc的这一版spam.py的修改时间记录在spam.pyc文件中，如果两者不匹配，.pyc文件就被忽略。 包为了让 Python 将目录当做内容包，目录中必须包含__init__.py文件。这是为了避免一个含有烂俗名字的目录无意中隐藏了稍后在模块搜索路径中出现的有效模块，比如string。最简单的情况下，只需要一个空的__init__.py文件即可。当然它也可以执行包的初始化代码，或者定义__all__变量。 执行from package import *时，如果包中的__init__.py代码定义了一个名为__all__的列表，就会按照列表中给出的模块名进行导入。 显式或隐式相对位置导入都基于当前模块的命名。因为主模块的名字总是 __main__，Python 应用程序的主模块应该总是用绝对导入。 异常处理try 语句按如下方式工作： 首先，执行 try 子句(在 try 和 except 关键字之间的部分)。 如果没有异常发生，except 子句在 try 语句执行完毕后就被忽略了。 如果在 try 子句执行过程中发生了异常，那么该子句其余的部分就会被忽略。如果异常匹配于 except 关键字后面指定的异常类型，就执行对应的 except 子句。然后继续执行 try 语句之后的代码。 如果发生了一个异常，在 except 子句中没有与之匹配的分支，它就会传递到上一级 try 语句中。如果最终仍找不到对应的处理语句，它就成为一个 未处理异常，终止程序运行，显示提示信息。 一个 try 语句可能包含多个 except 子句，分别指定处理不同的异常。至多只会有一个分支被执行。异常处理程序只会处理对应的 try 子句中发生的异常，在同一个 try 语句中，其他子句中发生的异常则不作处理。一个 except 子句可以在括号中列出多个异常的名字，例如:12except (RuntimeError, TypeError, NameError): pass 最后一个 except 子句可以省略异常名称，以作为通配符使用。你需要慎用此法，因为它会轻易隐藏一个实际的程序错误！可以使用这种方法打印一条错误信息，然后重新抛出异常(允许调用者处理这个异常):123456except IOError as e: passexcept ValueError: passexcept: raise try … except 语句可以带有一个 else子句 ，该子句只能出现在所有 except 子句之后。当 try 语句没有抛出异常时，需要执行一些代码，可以使用这个子句。 raise语句允许程序员强制抛出一个指定的异常。要抛出的异常由raise的唯一参数标识。它必需是一个异常实例或异常类(继承自 Exception 的类)。如果你需要明确一个异常是否抛出，但不想处理它，raise语句可以让你很简单的重新抛出该异常。 不管有没有发生异常，finally子句 在程序离开 try 后都一定会被执行。当 try 语句中发生了未被 except 捕获的异常(或者它发生在 except 或 else 子句中)，在 finally 子句执行完后它会被重新抛出。try 语句经由 break，continue 或 return 语句退出也一样会执行 finally 子句。1234try: raise KeyboardInterruptfinally: print 'Goodbye, world!' 类命名空间和作用域命名空间 是从命名到对象的映射。当前命名空间主要是通过 Python 字典实现的。 不同命名空间中的命名没有任何联系。 不同的命名空间在不同的时刻创建，有不同的生存期。包含内置命名的命名空间在 Python 解释器启动时创建，会一直保留，不被删除。模块的全局命名空间在模块定义被读入时创建，通常，模块命名空间也会一直保存到解释器退出。由解释器在最高层调用执行的语句，不管它是从脚本文件中读入还是来自交互式输入，都是__main__模块的一部分，所以它们也拥有自己的命名空间(内置命名也同样被包含在一个模块中，它被称作__builtin__)。 当调用函数时，就会为它创建一个局部命名空间，并且在函数返回或抛出一个并没有在函数内部处理的异常时被删除。每个递归调用都有自己的局部命名空间。 作用于访问顺序：包含局部命名的使用域在最里面，首先被搜索；其次搜索的是中层的作用域，这里包含了同级的函数；最后搜索最外面的作用域，它包含内置命名。 首先搜索最内层的作用域，它包含局部命名任意函数包含的作用域，是内层嵌套作用域搜索起点，包含非局部，但是也非全局的命名 接下来的作用域包含当前模块的全局命名 最外层的作用域(最后搜索)是包含内置命名的命名空间。 一个定义于某模块中的函数的全局作用域是该模块的命名空间，而不是该函数的别名被定义或调用的位置。 类对象类对象支持两种操作：属性引用和实例化。 类定义了__init__()方法的话，类的实例化操作会自动为新创建的类实例调用__init__()方法。 和局部变量一样，数据属性不需要声明，第一次使用时它们就会生成。 类中所有(用户定义)的函数对象对应它的实例中的方法。实例中的函数是方法对象，不是函数对象。 例子：123456class MyClass: \"\"\"A simple example class\"\"\" i = 12345 def f(self): return 'hello world'x = MyClass() 方法的特别之处在于实例对象作为函数的第一个参数传给了函数。 调用x.f()相当于MyClass.f(x) 引用非数据属性的实例属性时，会搜索它的类。如果这个命名确认为一个有效的函数对象类属性，就会将实例对象和函数对象封装进一个抽象对象：这就是方法对象。以一个参数列表调用方法对象时，它被重新拆 封，用实例对象和原始的参数列表构造一个新的参数列表，然后函数对象调用这个新的参数列表。 一般来说，实例变量用于对每一个实例都是唯一的数据，类变量用于类的所有实例共享的属性和方法。 数据属性会覆盖同名的方法属性。 方法可以像引用普通的函数那样引用全局命名。与方法关联的全局作用域是包含类定义的模块(类本身永远不会做为全局作用域使用)。 对于 C++ 程序员来说，Python 中的所有方法本质上都是虚方法 派生类中的覆盖方法可能是想要扩充而不是简单的替代基类中的重名方法。有一个简单的方法可以直接调用基类方法，只要调用：BaseClassName.methodname(self, arguments)。 实用技巧 在Python源文件中可以使用非 ASCII 编码。最好的方法是在 #! 行的后面再增加一行特殊的注释来定义源文件的编码: 1# -*- coding: encoding -*- 迭代器 生成器 格式化输入和输出 文件读写 序列中循环时，索引位置和对应值可以使用enumerate()函数同时得到: 12&gt;&gt;&gt; for i, v in enumerate(['tic', 'tac', 'toe']):... print(i, v) 同时循环两个或更多的序列，可以使用 zip() 整体打包: 1234&gt;&gt;&gt; questions = ['name', 'quest', 'favorite color']&gt;&gt;&gt; answers = ['lancelot', 'the holy grail', 'blue']&gt;&gt;&gt; for q, a in zip(questions, answers):... print 'What is your &#123;0&#125;? It is &#123;1&#125;.'.format(q, a) 需要逆向循环序列的话，先正向定位序列，然后调用 reversed() 函数: 12&gt;&gt;&gt; for i in reversed(xrange(1, 10, 2)):... print(i) sorted() 函数不改动原序列，而是生成一个新的已排序的序列。 遍历字典时，使用 iteritems() 方法可以同时得到键和对应的值： 123&gt;&gt;&gt; knights = &#123;'gallahad': 'the pure', 'robin': 'the brave'&#125;&gt;&gt;&gt; for k, v in knights.iteritems():... print k, v 在循环内部修改正在遍历的序列，应首先制作副本： 123words = ['cat', 'window', 'defenestrate']for w in words[:]: # Loop over a slice copy of the entire list. pass print 用一个逗号结尾就可以禁止输出换行 注意 is 用来判断两个对象是否是同一个对象，== 用来判断两个对象是否相等 编码风格 使用 4 空格缩进，而非 TAB。 在小缩进(可以嵌套更深)和大缩进(更易读)之间，4 空格是一个很好的折中。TAB 引发了一些混乱，最好弃用。 折行以确保其不会超过 79 个字符。 这有助于小显示器用户阅读，也可以让大显示器能并排显示几个代码文件。 使用空行分隔函数和类，以及函数中的大块代码。 可能的话，注释独占一行 使用文档字符串 把空格放到操作符两边，以及逗号后面，但是括号里侧不加空格：a = f(1, 2) + g(3, 4)。 统一函数和类命名。 推荐类名用 驼峰命名，函数和方法名用小写和下划线。总是用self作为方法的第一个参数(关于类和方法的知识详见 初识类)。 不要使用花的编码，如果你的代码的目的是要在国际化环境。Python的默认情况下，UTF-8，甚至普通的 ASCII 总是工作的最好。 同样，也不要使用非 ASCII 字符的标识符，除非是不同语种的会阅读或者维护代码。","categories":[{"name":"learning python","slug":"learning-python","permalink":"https://uyouii.github.io/categories/learning-python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://uyouii.github.io/tags/python/"}]},{"title":"Lua Table Parser","slug":"Lua-Table-Parser","date":"2018-01-30T10:03:35.000Z","updated":"2018-02-02T03:07:33.010Z","comments":true,"path":"2018/01/30/Lua-Table-Parser/","link":"","permalink":"https://uyouii.github.io/2018/01/30/Lua-Table-Parser/","excerpt":"","text":"Lua Table Parser 使用说明PyLuaTblParser类中有两个私有变量： self.str_praser是类LuaStrParser的实例，用来实现lua字符串的解析。 self.lua_table是一个dict或者list，用来储存从lua table字符串或者其他dict中读取的数据。 接口1234567891011121314151617181920212223def load(self, s):读取Lua table数据，输入s为一个符合Lua table定义的字符串，无返回值遇到Lua table格式错误则抛出异常def dump(self):根据类中数据返回Lua table字符串def loadLuaTable(self, f):从文件中读取Lua table字符串，f为文件路径，遇到Lua Table的格式错误则抛出异常，文件操作失败抛出异常def dumpLuaTable(self, f):将类中的内容以Lua table格式存入文件，f为文件路径，文件若存在则覆盖，文件操作失败抛出异常def loadDict(self, d):读取dict中的数据，存入类中，只处理数字和字符串两种类型的key，其他类型的key直接忽略def dumpDict(self):返回一个dict，包含类中的数据def update(self, d):用字典d更新类中的数据，类似于字典的updatePyLuaTblParser类支持用[]进行赋值、读写数据的操作，类似字典 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440class LuaStrParser: __spaceChars = [' ', '\\t', '\\n', '\\r'] __stopChars = [' ', '\\t', '\\n', '\\r', '=', ',', ';', '&#125;', ']'] keyTypes = [int, float, str] __specialChars = &#123; 'a': '\\a', 'b': '\\b', 'f': '\\f', 'n': '\\n', 'r': '\\r', 't': '\\t', 'v': '\\v', '\\\\': '\\\\', '\"': '\"', \"'\": \"'\", &#125; __reverseSpecialChars = &#123; '\\a': '\\\\a', '\\b': '\\\\b', '\\f': '\\\\f', '\\n': '\\\\n', '\\r': '\\\\r', '\\t': '\\\\t', '\\v': '\\\\v', '\\\\': '\\\\\\\\', '\"': '\\\\\"', \"'\": \"\\\\'\" &#125; def __init__(self): self.__lua_object = None self.__lua_str = None def __jumpSpace(self, string, loc): while loc &lt; len(string) and string[loc] in self.__spaceChars: loc += 1 return loc def __getBackSlashNum(self, lua_str, loc): backslash_num = 0 while loc &gt;= 0 and lua_str[loc] == '\\\\': loc -= 1 backslash_num += 1 return backslash_num def __getStringEnd(self, lua_str, loc, quote): result = loc + 1 if lua_str[loc] == quote: end = lua_str.find(quote, loc + 1) if end != loc + 1: at_end = False while not at_end: if self.__getBackSlashNum(lua_str, end - 1) % 2 == 0: at_end = True if not at_end: end = lua_str.find(quote, end + 1) if end &lt; 0: raise Exception(\"wrong quotes!\") result = end return result def __getStringConent(self, lua_str, loc): \"\"\" return the string in the @para lua_str thee result contain the quotes\"\"\" loc = self.__jumpSpace(lua_str, loc) result = None if lua_str[loc] == '\"' or lua_str[loc] == \"'\": end = self.__getStringEnd(lua_str, loc, lua_str[loc]) result = lua_str[loc: end + 1] loc = end + 1 return result, loc def __removeComment(self, lua_str): result = \"\" loc = 0 while loc &lt; len(lua_str): # string should be add in result directly if lua_str[loc] == '\"' or lua_str[loc] == \"'\": string, loc = self.__getStringConent(lua_str, loc) result += string # remove comment elif lua_str[loc] == '-': if loc + 1 &lt; len(lua_str) and lua_str[loc + 1] == '-': loc += 2 # multi line comments if loc + 1 &lt; len(lua_str) and lua_str[loc:loc + 2] == '[[': loc = lua_str.find(']]', loc + 1) + 2 # single line comment else: loc = lua_str.find('\\n', loc + 1) + 1 # add a space after remove the comment result += ' ' else: result += lua_str[loc] loc += 1 # remove '\\r' elif lua_str[loc] == '\\r': loc += 1 continue else: result += lua_str[loc] loc += 1 return result def __getRightBrace(self, lua_str, loc): loc = lua_str.find('&#123;', loc) + 1 left_barce_num = 0 while loc &lt; len(lua_str): if lua_str[loc] == '\"' or lua_str[loc] == \"'\": loc = self.__getStringEnd(lua_str, loc, lua_str[loc]) + 1 elif lua_str[loc] == '&#123;': left_barce_num -= 1 loc += 1 elif lua_str[loc] == '&#125;': left_barce_num += 1 if left_barce_num &gt;= 1: break loc += 1 else: loc += 1 if loc == len(lua_str): raise Exception(\"wrong number of brace\") return loc def __getRightBracket(self, lua_str, loc): loc = lua_str.find('[', loc) + 1 while loc &lt; len(lua_str): if lua_str[loc] == '\"' or lua_str[loc] == \"'\": loc = self.__getStringEnd(lua_str, loc, lua_str[loc]) + 1 elif lua_str[loc] == ']': break else: loc += 1 if loc == len(lua_str): raise Exception(\"wrong number of bracket\") return loc def __getLastBrace(self, lua_str): end = len(lua_str) - 1 while end &gt;= 0 and lua_str[end] != '&#125;': end -= 1 if end &lt; 0: raise Exception(\"wrong number of brace\") return end def __readNum(self, number_str): try: num = eval(number_str) except Exception: return None else: return num def __getRealStr(self, s): result = \"\" i = 0 while i &lt; len(s): if s[i] == '\\\\': if i + 1 &lt; len(s) and s[i + 1] in self.__specialChars.keys(): result += self.__specialChars[s[i+1]] i += 2 else: result += s[i] i += 1 else: result += s[i] i += 1 # print s, \"&gt;&gt;\" , result return result def __readValue(self, value): value = value.strip() if len(value) &gt; 0: if value[0] == '\"' or value[0] == \"'\": return self.__getRealStr(value[1:len(value) - 1]), str elif value == 'nil': return None, \"nil\" elif value == 'false': return False, bool elif value == 'true': return True, bool else: number = self.__readNum(value) if isinstance(number, int): return number, int elif isinstance(number, float): return number, float else: return None, None return value, str def __readStatement(self, lua_str, loc): loc = self.__jumpSpace(lua_str, loc) if lua_str[loc] == '&#123;': end = self.__getRightBrace(lua_str, loc) stat = self.__parserLuaStr(lua_str[loc: end + 1]) stat_type = type(stat) loc = end + 1 elif lua_str[loc] == '[': end = self.__getRightBracket(lua_str, loc) stat, stat_type = self.__readValue(lua_str[loc + 1: end]) loc = end + 1 elif lua_str[loc] == '\"' or lua_str[loc] == \"'\": end = self.__getStringEnd(lua_str, loc, lua_str[loc]) stat = lua_str[loc + 1: end] stat = self.__getRealStr(stat) stat_type = str loc = end + 1 else: end = loc while end &lt; len(lua_str) and lua_str[end] not in self.__stopChars: end += 1 stat, stat_type = self.__readValue(lua_str[loc: end]) loc = end return stat, stat_type, loc def __parserLuaStr(self, lua_str): loc = lua_str.find('&#123;') + 1 end = self.__getLastBrace(lua_str) has_equal = False keys = [] values = [] while 0 &lt;= loc &lt; end: key, key_type, loc = self.__readStatement(lua_str, loc) value, value_type = None, None has_value = False loc = self.__jumpSpace(lua_str, loc) if lua_str[loc] == '=': has_value = has_equal = True loc += 1 value, value_type, loc = self.__readStatement(lua_str, loc) loc = self.__jumpSpace(lua_str, loc) loc += 1 if has_value: if key is not None: keys.append((key, key_type)) values.append((value, value_type)) else: raise Exception(\"the key is nil\") else: keys.append((key, key_type)) values.append((None, None)) number = 1 if has_equal: result = &#123;&#125; for key_tuple, value_tuple in zip(keys, values): if value_tuple[1] is not None: result[key_tuple[0]] = value_tuple[0] else: if key_tuple[1] != 'nil' and key_tuple[0] is not None: result[number] = key_tuple[0] number += 1 result = &#123;k: v for k, v in result.iteritems() if v is not None&#125; else: result = [] for key_tuple in keys: if key_tuple[1] is not None: result.append(key_tuple[0]) return result def readStr(self, lua_str): lua_str = self.__removeComment(lua_str.strip()) self.__lua_object = self.__parserLuaStr(lua_str) def getLuaObject(self): return self.__lua_object def __generateKeyStr(self, lua_object): result = \"\" if lua_object is not None: if type(lua_object) is str: result = '[\"' + self.__getOriginStr(lua_object) + '\"]' elif type(lua_object) is int or type(lua_object) is float: result = '[' + str(lua_object) + ']' elif type(lua_object) is bool: if lua_object: result = '[true]' else: result = '[false]' else: raise Exception(\"Wrong type of key: \" + str(lua_object)) return result def __getOriginStr(self, s): result = \"\" for c in s: if c in self.__reverseSpecialChars.keys(): result += self.__reverseSpecialChars[c] else: result += c return result def __generateValueStr(self, lua_object): result = \"\" object_type = type(lua_object) if lua_object is None: result = 'nil' elif object_type is list or object_type is dict: result = self.generateLuaStr(lua_object) elif object_type is str: result = '\"' + self.__getOriginStr(lua_object) + '\"' elif object_type is int or object_type is float: result = str(lua_object) elif object_type is bool: if lua_object: result = 'true' else: result = 'false' return result def generateLuaStr(self, lua_object): result = \"\" if lua_object is not None: result += '&#123;' if type(lua_object) is dict: for key, value in lua_object.iteritems(): result += self.__generateKeyStr(key) + ' = ' + self.__generateValueStr(value) + ', ' elif type(lua_object) is list: for value in lua_object: result += self.__generateValueStr(value) + ', ' result += '&#125;' self.__lua_str = result return resultclass PyLuaTblParser: def __init__(self): self.str_praser = LuaStrParser() self.lua_table = None def load(self, s): self.str_praser.readStr(s) self.lua_table = self.str_praser.getLuaObject() def dump(self): return self.str_praser.generateLuaStr(self.lua_table) def loadLuaTable(self, f): with open(f, 'r') as lua_str_file: lua_str = lua_str_file.read() self.load(lua_str) def dumpLuaTable(self, f): with open(f, 'w') as out_file: out_file.write(self.str_praser.generateLuaStr(self.lua_table)) def deleteOtherKey(self, d): result = None if type(d) is dict: result = &#123;&#125; for key, value in d.iteritems(): if type(key) in LuaStrParser.keyTypes: if type(value) is list or type(value) is dict: result[key] = self.deleteOtherKey(value) else: result[key] = value elif type(d) is list: result = [] for value in d: if type(value) is list or type(value) is dict: result.append(self.deleteOtherKey(value)) else: result.append(value) return result def loadDict(self, d): if type(d) is dict: self.lua_table = self.deleteOtherKey(d) def dumpDict(self): if type(self.lua_table) is dict: return self.lua_table.copy() elif type(self.lua_table) is list: return [v for v in self.lua_table] def update(self, d): if self.lua_table is None: self.lua_table = d else: if type(self.lua_table) is list: new_table = &#123;&#125; for k, v in zip(range(1, len(self.lua_table) + 1), self.lua_table): if v is not None: new_table[k] = v self.lua_table = new_table new_table = self.deleteOtherKey(d) for k, v in new_table.iteritems(): self.lua_table[k] = v def __getitem__(self, item): try: return self.lua_table[item] except: return None def __setitem__(self, key, value): if self.lua_table is None: self.lua_table = &#123;&#125; self.lua_table[key] = value elif type(self.lua_table) is dict: self.lua_table[key] = value elif type(self.lua_table) is list: new_table = &#123;&#125; for k, v in zip(range(1,len(self.lua_table) + 1), self.lua_table): if v is not None: new_table[k] = v new_table[key] = value self.lua_table = new_tableif __name__ == '__main__': pyluatblparser = PyLuaTblParser() pyluatblparser.load('&#123;&#123;&#125;,nil,nil,2,3&#125;') pyluatblparser[1] = 1 print pyluatblparser[1] print pyluatblparser.dump() pyluatblparser[1] = &#123;&#125; print pyluatblparser.dump() # print repr(lua_str) # print str_parser.__removeComment(lua_str) # with open('sysinput2', 'r') as f: # lua_str = f.read() # pyluatblparser.load(lua_str) # outDict = pyluatblparser.dumpDict() # print outDict # result = outDict['root'][7] # print result[\"\\\\\\\"\\b\\f\\n\\r\\t`1~!@#$%^&amp;*()_+-=[]&#123;&#125;|;:',./&lt;&gt;?\"] # # print '\\n' # print pyluatblparser.dump() # # print result # # next = None # # for key,value in result.iteritems(): # # for k, v in value.iteritems(): # # if k == 7: # # next = v # # # # for k,v in next.iteritems(): # # print k ,'=', v # # print '\\n' # # pyluatblparser.dumpLuaTable('output') # # # with open('output', 'w') as out: # # new_str = pyluatblparser.dump() # # print new_str # # out.write(new_str) # # with open('output.lua', 'w') as out: # # out.write(result) 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960if __name__ == '__main__': # test multi table levels a1 = PyLuaTblParser() test_str = '&#123;array = &#123;65,23,5,&#125;,dict = &#123;mixed = &#123;43,54.33,false,9,string = \"value\",&#125;,array = &#123;3,6,4,&#125;,string = \"value\",&#125;,&#125;' a1.load(test_str) d1 = a1.dumpDict() print '&gt;&gt;&gt;&gt;&gt;', d1 print '===========================================================' # test file load a2 = PyLuaTblParser() a2.loadDict(d1) a2.dumpLuaTable('test_output') # test file dump a3 = PyLuaTblParser() a3.loadLuaTable('test_input') d3 = a3.dumpDict() print '&gt;&gt;&gt;&gt;&gt;', d3 print '===========================================================' # test complex string test_str = '&#123; strs = \"\\\\\"\\'\\\\\" \\\\t\\\\b\\\\f\\\\n\", [\"\\\\\"\\'\\\\\" \\\\t\\\\b\\\\f\\\\n\"] = \"complex string is key\"&#125;' print test_str a4 = PyLuaTblParser() a4.load(test_str) d4 = a4.dumpDict() print '&gt;&gt;&gt;&gt;&gt;', d4 print '===========================================================' # test comment test_str = '&#123;\\t\\n-- \"comment str\",\\t\\n[\"hello world\"] = 1,\\t\\n--[[\\t\\n\"should be comment\",\\t\\n2 = 1\\t\\n ]]\\t\\n[3] = 2\\n&#125;' print test_str a5 = PyLuaTblParser() a5.load(test_str) d5 = a5.dumpDict() print '&gt;&gt;&gt;&gt;&gt;', d5 print '===========================================================' # test [] test_str = '&#123;[1] = \"1\", a = \"a\"&#125;' print test_str a6 = PyLuaTblParser() a6.load(test_str) print '&gt;&gt;&gt;&gt;&gt;', a6.dump() a6[1] = \"changed\" print '&gt;&gt;&gt;&gt;&gt;', a6[1] print '&gt;&gt;&gt;&gt;&gt;&gt;', a6.dump() print '===========================================================' # test update test_str = '&#123;[1] = \"1\", a = \"a\"&#125;' print test_str a7 = PyLuaTblParser() a7.load(test_str) print '&gt;&gt;&gt;&gt;&gt;', a7.dump() update_table = &#123;1: [&#123;&#125;], \"b\": \"b\"&#125; a7.update(update_table) print '&gt;&gt;&gt;&gt;&gt;', a7.dump()","categories":[{"name":"python","slug":"python","permalink":"https://uyouii.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://uyouii.github.io/tags/python/"},{"name":"lua","slug":"lua","permalink":"https://uyouii.github.io/tags/lua/"}]},{"title":"合金装备V 幻痛 游戏评测","slug":"合金装备V-幻痛-游戏测评","date":"2017-12-21T15:35:35.000Z","updated":"2018-01-30T10:20:20.551Z","comments":true,"path":"2017/12/21/合金装备V-幻痛-游戏测评/","link":"","permalink":"https://uyouii.github.io/2017/12/21/合金装备V-幻痛-游戏测评/","excerpt":"","text":"游戏概述《合金装备V 幻痛》(Metal Gear Solid V: The Phantom Pain, 台译作“潜龙谍影V 幻痛”) 是一款由小岛制作（KONAMI旗下的王牌游戏研发工作室）开发的隐蔽类开放世界动作冒险游戏。它由小岛制作研发的游戏引擎“狐引擎”（FOX Engine）制作，在2015年9月1日发行于Microsoft Windows、PlayStation 3、PlayStation 4、Xbox 360和Xbox One平台。 游戏起初被分别公布为2个不同的项目，一个是在合金装备25周年纪念会上公布，名为《合金装备 原爆点》（Metal Gear Solid : Ground Zeroes），另一个则是由Moby Dick Studio开发的《幻痛》（Phantom Pain）。至2013年3月游戏网页正式上线，游戏名称才确定为《合金装备V 幻痛》。2013年11月11日，科乐美宣布《合金装备V 原爆点》独立于2014年春季发行。2014年德国Gamescom展，小岛秀夫宣布《幻痛》将借由Steam登上电脑平台。 游戏背景游戏设定在一个架空的冷战世界中，除了对峙的美国和苏联外，世界的格局还被一种名为“合金装备”的武器影响着。游戏的时间设定在《合金装备V 原爆点》九年之后，即1984年，此时游戏中和现实一样也在进行着阿富汗战争。尽管游戏大体和现实相同，但是玩家可以发现游戏内的武器和科技要远远比现实中的冷战时期先进，军事技术诸如外骨骼、双足机甲、光学隐形、全息影像都被各国谍报机关所使用着。其他科学技术诸如纳米技术、克隆、人工智能也进入了实用化的阶段。 主角Big Boss建立的佣兵组织“无界之师”在《合金装备V 原爆点》的结尾被摧毁，主角也陷入了长达9年的昏迷。醒来后世界也发生了翻天覆地的变化。《合金装备V 幻痛》讲述的是主角在苏醒后重新建立佣兵组织“Diamond Dogs”，并在“Snake”的代号下，在阿富汗和安哥拉-扎伊尔边境进行冒险，以向九年前摧毁自己亲手建立的无国界军队MSF的神秘人物”Skull Face”复仇。 配置要求 项目 最低配置 推荐配置 系统 Windows 7 Windows 7 处理器 i5-4460 i7-4790 内存 4GB RAM 8GB RAM 显卡 GeForce GTX 650或更好 GeForce GTX 760或更好 硬盘 28GB空闲空间 28GB空闲空间 资料来源：游民星空 游戏评测1. 游戏场景 9.0合金装备V是开放世界类的潜入冒险游戏。游戏中总共有两个比较大的开放式的地图，分别在中东地区的阿富汗和非洲地区，游戏的情节和任务也都在这两个地图中展开。 可以说合金装备5幻痛的游戏画面是日式游戏中少见的优质画面，几乎所有玩家在进入游戏之后都会在几分钟内被游戏所折服，可以说是真正的划时代之作。在画面的重大突破很大程度上得益于FOX引擎。2008年Kojima开发FOX引擎绝对是个目光长远之举，人们当时还没有意识到游戏画面可以进化到今天这个地步，但当时的“FOX引擎”团队致力于打造世界上最好的游戏引擎，也就是这个好高骛远的目标如今终于为日式游戏正名。 游戏中的场景可谓多种多样，甚至不做任务在游戏中闲逛也是一种乐趣。幻痛对游戏环境场景做了生动的还原。在游戏中你会发现各种植物和动物，有时还会遇到瀑布、峡谷、沼泽等等。游戏中会标出有用的药草和资源等等，收集药草可以用来制作药品和装备，甚至可以在基地出售换取游戏中的金币，进而开发装备。 游戏中的动物可以被主角用麻醉枪麻醉后送往基地（传送或虫洞技术）。游戏中有一个动物保护组织承诺主角收集动物后可以给予主角相应的声望和金币。甚至有个支线任务要求主角前往指定区域抓捕棕熊。 游戏中同样添加了气候和自然时间的设定。笔者总共体验过晴天、阴天、雨天和沙尘暴这几种气候。对于潜入型的游戏来说，这个设定更增添了游戏的趣味性。白天和黑夜会影响NPC的巡逻线路和视野，雨天可以很好的掩盖主角的脚步声，沙尘暴更是无压力潜入（偶尔会撞在敌人脸上…）。 地图上会散布着很多岗哨和敌人的大型据点，兵力和设备也会有所不同。随着游戏的推进，驻守的兵力也会不断增多，而且会根据玩家的入侵习惯不断调整，这是游戏一个特别新颖的地方。比如玩家入侵时喜欢爆头，则NPC会装配头盔、玩家喜欢在夜晚时入侵，敌人则会装备夜视仪等。敌人也会因为玩家的方式来采取不同的措施，他们会组队调查可以的地方对玩家进行包围，必要的时候会采用重武器对玩家进行压制（不止一次被榴弹炮和武装直升机干掉= =）。 幻痛的游戏环境是对现实的高度还原，人物的视觉和感官也做的十分逼真，使人们在玩游戏是的代入感十分强烈。唯一不足是游戏中的时间流逝设定比现实中快了不少，往往潜入敌方基地后还没完成任务天就亮了。俘虏敌人的回答和选项方面的设定也比较单一，希望增强游戏中NPC的多样性，更能增添游戏的趣味性。 2. 游戏玩法 9.5开放世界对于潜入游戏的核心玩法的改变可以说是革命性的，可以说完成游戏的方式完全取决于玩家自身，这款游戏基本没有固定的模式。潜入只是暗示玩家游戏的风格，但玩家完全可以按照自己的路线来完成。当然游戏推荐潜入的玩法确实具有挑战性，也更加考验玩家的耐心。 潜入时玩家可以选择晚上或者暴雨天气，之前先用望远镜标记好敌人的位置，为潜入工作打下基础。枪械方面也可以选择带消音管或者麻醉枪。因为这个游戏中玩家有一个自己的基地，俘虏敌人并传送回基地可以加强基地的建设工作，促进武器的研发和资源的收集。具有特殊技能的NPC也会带来意想不到的好处。例如当你回收一名具有翻译技能的人员后你就能够听懂敌人交流的语言了。 在不惊动其他敌人的情况下俘虏敌人也可以获得一些关键性的情报，例如指挥所的位置，蓝图的地点，钻石的地点，具有特殊技能的人员（专家）是哪些等。在进行主线任务时，通过审问敌人可以得到完成主线任务的线索。这些设定都增加了游戏的趣味性和挑战性。 当然对于没有耐心的玩家这些都是虚的，正面刚才是王道呀。背着火箭炮，空投坦克，穿着重型装甲就可以攻占下来一个基地了，任务什么的在进去探索就行了。这样魂斗罗式的玩法也别有一番趣味。 游戏中NPC使用的任何车辆和武器玩家都可以使用，包括榴弹炮，火箭发射车等，不过在坦克中如果被敌人集火攻击的话也很容易被干掉。 3. 游戏装备和资源 9.0第三人称射击类的游戏怎么会少了武器枪械。合金装备V 中的枪械种类可以说是花样繁多，不管是现实中存在的或者是改版的都有在游戏中体现出来。 武器的研发是在玩家的基地中实现的。玩家通过不断升级研发平台可以不断解锁新的武器装备。研发平台的升级需要人员扩中和基地基础设施研发来完成，部分武器还需要武器蓝图和专业人员存在才可以解锁。 武器的研发是按照树状图的方式进行的，即一类武器只有将其之前的武器解锁后，才可以继续研发更加先进的武器。 玩家在游戏中可以选择各种不同的枪械，不同的武器也拥有不同的功能。玩家在进行任务时，不仅可以呼叫直升机空投武器资源，还可以空投之前回收的武器车辆等，例如双足机器人和坦克。 玩家在执行任务时回收的资源很多会运回基地用于基地基础设施的开发和武器的研究。 玩家可以随时回到基地，有时会触发一些剧情。在基地中有些地方会出现一些试炼任务，完成后会给玩家提供大量的游戏金币。在基地中闲逛的时候偶尔会发现一些钻石碎片，同样可以兑换大量的GMP（游戏金币）。小岛的幽默依然不减，基地中偶尔也会出现一些日式风格的海报，收集后同样可以兑换一下GMP。 在基地的建设中，人员素质占了很大一部分比重。基地人员的能力与基地的研发等级相挂钩。主角的声望越高，越容易招募到高素质的成员。同时玩家在执行任务时对高素质人员的回收也很重要。这同时也暗示了玩家幻痛不仅仅是一个枪战游戏，更重要的是策略和思维。 游戏中黑科技依然不少，寄生虫，人体改造，基因技术，机械手臂，双足机器等。一些超自然的设定和剧情也为游戏增添的不少魔幻主义色彩，很多时候玩家在进行游戏的时候都会有一种惊心动魄的感觉，有些NPC是真的太恐怖了！ 4 游戏剧情 9.9合金装备V 幻痛剧情只是整个合金装备游戏系列的一个中间阶段，它讲述的是Snake在基地被摧毁，经历了长达9年的昏迷之后，在山猫和米勒的帮助下，投身于阿富汗战场，并重新建立佣兵组织钻石狗的故事。这些剧情和往届合金装备游戏的剧情都属于同一种风格，但是不同的是，幻痛中竟然出现了女主！这个设定真的是让不少玩家去趋之若鹜呀，真的是一直在刷妹子的好感度。什么主线剧情的先不管了，最终主角是把大反派“Skull Face”消灭了，我们还是围绕静静来介绍。 女主的名字叫做“Quiet”，顾名思义，意思是女主从来都不说话，至于原因我们会在后面揭晓。 玩家在进行到第11次主线任务时，会触发一次隐藏剧情，在阿富汗某地区会遇到一名强大的女狙击手。不仅身法快捷，而且还会隐身伪装的能力，狙击能力也特别强。这时候玩家就要想办法战胜这位女狙击手。当任务完成后，基地一个NPC会要求玩家杀掉Quiet，认为他是“Skull Face”的人，而另一个NPC则认为可以俘虏Quiet到基地来观察一段时间。这时候玩家就可以选择是否要杀掉Quiet。我觉得正常的玩家肯定会把Quiet带回基地啊！这么漂亮的女主。 游戏的第一个任务是要让昏迷了9年的主角逃出医院。当主角还在医院中的时候，“Skull Face”曾派遣了一位女特工来刺杀主角，结果被主角和一位NPC联手烧伤后不知所踪。细心的玩家会发现者刺杀主角的女特工和静静其实是同一个，由此可以推断Quiet是来复仇的。 当Quiet来到基地以后，基地的NPC发现他们根本控制不住Quiet（根本打不过），Quiet也从不说话，但是只听主角一个人的指挥，Quiet就只能暂时被关押起来。后来一次机缘巧合基地的NPC同意主角带上Quiet一起执行任务。这时玩家会发现Quiet来了以后，执行任务的速度简直事半功倍呀，有时Quiet自己就可以团灭一个敌方基地。 后来主角建立的基地会面临一种灾难，就是不断有成员得一种怪病死去，原因要主角自己调查。在见到密语者（NPC）之后得知这场疾病是由于声带寄生虫引起的。声带寄生虫是指一种寄生到人的声带，根据人的语言种类来进行繁殖的一种寄生虫。只会感染说某种特定语言的群体并繁殖，感染到基本无药可救，而且传染性极强。声带寄生虫是“Skull Face”从密语者哪里获得后拿来进行人体改造实验。静静的特殊能力、以及“Skull Face”身边的一些NPC都是寄生虫改造的产物，因此具有了异于常人的能力。 Quiet和主角的关系也在一次次的任务中不断升温，Quiet和boss这雨中嬉戏的这个画面相信让很多玩家难以忘怀，本以为主角和Quiet最后能走在一次，可是忘了编剧喜欢悲剧的这个事实（寄过刀片了有没有）。 游戏的第30个主线任务完成后，也就是主角终于将最终Boss“Skull Face”杀掉后，会说明一个关键信息。“Skull Face”共制造了三支英语种的寄生虫，可是现在只剩下两支……相信细心的读者已经明白了剩下的一支到哪里去了，但是笔者没想到结果会来的这么突然。 在任务推进到一定程度，会出现隐藏的45号主线任务。任务会提示静静突然消失了，然后主角得知静静被苏联人抓走了，笔者当时第一反应当然是干翻他们找到静静啊！说实话这个关卡挺难的。 关卡任务是玩家要和静静一起摧毁掉苏联军队的一个坦克部队。当玩家摧毁所有地图上的敌军后，会进入下一段剧情。主角以为所有坦克都被摧毁，但一辆没有完全摧毁的坦克已经悄悄瞄准了主角。静静因为不能说话，一把抢过主角的火箭炮摧毁了坦克，但是也被炮弹击中，陷入昏迷，也就在这时，敌军的增援部队赶到，主角要带着静静从这个绝望之地逃出。 主角和静静躲在了一处岩石后，敌人的搜查部队就在眼前，由于沙尘暴的原因主角和静静躲过了一劫，但主角却因此被眼镜蛇咬伤，而后同样陷入昏迷（眼镜蛇是神经性毒素，可以致命）。主角后来在半睡半醒中听到救援直升机赶到，但因为沙尘暴找不到正确的方位。当救援直升机得不到应答，正要返回的时候，静静说出了英语。相信大家都猜到了，静静是英语语种的寄生虫携带者，所以她从不说话。之前“Skull Face”派遣她来就是为了感染主角，但是她没有这样做。在最后时刻她为了救主角却牺牲了自己。静静在直升机到来后，看了主角最后一眼，然后离开。 主角得到救援后发现静静不在，但跟着脚印在一处山顶上发现了静静留下的一个录音磁带。里面说：1234567891011I did not choose to be Quiet.I wanted to express my feelings to you.If only we shared a common tongue.Vengeance was what drove me to them...The only language left to me, revenge.But the words we shared...No, that was no language at all.That&apos;s why I...I chose the language of gratitude instead, and go back to silence.I am Quiet...I am... The absence of words... 从此静静便淡出了玩家的视野，但是回到基地后会发现静静已经列入了基地的死亡名单，直升机上静静的相片也不见了，再也不会有静静的身影了…… 当笔者玩到这里的时候真的是非常的虐心，但是毕竟程序员们的智慧是无限的，虽然网友通过替换文件的方法可以重新找回静静，但是再也没有和静静有关的任务了。 游戏剧情的设计让玩家们如此着迷，甚至主线任务通关后仍然想要找回女主的身影，更让无数玩家尝试各种方法寻回静静，真心满分。 在静静淡出后，游戏的最终关卡也出现了。玩家们发现这个最终关卡和第一关基本一样，但是却揭示了和第一关完全不同的结局。原来玩家操控的主角一直都不是真正的Big Boss，而是Big Boss的一个替身，这个秘密只有将主角救出的山猫一个人知道。真正的Big Boss已经去了其他地方开辟新的基地。游戏开始会让玩家自定义自己的外貌属性，但是在第一关却没有体现出来，直到现在自定义的外貌的选项才出现。原来这个游戏本身就是一场幻痛…… 笔者个人觉得，游戏的画面感和操作倒是其次，游戏的剧情才是游戏真正的灵魂。一个没有剧情的游戏很容易让人感到无聊，但是游戏的剧情却可以让人回味无穷。 5. 游戏音效 9.0游戏的音效方面的效果也是很棒的，游戏中的所有的音效都是立体音，玩家在游戏中的时候，无论是风声，鸟叫声或者是流水的声音都非常的真实，仿佛真的置身于野外一样。在执行任务的时候，敌人的交谈声和脚步声也是非常重要的信息。 游戏中也穿插了大量的70、80年代的大量的经典的歌曲。在执行任务的过程中，玩家可以在敌人的据点或者基地中可以发现一些录音机，从而获得一些磁带，来解锁一些游戏中的经典的歌曲。 这些歌曲玩家可以在任务栏的磁带中收听。在基地中的女主的房间中，玩家可以听到收集来的磁带中的歌曲。女主的房间中有彩蛋的哦。在女主的房间中偶尔可以看到女主在洗澡哦！ 6. 综合评价 9.5很多人对《合金装备V 幻痛》的评价颇高，在笔者看来，有两个主要的原因： 游戏具有超高的自由度。玩家不会再被任务限制在一个狭小的空间内，相反是在两个巨大的沙盒式的世界中。 游戏有着行云流水般的剧情体验，而不是生硬的强迫性的过场。 这两个体验往往不会兼得，重视了一项，就会影响另一项。《合金装备V 幻痛》做到了二者的水乳交融，可以说是行业的顶尖的神作。 游戏具有意义的复杂性、灵活的潜入选择、海量的道具和能力也带给了玩家更加丰富的游戏体验，不可不玩的游戏之一。 媒体评价IGN —— 10/10 “《合金装备5：幻痛》是一款拥有奇迹般的游戏玩法、需要玩家动用自己的创造力和智力的游戏——没有多少游戏可以做成这样。” Gamespot —— 10/10 “每一个粉丝都会有自己喜爱的《合金装备》作品，可能在这方面玩家没有统一的意见。但是《合金装备5：幻痛》的出现解决了这个问题。《合金装备》系列中没有哪一部作品会如此有深度，会有如此丰富的游戏内容。游戏中的开放世界令整体素质更上一个台阶。《幻痛》无疑是合金装备系列中最好的作品。” Daily Dot 5/5 “小岛很机智，他将故事讲的很含蓄。玩家只有在事后才会意识到，原来之前的每件叙事都是有一些深刻的含义的。” Game Informer 9.25/10 “一个游戏系列如果没有进化将很难长久的生存下去，《合金装备5：幻痛》就是一个勇于冒险的证明。一个开放世界，一个可自定义的基地，一个多变的任务体系——这些都不曾是传统《合金装备》系列中的元素，但正是这些令《幻痛》如此出色。”","categories":[{"name":"game","slug":"game","permalink":"https://uyouii.github.io/categories/game/"}],"tags":[{"name":"game","slug":"game","permalink":"https://uyouii.github.io/tags/game/"},{"name":"interview","slug":"interview","permalink":"https://uyouii.github.io/tags/interview/"}]},{"title":"KCP 源码阅读","slug":"KCP-源码阅读","date":"2017-12-21T14:01:04.000Z","updated":"2018-01-30T10:19:51.841Z","comments":true,"path":"2017/12/21/KCP-源码阅读/","link":"","permalink":"https://uyouii.github.io/2017/12/21/KCP-源码阅读/","excerpt":"","text":"KCP项目地址： KCP - A Fast and Reliable ARQ Protocol 版权声明：本文为博主原创文章，转载请注明出处。 作者: Uyouii 简介KCP是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，以 callback的方式提供给 KCP。 连时钟都需要外部传递进来，内部不会有任何一次系统调用。 主要数据结构IKCPSEGIKCPSEG是kcp的数据段结构，即储存需要发送的packet的内容。1234567891011121314151617struct IKCPSEG&#123; struct IQUEUEHEAD node; // 双向链表定义的队列 IUINT32 conv; // conversation, 会话序号: 接收到的数据包与发送的一致才接收此数据包 IUINT32 cmd; // command, 指令类型: 代表这个Segment的类型 IUINT32 frg; // fragment, 分段序号 IUINT32 wnd; // window, 窗口大小 IUINT32 ts; // timestamp, 发送的时间戳 IUINT32 sn; // sequence number, segment序号 IUINT32 una; // unacknowledged, 当前未收到的序号: 即代表这个序号之前的包均收到 IUINT32 len; // length, 数据长度 IUINT32 resendts; // 重发的时间戳 IUINT32 rto; // 超时重传的时间间隔 IUINT32 fastack; // ack跳过的次数，用于快速重传 IUINT32 xmit; // 发送的次数(即重传的次数) char data[1];&#125;; IKCPCBIKCPCB是kcp的控制块，用于控制packet的发送，接收，重传等操作。 buffer的发送和接收均调用外部传入的函数。IKCPCB只负责处理算法层面的逻辑。 12345678910111213141516171819202122232425262728293031323334353637struct IKCPCB&#123; //conv:会话ID，mtu:最大传输单元，mss:最大分片大小，state:连接状态 IUINT32 conv, mtu, mss, state; //sun_una：第一个未确认的包，sen_nxt：待发送包的序号，rcv_nxt：待接收消息的序号 IUINT32 snd_una, snd_nxt, rcv_nxt; //ssthresh:拥塞窗口的阈值 IUINT32 ts_recent, ts_lastack, ssthresh; //rx_rttval：ack接收rtt浮动值，rx_srtt：ack接收rtt平滑值(smoothed)，rx_rto：由ack接收延迟计算出来的复原时间，rx_minrto：最小复原时间 IINT32 rx_rttval, rx_srtt, rx_rto, rx_minrto; //sen_wnd：发送窗口大小，rcv_wnd：接收窗口大小，rmt_wnd：远端接收窗口大小，cwnd：拥塞窗口大小，probe 探查变量，IKCP_ASK_TELL表示告知远端窗口大小。IKCP_ASK_SEND表示请求远端告知窗口大小。 IUINT32 snd_wnd, rcv_wnd, rmt_wnd, cwnd, probe; //currunt：当前的时间戳，interval：内部flush刷新间隔，ts_flush：下次flush刷新时间戳 IUINT32 current, interval, ts_flush, xmit; IUINT32 nrcv_buf, nsnd_buf; IUINT32 nrcv_que, nsnd_que; //nodelay：是否启动无延迟模式，update：是否调用过update函数的标识(kcp需要上层通过不断的ikcp_update和ikcp_check来驱动kcp的收发过程) IUINT32 nodelay, updated; //ts_probe：下次探查窗口的时间戳，probe_wait：探查窗口需要等待的时间 IUINT32 ts_probe, probe_wait; //dead_link：最大重传次数，incr：可发送的最大数据量 IUINT32 dead_link, incr; struct IQUEUEHEAD snd_queue; //发送消息的队列 struct IQUEUEHEAD rcv_queue; //接收消息的队列 struct IQUEUEHEAD snd_buf; //发送消息的缓存 struct IQUEUEHEAD rcv_buf; //接收消息的缓存 IUINT32 *acklist; //待发送的ack的列表 IUINT32 ackcount; //ack数量 IUINT32 ackblock; //acklist的大小 void *user; char *buffer; //储存消息字节流的内存 int fastresend; //触发快速重传的重复ack个数 int nocwnd, stream; //nocwnd：取消拥塞控制，stream：是否采用流传输模式 int logmask; int (*output)(const char *buf, int len, struct IKCPCB *kcp, void *user); //发送消息的回调函数 void (*writelog)(const char *log, struct IKCPCB *kcp, void *user);&#125;; KCP网络包头结构123456789101112131415|&lt;------------ 4 bytes ------------&gt;|+--------+--------+--------+--------+| conv | conv：Conversation, 会话序号，用于标识收发数据包是否一致+--------+--------+--------+--------+ cmd: command，用于标识指令，例如：push，ack等| cmd | frg | wnd | frg: Fragment, 分段序号，序号从大到小+--------+--------+--------+--------+ wnd: 接收窗口大小| ts | ts: 发送的时间戳+--------+--------+--------+--------+| sn | sn: Segment序号+--------+--------+--------+--------+| una | una: Unacknowledged, 当前未收到的序号，即代表这个序号之前的包均收到+--------+--------+--------+--------+ | len | len: data数据的长度+--------+--------+--------+--------+ kcp包头总共占用了24个字节。给sn分配了4个字节，可以不用考虑序号越界的问题。 KCP工作流程发送数据kcp首先将要发送的数据存到kcp-&gt;buffer中，如果需要发送的数据总量的大小大于kcp-&gt;mtu，则将buffer中的数据调用output函数发送出去，output函数由用户传入。 kcp数据包发送顺序： IKCP_CMD_ACK(ack) IKCP_CMD_WASK(请求远程窗口大小) IKCP_CMD_WINS(发送本地窗口大小) IKCP_CMD_PUSH(push data) 在发送PUSH类型的数据时，首先需要将数据从sen_que移动到sen_buf中（在移动时会检测拥塞窗口的大小，sen_que可以理解为发送数的缓冲队列）。 kcp在发送sen_buf队列中的数据时会检测是否是第一次发送： 如果该segment的发送次数为0，则直接发送。 如果发送次数大于0并且已经超时，则再次发送并调整rto和下次超时时间 如果没有超时但是达到了快速重传的条件（被跳过了几个包），则发送并且更新下次超时时间。 函数解析Input1int ikcp_input(ikcpcb *kcp, const char *data, long size) 处理接收到的数据，data即用户传入的数据。kcp不负责网络数据的接收，需要用户将接收到的数据传入。 在接收到数据后，解析数据得到segment的sn，una等数据包头信息。首先根据una清除掉kcp-&gt;snd_buf中已经确认接收到的segment（una即表示该seg之前数据包均已收到），随后根据kcp-&gt;sen_buf更新kcp-&gt;snd_una。 ack: IKCP_CMD_ACK，首先根据该segment的rtt更新计算kcp的rtt和rto，删除掉kcp-&gt;snd_buf中相应的segment，更新kcp的sed_una(下一个未确认的segment)。 push:IKCP_CMD_PUSH，收到push segment后需要发送ack，将该segment的sn和ts放入kcp-&gt;acklist中。 如果该seg符合滑动窗口的范围，则将该segment放入kcp-&gt;rev_buf中。 如果kcp-&gt;queue的大小小于kcp-&gt;rev_wnd(滑动窗口的大小)，则将kcp-&gt;rev_buf符合条件的segment放入kcp-&gt;rcv_queue中(保证序号连续的seg)。 window ask: IKCP_CMD_WASK,将kcp-&gt;probe中相应位置为1，发送segment时向远端发送相应接收窗口大小。 IKCP_CMD_WINS，对应远端的窗口更新包，无需做额外的操作。 随后遍历kcp-&gt;sed_buf，更新每个segment的seg-&gt;fastack(被跳过的次数，用于判断是否需要快速重传)。 如果远端接收状态有更新，则更新本地拥塞窗口的大小。 Receive1int ikcp_recv(ikcpcb *kcp, char *buffer, int len) 用户层面的数据读取，从rcv_queue中读取一个packet（如果该packet在发送前分段的话，则将fragement合并后放入buffer中）。input的操作保证了rcv_queue中的segment都是有序且连续的。 随后如果rcv_queue大小小于rcv_wnd（接收窗口）的大小，则将rcv_buf中合适的segment放入rcv_queue中。 如果需要告知远端主机窗口大小，则1kcp-&gt;probe |= IKCP_ASK_TELL 将ICKP_ASK_TELL置为1。 Send1int ikcp_send(ikcpcb *kcp, const char *buffer, int len) 将buffer中需要发送的数据分片后放入snd_queue中。 在发送数据时，会首先检测是否开启了流模式。如果开启流模式，在发送数据时，如果上一个segment没有填满mss（最大分片大小），则将这次要发送的数据继续写入上一个segment。如果没有开启流模式，则创建一个新的segment发送。 如果需要发送的数据大小大于mss，则将其拆分为多个segment发送，如果不是流模式，则将其frg至为其相应的序号，序号从count-1开始递减至0，即count-1表示第一个segment，0表示最后一个segment。 Flush1void ikcp_flush(ikcpcb *kcp) flush data，即发送需要发送的数据，ack，win probe，push data等，以及检测snd_buf中的数据是否需要重传。 将seg的wnd设置为接收窗口的剩余大小1kcp-&gt;rcv_wnd - kcp-&gt;nrcv_que nrcv_que指接收队列中的segment的数量。 在发送时将需要发送的数据填充到buffer中，如果buffer下次填入的数据量 &gt; mtu，则调用output函数将buffer中的数据发送出去，ouotput函数由用户定义。 发送segment首先将acklist中需要发送的ack发送出去，kcp在发送时会优先发送ack。 如果远端接收窗口大小为0且当前时间超过下次发送窗口探测时间，则1kcp-&gt;probe |= IKCP_ASK_SEND; 并更新窗口探测时间间隔和下次窗口探测时间。 如果需要探测远端发送窗口大小或者需要告诉远端本机发送窗口大小，则发送相应的probe segment。 取拥塞窗口的大小为发送窗口和远端接收窗口的最小值。在已经发送的segment的数量不超过拥塞窗口大小时将送sed_queue中的segment放入snd_buf中。 遍历snd_buf中的数据： 如果之前没有发送过，则设置其rto和超时重传时间，并将needsend置为1. 如果snd_buf中的segment超过其超时重传时间，如果启动无延时模式，则将segment的rto1.5，否则将rto 2，并将needsend置为1。 如果启动了快速重传并且该segment被跳过的次数大于resent，则将needsend置为1，并更新该segment的超时时间。 如果needsend被置为1，则将该segment发送出去。 如果segment的重传次数超过kcp的最大重传次数，则更新kcp的连接状态为-1。 发送之后更新ssthresh(拥塞窗口阈值)和cwnd(拥塞窗口大小)。","categories":[{"name":"network","slug":"network","permalink":"https://uyouii.github.io/categories/network/"}],"tags":[{"name":"kcp","slug":"kcp","permalink":"https://uyouii.github.io/tags/kcp/"},{"name":"network","slug":"network","permalink":"https://uyouii.github.io/tags/network/"},{"name":"coderead","slug":"coderead","permalink":"https://uyouii.github.io/tags/coderead/"}]},{"title":"剑指offer题解","slug":"剑指offer题解","date":"2017-12-21T13:15:39.000Z","updated":"2018-01-30T10:20:31.674Z","comments":true,"path":"2017/12/21/剑指offer题解/","link":"","permalink":"https://uyouii.github.io/2017/12/21/剑指offer题解/","excerpt":"","text":"剑指offer上的一些算法题解。 1 ~ 10 Problems01 赋值运算符函数题目：123求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。 12345678910111213141516171819202122class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int result = 0; int index = 10; while (index / 10 &lt;= n) &#123; int res = n / index, rem = n % index; if(res &gt;= 1) result += res * index / 10; if (rem &gt;= 2 * index / 10) &#123; result += index / 10; &#125; else if(rem &gt;= index / 10 )&#123; result += rem - (index / 10) + 1; &#125; index *= 10; &#125; return result; &#125;&#125;; 03 数组中重复的数字题目：123在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组&#123;2, 3, 1, 0, 2, 5, 3&#125;，那么对应的输出是重复的数字2或者3。 123456789101112131415bool duplicate(int numbers[], int length, int* duplication) &#123; if (!numbers || length &lt;= 0) return false; for (int i = 0; i &lt; length; i++) &#123; while (numbers[i] != i) &#123; if (numbers[i] == numbers[numbers[i]]) &#123; *duplication = numbers[i]; return true; &#125; swap(numbers[i], numbers[numbers[i]]); &#125; &#125; return false;&#125; 04 二维数组中的查找题目：123在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 12345678910111213141516171819202122//每次比较右上角的元素和target的关系，选择剔除行或者列//如果该数字等于要查找的数字，则查找过程结束//如果该数字中大于要查找的数字，则剔除这个字所在的列//如果这个字小于要查找的数字，则提出这个字所在的行bool Find(int* matrix, int rows, int columns, int number) &#123; if (!matrix || rows &lt;= 0 || columns &lt;= 0) return false; int index, r = 0, c = columns - 1; while (r &lt; rows &amp;&amp; c &gt;= 0) &#123; index = r * columns + c; if (matrix[index] == number) return true; else if (matrix[index] &lt; number) &#123; ++r; &#125; else if (matrix[index] &gt; number) &#123; --c; &#125; &#125; return false;&#125; 05 替换空格题目：1请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;。例如输入“We are happy.”，则输出“We%20are%20happy.”。 12345678910111213141516171819202122232425262728293031//先遍历一遍字符串得到其中空格的数量//然后从后面开始替换，时间复杂度O(n),空间复杂度O(1)//length 为字符串的总容量void ReplaceBlank(char string[], int length) &#123; if (!string || length &lt;= 0) return; int blankNum = 0; int oldl = 0; for (; string[oldl] != '\\0'; oldl++) &#123; if (string[oldl] == ' ') ++blankNum; &#125; int newLength = oldl + 2 * blankNum; if (newLength &gt; length) return; int l1 = newLength - 1, l2 = oldl - 1; while (l2 &gt;= 0) &#123; if (string[l2] != ' ') &#123; string[l1--] = string[l2--]; &#125; else &#123; string[l1--] = '0'; string[l1--] = '2'; string[l1--] = '%'; --l2; &#125; &#125;&#125; 06 从尾到头打印链表题目：1输入一个链表的头结点，从尾到头反过来打印出每个结点的值。 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; if (!head) return &#123;&#125;; ListNode* node = head; vector&lt;int&gt; result; while (node) &#123; result.push_back(node-&gt;val); node = node-&gt;next; &#125; reverse(result.begin(), result.end()); return result; &#125;&#125;; 07 重建二叉树题目：123输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列&#123; 1,2,4,7,3,5,6,8 &#125;和中序遍历序列&#123; 4,7,2,1,5,3,8,6 &#125;，则重建二叉树并返回。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre, vector&lt;int&gt; vin) &#123; if (pre.size() == 0 || vin.size() == 0 || pre.size() != vin.size()) return NULL; return createTree(pre, 0, pre.size() - 1, vin, 0, vin.size() - 1); &#125; TreeNode* createTree(vector&lt;int&gt;&amp; pre, int p_begin, int p_end, vector&lt;int&gt;&amp; vin, int v_begin, int v_end) &#123; if (p_begin == p_end) &#123; return new TreeNode(pre[p_begin]); &#125; if (p_begin &gt; p_end) return NULL; int v_head; for (v_head = v_begin; v_head &lt;= v_end; v_head++) &#123; if (vin[v_head] == pre[p_begin]) break; &#125; TreeNode* head = new TreeNode(vin[v_head]); if (v_head &gt; v_begin) &#123; int l = v_head - v_begin; head-&gt;left = createTree(pre, p_begin + 1, p_begin + l, vin, v_begin, v_head - 1); &#125; if (v_head &lt; v_end) &#123; int l = v_end - v_head; head-&gt;right = createTree(pre, p_end - l + 1, p_end, vin, v_head + 1, v_end); &#125; return head; &#125;&#125;; 08 二叉树的下一个节点题目：12给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 123456789101112131415161718192021class Solution &#123;public: TreeLinkNode* GetNext(TreeLinkNode* pNode)&#123; if (!pNode) return NULL; if (pNode-&gt;right) &#123; TreeLinkNode* node = pNode-&gt;right; while (node-&gt;left) node = node-&gt;left; return node; &#125; else &#123; TreeLinkNode* node = pNode; while (node-&gt;next &amp;&amp; node-&gt;next-&gt;right == node) node = node-&gt;next; return node-&gt;next; &#125; &#125;&#125;; 09 用两个栈实现队列题目：12用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 12345678910111213141516171819202122232425262728293031323334353637//很厉害//一个push栈，一个pop栈class Solution&#123;public: void push(int node); int pop();private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;;void Solution::push(int node) &#123; this-&gt;stack1.push(node);&#125;int Solution::pop() &#123; int result = 0; if (this-&gt;stack2.size() &gt; 0) &#123; result = stack2.top(); this-&gt;stack2.pop(); &#125; else &#123; while (stack1.size() &gt; 0) &#123; stack2.push(stack1.top()); stack1.pop(); &#125; if (stack2.size() &gt; 0) &#123; result = stack2.top(); stack2.pop(); &#125; &#125; return result;&#125; 10 斐波那契数列题目：12大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n &lt;= 39 123456789101112131415class Solution &#123;private: vector&lt;int&gt; fibArray;public: int Fibonacci(int n) &#123; if (n == 0 || n == 1) return n; fibArray = vector&lt;int&gt;(n + 1, 0); fibArray[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; fibArray[i] = fibArray[i - 1] + fibArray[i - 2]; &#125; return fibArray[n]; &#125;&#125;; 11 ~ 20 Problems11 旋转数组的最小数字题目：1234把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组&#123; 3,4,5,1,2 &#125;为&#123; 1,2,3,4,5 &#125;的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 12345678910111213141516class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; int begin = 0, end = rotateArray.size() - 1; while (begin &lt; end &amp;&amp; rotateArray[begin] &gt;= rotateArray[end]) &#123; int mid = (begin + end) / 2; if (rotateArray[mid] &gt;= rotateArray[end]) &#123; begin = mid + 1; &#125; else if (rotateArray[mid] &lt; rotateArray[end]) &#123; end = mid; &#125; &#125; return rotateArray[begin]; &#125;&#125;; 12 矩阵中的路径题目：12345请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; int rows, cols; vector&lt;vector&lt;bool&gt;&gt; mark;public: bool hasPath(char* matrix, int rows, int cols, char* str) &#123; if (!matrix || rows &lt;= 0 || cols &lt;= 0) return false; this-&gt;mark = vector&lt;vector&lt;bool&gt;&gt;(rows, vector&lt;bool&gt;(cols, false)); this-&gt;rows = rows; this-&gt;cols = cols; char* c = matrix; bool result = false; for (int i = 0; i &lt; strlen(matrix); i++) &#123; if (matrix[i] == *str) &#123; result = found(matrix, str, i / cols, i % cols); &#125; if (result) break; &#125; return result; &#125;private: bool found(char* matrix, char* str, int x,int y) &#123; if (*str == '\\0') return true; if (x &lt; 0 || x &gt;= rows || y &lt; 0 || y &gt;= cols) return false; int index = x * cols + y; bool result = false; if (!mark[x][y] &amp;&amp; matrix[index] == *str) &#123; mark[x][y] = true; if (!result) result = found(matrix, str + 1, x - 1, y); if (!result) result = found(matrix, str + 1, x + 1, y); if (!result) result = found(matrix, str + 1, x, y - 1); if (!result) result = found(matrix, str + 1, x, y + 1); mark[x][y] = false; &#125; return result; &#125;&#125;; 13 机器人的运动范围题目:123456地上有一个m行和n列的方格。一个机器人从坐标0, 0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35, 37），因为3 + 5 + 3 + 7 = 18。但是，它不能进入方格（35, 38），因为3 + 5 + 3 + 8 = 19。请问该机器人能够达到多少个格子？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123;public: int movingCount(int threshold, int rows, int cols) &#123; if (threshold &lt; 0) return 0; vector&lt;bool&gt; check(rows * cols, 0); queue&lt;int&gt; search; search.push(0); check[0 ] = true; int result = 1; while (search.size() &gt; 0) &#123; int point = search.front(); int x = point / cols, y = point % cols; search.pop(); if (x &gt; 0 &amp;&amp; count(x - 1, y) &gt; threshold) &#123; check[point - cols] = true; &#125; else if (x &gt; 0 &amp;&amp; !check[point - cols]) &#123; search.push(point - cols); check[point - cols] = true; ++result; &#125; if (x &lt; rows - 1 &amp;&amp; count(x + 1, y) &gt; threshold) &#123; check[point + cols] = true; &#125; else if (x &lt; rows - 1 &amp;&amp; !check[point + cols]) &#123; search.push(point + cols); check[point + cols] = true; ++result; &#125; if (y &gt; 0 &amp;&amp; count(x, y - 1) &gt; threshold) &#123; check[point - 1] = true; &#125; else if (y &gt; 0 &amp;&amp; !check[point - 1]) &#123; search.push(point - 1); check[point - 1] = true; ++result; &#125; if (y &lt; cols - 1 &amp;&amp; count(x, y + 1) &gt; threshold) &#123; check[point + 1] = true; &#125; else if (y &lt; cols - 1 &amp;&amp; !check[point + 1]) &#123; search.push(point + 1); check[point + 1] = true; ++result; &#125; &#125; return result; &#125;private: int count(int rows, int cols) &#123; int result = 0; while (rows &gt; 0) &#123; result += rows % 10; rows /= 10; &#125; while (cols &gt; 0) &#123; result += cols % 10; cols /= 10; &#125; return result; &#125;&#125;; 14 剪绳子题目：123给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]*k[1]*…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。 123456789101112131415161718//如果不知道结论的话可以用动态规划的方法实现//结论：如果剩下的长度仍大于等于5，则尽可能的减成长度为3的绳子//如果小于5，则不变int maxProductAfterCutting(int length) &#123; if (length &lt;= 0) return 0; if (length &lt;= 4) return length; int time3 = length / 3; int rem = length % 3; if (rem == 1) &#123; return 4 * (int)(pow(3, time3 - 1)); &#125; if (rem == 0) return (int)(pow(3, time3)); else return (int)(pow(3, time3)) * rem;&#125; 15 二进制中1的个数题目：1输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 12345678910111213141516//直接将n右移可能会因为n为负数造成死循环//正常解法是用一个flat每次左移和原来的数进行&amp;运算//这里采用一种新解法//n &amp; (n - 1) 相当于将一个数最右边的1变成0class Solution &#123;public: int NumberOf1(int n) &#123; int count = 0; while (n) &#123; n = n &amp; (n - 1); ++count; &#125; return count; &#125;&#125;; 16 数值的整数次方法题目：1给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 12345678910111213141516171819202122232425class Solution &#123;public: double Power(double base, int exponent) &#123; if (exponent == 0) return 1; bool flag = false; if (exponent &lt; 0) &#123; flag = true; exponent = -exponent; &#125; double result = 1.0; double temp = base; while (exponent &gt; 0) &#123; if (exponent &amp; 1) &#123; result *= temp; &#125; exponent &gt;&gt;= 1; temp *= temp; &#125; if (flag) &#123; result = 1 / result; &#125; return result; &#125;&#125;; 18 删除链表中重复的节点题目：123在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 12345678910111213141516171819202122232425262728class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; if (!pHead) return pHead; ListNode* head = new ListNode(0); head-&gt;next = pHead; ListNode* node = head, *tem; while (node) &#123; if (node-&gt;next &amp;&amp; node-&gt;next-&gt;next &amp;&amp; node-&gt;next-&gt;val == node-&gt;next-&gt;next-&gt;val) &#123; int val = node-&gt;next-&gt;val; while (node-&gt;next &amp;&amp; node-&gt;next-&gt;val == val) &#123; tem = node-&gt;next; node-&gt;next = node-&gt;next-&gt;next; delete tem; &#125; &#125; //需要注意! else &#123; node = node-&gt;next; &#125; &#125; pHead = head-&gt;next; delete head; return pHead; &#125;&#125;; 19 正则表达死匹配题目：1234请实现一个函数用来匹配包括&apos;.&apos;和&apos;*&apos;的正则表达式。模式中的字符&apos;.&apos;表示任意一个字符，而&apos;*&apos;表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: bool match(char* str, char* pattern) &#123; if (!str &amp;&amp; !pattern) return true; int M = strlen(str); int N = strlen(pattern); vector&lt;vector&lt;bool&gt;&gt; check(M + 1, vector&lt;bool&gt;(N + 1, false)); check[0][0] = true; for (int k = 1; k &lt;= N; k++) &#123; check[0][k] = (k &gt;= 2 &amp;&amp; pattern[k - 1] == '*' &amp;&amp; check[0][k - 2]); &#125; for (int i = 1; i &lt;= M; i++) &#123; for (int j = 1; j &lt;= N; j++) &#123; if (pattern[j - 1] == '.') &#123; check[i][j] = check[i - 1][j - 1]; &#125; else if (pattern[j - 1] == '*') &#123; if (j &gt;= 2 &amp;&amp; pattern[j - 2] == '.') &#123; for (int k = 0; k &lt;= i; k++) &#123; if (check[k][j - 2]) &#123; check[i][j] = true; break; &#125; &#125; &#125; else &#123; check[i][j] = check[i][j - 1] || (j &gt;= 2 &amp;&amp; (check[i - 1][j] || check[i - 1][j - 1]) &amp;&amp; (str[i - 1] == pattern[j - 2])) || (j &gt;= 2 &amp;&amp; check[i][j - 2]); &#125; &#125; else&#123; check[i][j] = check[i - 1][j - 1] &amp;&amp; (str[i - 1] == pattern[j - 1]); &#125; &#125; &#125; //for (int i = 0; i &lt;= M; i++) &#123; // for (int j = 0; j &lt;= N; j++) &#123; // cout &lt;&lt; check[i][j] &lt;&lt; \" \"; // &#125; // cout &lt;&lt; endl; //&#125; return check[M][N]; &#125;&#125;; 21 ~ 30 Problems21 调整数组顺序使奇数位于偶数前面题目：123输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 123456789101112131415161718class Solution &#123;public: void reOrderArray(vector&lt;int&gt;&amp; array) &#123; if (array.size() == 0) return; vector&lt;int&gt; orderArray(array); int begin = 0, end = orderArray.size() - 1; for (int i = 0; i &lt; orderArray.size(); i++) &#123; if (orderArray[i] &amp; 1) &#123; array[begin++] = orderArray[i]; &#125; &#125; for (int i = orderArray.size() - 1; i &gt;= 0; i--) &#123; if (!(orderArray[i] &amp; 1)) array[end--] = orderArray[i]; &#125; &#125;&#125;; 22 链表中倒数第k个节点题目:1输入一个链表，输出该链表中倒数第k个结点。 12345678910111213141516171819class Solution &#123;public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; if (k &lt;= 0 || !pListHead) return NULL; ListNode* node = pListHead; ListNode* lastKNode = pListHead; int number = 0; while (node) &#123; if (number &gt;= k) lastKNode = lastKNode-&gt;next; node = node-&gt;next; number++; &#125; if (k &gt; number) return NULL; return lastKNode; &#125;&#125;; 23 链表中环的入口点题目：1一个链表中包含环，请找出该链表的环的入口结点。 12345678910111213141516171819202122232425class Solution &#123;public: ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (!pHead) return pHead; ListNode *fast = pHead, *slow = pHead; while (fast) &#123; if (!fast-&gt;next || !fast-&gt;next-&gt;next) return NULL; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) break; &#125; ListNode *entrance = pHead; while (entrance != slow) &#123; entrance = entrance-&gt;next; slow = slow-&gt;next; &#125; return entrance; &#125;&#125;; 24 反转链表题目：1输入一个链表，反转链表后，输出链表的所有元素。 1234567891011121314151617class Solution &#123;public: ListNode* ReverseList(ListNode* pHead) &#123; if (!pHead || !pHead-&gt;next) return pHead; ListNode *p1 = pHead, *p2 = pHead-&gt;next, *p3 = pHead-&gt;next-&gt;next; while (p2) &#123; p2-&gt;next = p1; p1 = p2; p2 = p3; if (p3) p3 = p3-&gt;next; &#125; pHead-&gt;next = NULL; return p1; &#125;&#125;; 25 合并两个排序的链表题目：1输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) &#123; if (!pHead1) return pHead2; if (!pHead2) return pHead1; ListNode *node1 = pHead1, *node2 = pHead2, *node; ListNode *head = new ListNode(0); node = head; while (node1 &amp;&amp; node2) &#123; if (node1-&gt;val &lt;= node2-&gt;val) &#123; node-&gt;next = node1; node1 = node1-&gt;next; &#125; else &#123; node-&gt;next = node2; node2 = node2-&gt;next; &#125; node = node-&gt;next; &#125; if (node1) &#123; node-&gt;next = node1; &#125; if (node2) &#123; node-&gt;next = node2; &#125; node = head-&gt;next; delete head; return node; &#125;&#125;; 26 树的子结构题目：1输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) &#123; if (!pRoot2 || !pRoot1) return false; queue&lt;TreeNode*&gt; nodeQueue; nodeQueue.push(pRoot1); while (nodeQueue.size() &gt; 0) &#123; TreeNode* top = nodeQueue.front(); if (top-&gt;val == pRoot2-&gt;val &amp;&amp; check(top, pRoot2)) return true; nodeQueue.pop(); if (top-&gt;left) nodeQueue.push(top-&gt;left); if (top-&gt;right) nodeQueue.push(top-&gt;right); &#125; return false; &#125;private: bool check(TreeNode* node1, TreeNode* node2) &#123; if (!node1 &amp;&amp; !node2) return true; if (!node1 || !node2) return false; if (node1-&gt;val != node2-&gt;val) return false; bool result = true; if (node2-&gt;left) &#123; result *= check(node1-&gt;left, node2-&gt;left); &#125; if (node2-&gt;right) &#123; result *= check(node1-&gt;right, node2-&gt;right); &#125; return result; &#125;&#125;; 27 2叉树的镜像题目：1234567891011121314操作给定的二叉树，将其变换为源二叉树的镜像。输入描述 :二叉树的镜像定义：源二叉树 8 / \\ 6 10 / \\ / \\5 7 9 11镜像二叉树 8 / \\ 10 6 / \\ / \\11 9 7 5 123456789101112131415class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (!pRoot) return; TreeNode* tem = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = tem; if (pRoot-&gt;left) Mirror(pRoot-&gt;left); if (pRoot-&gt;right) Mirror(pRoot-&gt;right); &#125;&#125;; 28 对称的二叉树题目：12请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 123456789101112131415161718192021class Solution &#123;public: bool isSymmetrical(TreeNode* pRoot) &#123; if (!pRoot) return true; return isMirror(pRoot-&gt;left, pRoot-&gt;right); &#125;private: bool isMirror(TreeNode* node1, TreeNode* node2) &#123; if (!node1 &amp;&amp; !node2) return true; if (!node1 || !node2) return false; if (node1-&gt;val != node2-&gt;val) return false; return isMirror(node1-&gt;left, node2-&gt;right) &amp;&amp; isMirror(node1-&gt;right, node2-&gt;left); &#125;&#125;; 30 包含min函数的栈题目：1定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。 1234567891011121314151617181920212223class Solution &#123;public: void push(int value) &#123; if (minValue &gt; value) minValue = value; minStack.push(minValue); dataStack.push(value); &#125; void pop() &#123; dataStack.pop(); minStack.pop(); &#125; int top() &#123; return dataStack.top(); &#125; int min() &#123; return minStack.top(); &#125;private: int minValue = INT_MAX; stack&lt;int&gt; minStack; stack&lt;int&gt; dataStack;&#125;; 31 ~ 40 Problems31 栈的压入和弹出序列题目：1234输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1, 2, 3, 4, 5是某栈的压入顺序，序列4，5, 3, 2, 1是该压栈序列对应的一个弹出序列，但4, 3, 5, 1, 2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 12345678910111213141516171819202122class Solution &#123;public: bool IsPopOrder(vector&lt;int&gt; pushV, vector&lt;int&gt; popV) &#123; if (pushV.size() == 0) return true; int index1 = 0, index2 = 0; stack&lt;int&gt; dataStack; while (index1 &lt; pushV.size()) &#123; do &#123; if (index1 &gt;= pushV.size() || index2 &gt;= popV.size()) break; dataStack.push(pushV[index1]); &#125; while (pushV[index1++] != popV[index2]); while (dataStack.size() &gt; 0 &amp;&amp; dataStack.top() == popV[index2]) &#123; dataStack.pop(); index2++; &#125; &#125; return dataStack.size() == 0; &#125;&#125;; 32 从上到下打印二叉树题目：1从上往下打印出二叉树的每个节点，同层节点从左至右打印。 12345678910111213141516171819202122//层序遍历二叉树本质上是广度优先遍历二叉树class Solution &#123;public: vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123; if (!root) return &#123;&#125;; vector&lt;int&gt;result; queue&lt;TreeNode*&gt; levelQueue; levelQueue.push(root); while (levelQueue.size() &gt; 0) &#123; TreeNode* node = levelQueue.front(); levelQueue.pop(); if (node-&gt;left) levelQueue.push(node-&gt;left); if (node-&gt;right) levelQueue.push(node-&gt;right); result.push_back(node-&gt;val); &#125; return result; &#125;&#125;; 题目：1从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; if (pRoot == NULL) return &#123;&#125;; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; curruntLevel; int currunt = 1; queue&lt;TreeNode*&gt; nodeQueue; nodeQueue.push(pRoot); while (nodeQueue.size() &gt; 0) &#123; TreeNode* node = nodeQueue.front(); nodeQueue.pop(); if (node-&gt;left) nodeQueue.push(node-&gt;left); if (node-&gt;right) nodeQueue.push(node-&gt;right); curruntLevel.push_back(node-&gt;val); currunt--; if (currunt == 0) &#123; currunt = nodeQueue.size(); result.push_back(curruntLevel); curruntLevel = vector&lt;int&gt;(); &#125; &#125; return result; &#125;&#125;; 题目：12请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 1234567891011121314151617181920212223242526272829303132333435363738394041//其实copy操作可以省去，用一个二维的数组和一个bool量实现class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; if (pRoot == NULL) return &#123;&#125;; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;TreeNode*&gt; level1; vector&lt;TreeNode*&gt; level2; vector&lt;int&gt; curruntLevel; level1.push_back(pRoot); bool currunt = true; while (level1.size() &gt; 0) &#123; for (int i = 0; i &lt; level1.size(); i++) &#123; if (level1[i]-&gt;left) &#123; level2.push_back(level1[i]-&gt;left); &#125; if (level1[i]-&gt;right) level2.push_back(level1[i]-&gt;right); &#125; if (currunt) &#123; for (int i = 0; i &lt; level1.size(); i++) &#123; curruntLevel.push_back(level1[i]-&gt;val); &#125; &#125; else &#123; for (int i = level1.size() - 1; i &gt;= 0; i--) &#123; curruntLevel.push_back(level1[i]-&gt;val); &#125; &#125; level1 = level2; level2 = vector&lt;TreeNode*&gt;(); result.push_back(curruntLevel); curruntLevel = vector&lt;int&gt;(); currunt = !currunt; &#125; return result; &#125;&#125;; 33 二叉树的后续遍历序列12输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes, 否则输出No。假设输入的数组的任意两个数字都互不相同。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; if (sequence.size() == 0) return false; return justify(sequence, 0, sequence.size() - 1); &#125;private: bool justify(vector&lt;int&gt;&amp;sequence, int begin, int end) &#123; if (begin == end) return true; int top = sequence[end]; int firstLarge; for (firstLarge = begin; firstLarge &lt; end; firstLarge++) &#123; if (sequence[firstLarge] &gt; top) break; &#125; for (int i = firstLarge; i &lt; end; i++) &#123; if (sequence[i] &lt; top) return false; &#125; if (firstLarge == begin) &#123; return justify(sequence, begin, end - 1); &#125; else if (firstLarge == end) &#123; return justify(sequence, begin, end - 1); &#125; else &#123; return justify(sequence, begin, firstLarge - 1) &amp;&amp; justify(sequence, firstLarge, end - 1); &#125; &#125;&#125;; 34 二叉树中和为某一值的路径12输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root, int expectNumber) &#123; if (!root) return &#123;&#125;; this-&gt;expectNumber = expectNumber; vector&lt;int&gt; pathNumbers; find(pathNumbers, root, 0); return this-&gt;paths; &#125;private: vector&lt;vector&lt;int&gt;&gt; paths; int expectNumber; void find(vector&lt;int&gt;&amp; pathNumbers,TreeNode* node,int total) &#123; pathNumbers.push_back(node-&gt;val); total += node-&gt;val; if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; if (total == this-&gt;expectNumber) &#123; this-&gt;paths.push_back(pathNumbers); &#125; &#125; else &#123; if (node-&gt;left) &#123; find(pathNumbers, node-&gt;left, total); &#125; if (node-&gt;right) &#123; find(pathNumbers, node-&gt;right, total); &#125; &#125; if (pathNumbers.size() &gt; 0) &#123; total -= pathNumbers.back(); pathNumbers.pop_back(); &#125; &#125;&#125;; 35 复杂链表的复制123输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 123456789101112131415161718192021222324252627282930313233343536373839404142434445struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;&#125;;class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead) &#123; if (!pHead) return NULL; RandomListNode* node = pHead; while (node) &#123; RandomListNode *newNode = new RandomListNode(node-&gt;label); newNode-&gt;next = node-&gt;next; node-&gt;next = newNode; node = newNode-&gt;next; &#125; node = pHead; while (node) &#123; if (node-&gt;random) &#123; node-&gt;next-&gt;random = node-&gt;random-&gt;next; &#125; else node-&gt;next-&gt;random = NULL; node = node-&gt;next-&gt;next; &#125; RandomListNode* newHead = new RandomListNode(0), *newNode; newNode = newHead; node = pHead; while (node) &#123; newNode-&gt;next = node-&gt;next; node-&gt;next = node-&gt;next-&gt;next; newNode = newNode-&gt;next; node = node-&gt;next; &#125; newNode = newHead-&gt;next; delete newHead; return newNode; &#125;&#125;; 36 二叉搜索树与双向链表1输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 1234567891011121314151617181920212223242526272829class Solution &#123;public: TreeNode* Convert(TreeNode* pRootOfTree) &#123; if (!pRootOfTree) return NULL; change(pRootOfTree); while (lagetestNode-&gt;left) lagetestNode = lagetestNode-&gt;left; return lagetestNode; &#125;private: //TreeNode* smallestNode; TreeNode* lagetestNode = NULL; void change(TreeNode* node) &#123; if (node-&gt;left) &#123; change(node-&gt;left); &#125; node-&gt;left = lagetestNode; if (lagetestNode) &#123; lagetestNode-&gt;right = node; &#125; lagetestNode = node; if (node-&gt;right) &#123; change(node-&gt;right); &#125; &#125;&#125;; 37 序列化二叉树1请实现两个函数，分别用来序列化和反序列化二叉树 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: char* Serialize(TreeNode *root) &#123; vector&lt;int&gt; values; Serial(root, values); stringstream ss; for (int i = 0; i &lt; values.size(); i++) &#123; if (values[i] == -1) &#123; ss &lt;&lt; '$'; &#125; else &#123; ss &lt;&lt; values[i]; &#125; ss &lt;&lt; ','; &#125; return (char*)ss.str().c_str(); &#125; TreeNode* Deserialize(char *str) &#123; &#125;private: void Serial(TreeNode* node, vector&lt;int&gt;&amp; values) &#123; if (!node) &#123; values.push_back(-1); return; &#125; values.push_back(node-&gt;val); Serial(node-&gt;left, values); Serial(node-&gt;right, values); &#125;&#125;; 39 数组中出现次数超过一半的数字题目：123数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组&#123; 1,2,3,2,2,2,5,4,2 &#125;。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if (numbers.size() &lt;= 0) return INT_MAX; if (numbers.size() == 1) return numbers[0]; int result = numbers[0], times = 1; for (int i = 1; i &lt; numbers.size(); i++) &#123; if (numbers[i] != result) &#123; --times; if (times == 0) &#123; result = numbers[i]; times = 1; &#125; &#125; else &#123; times++; &#125; &#125; return CheckHalf(result, numbers) ? result : 0; &#125;private: bool CheckHalf(int number, vector&lt;int&gt;&amp; numbers) &#123; int times = 0; for (int i = 0; i &lt; numbers.size(); i++) &#123; if (numbers[i] == number) &#123; times++; &#125; &#125; return times &gt; numbers.size() / 2; &#125;&#125;; 40 最小的k个数题目：12输入n个整数，找出其中最小的K个数。例如输入4, 5, 1, 6, 2, 7, 3, 8这8个数字，则最小的4个数字是1, 2, 3, 4, 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; if (k &lt;= 0 || k &gt; input.size()) return this-&gt;result; FindSmallestK(input, k, 0, input.size() - 1); return this-&gt;result; &#125;private: vector&lt;int&gt; result; void FindSmallestK(vector&lt;int&gt;&amp; numbers, int k, int begin, int end) &#123; if (k == 0 || begin &gt; end) return; if (end - begin + 1 &lt;= k) &#123; for (int i = begin; i &lt;= end; i++) &#123; this-&gt;result.push_back(numbers[i]); &#125; return; &#125; int num = numbers[end]; int b = begin, e = end - 1; while (b &lt; e) &#123; while (b &lt; end &amp;&amp; numbers[b] &lt;= num) ++b; while (e &gt; begin &amp;&amp; numbers[e] &gt; num) --e; if (b &lt; e) swap(numbers[b], numbers[e]); &#125; if(numbers[b] &gt; numbers[end]) swap(numbers[b], numbers[end]); if (b == end) &#123; FindSmallestK(numbers, k, begin, end - 1); &#125; else if (b - begin + 1 &lt;= k) &#123; k -= b - begin + 1; for (int i = begin; i &lt;= b; i++) &#123; result.push_back(numbers[i]); &#125; FindSmallestK(numbers, k, b + 1, end); &#125; else &#123; FindSmallestK(numbers, k, begin, b); &#125; &#125; &#125;; 41 ~ 50 Problems42 连续子数组的最大和题目：1234HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后, 他又发话了:在古老的一维模式识别中, 常常需要计算连续子向量的最大和, 当向量全为正数的时候, 问题很好解决。但是, 如果向量中包含负数, 是否应该包含某个负数, 并期望旁边的正数会弥补它呢？例如 : &#123;6, -3, -2, 7, -15, 1, 2, 2&#125;, 连续子向量的最大和为8(从第0个开始, 到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1) 123456789101112131415161718192021class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; if (array.size() == 0) return 0; int max = INT_MIN, sum = 0; int begin = 0, end = 0; while (end &lt; array.size()) &#123; sum += array[end]; if (sum &gt; max) max = sum; if (sum &lt;= 0) &#123; begin = end + 1; sum = 0; &#125; end++; &#125; return max; &#125;&#125;; 43 1~n整数中1出现的次数题目：123求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。 12345678910111213141516171819202122class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int result = 0; int index = 10; while (index / 10 &lt;= n) &#123; int res = n / index, rem = n % index; if(res &gt;= 1) result += res * index / 10; if (rem &gt;= 2 * index / 10) &#123; result += index / 10; &#125; else if(rem &gt;= index / 10 )&#123; result += rem - (index / 10) + 1; &#125; index *= 10; &#125; return result; &#125;&#125;;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://uyouii.github.io/categories/algorithm/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://uyouii.github.io/tags/c/"},{"name":"algorithm","slug":"algorithm","permalink":"https://uyouii.github.io/tags/algorithm/"}]},{"title":"LeetCode  算法题解","slug":"LeetCode-算法题解","date":"2017-12-21T10:37:00.000Z","updated":"2018-01-30T10:21:37.615Z","comments":true,"path":"2017/12/21/LeetCode-算法题解/","link":"","permalink":"https://uyouii.github.io/2017/12/21/LeetCode-算法题解/","excerpt":"","text":"LeetCode 上的算法题的一些个人方法。 不多说，直接上代码。 1 ~ 20 problems1 Two Sum难度：Easy123456789101112class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for (int i = 0; i &lt; nums.size(); i++) &#123; for (int j = i + 1; j &lt; nums.size(); j++) &#123; if (nums[i] + nums[j] == target) &#123; return&#123; i,j &#125;; &#125; &#125; &#125; &#125;&#125;; 2 Add Two Numbers难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode * l3 = new ListNode(0); ListNode* l = l3; ListNode* last; while (l1 != NULL &amp;&amp; l2 != NULL) &#123; if (l-&gt;val + l1-&gt;val + l2-&gt;val &lt; 10) &#123; l-&gt;val += l1-&gt;val + l2-&gt;val; l-&gt;next = new ListNode(0); &#125; else if (l-&gt;val + l1-&gt;val + l2-&gt;val &gt;= 10) &#123; l-&gt;next = new ListNode((l-&gt;val + l1-&gt;val + l2-&gt;val) / 10); l-&gt;val = (l-&gt;val + l1-&gt;val + l2-&gt;val) % 10; &#125; last = l; l = l-&gt;next; l1 = l1-&gt;next; l2 = l2-&gt;next; &#125; if (l1 == NULL) &#123; while (l2 != NULL) &#123; if (l-&gt;val + l2-&gt;val &lt; 10) &#123; l-&gt;val += l2-&gt;val; l-&gt;next = new ListNode(0); &#125; else if (l-&gt;val + l2-&gt;val &gt;= 10) &#123; l-&gt;next = new ListNode((l-&gt;val + l2-&gt;val) / 10); l-&gt;val = (l-&gt;val + l2-&gt;val) % 10; &#125; last = l; l = l-&gt;next; l2 = l2-&gt;next; &#125; &#125; if (l2 == NULL) &#123; while (l1 != NULL) &#123; if (l-&gt;val + l1-&gt;val &lt; 10) &#123; l-&gt;val += l1-&gt;val; l-&gt;next = new ListNode(0); &#125; else if (l-&gt;val + l1-&gt;val &gt;= 10) &#123; l-&gt;next = new ListNode((l-&gt;val + l1-&gt;val) / 10); l-&gt;val = (l-&gt;val + l1-&gt;val) % 10; &#125; last = l; l = l-&gt;next; l1 = l1-&gt;next; &#125; &#125; if (l-&gt;val == 0) last-&gt;next = NULL; return l3; &#125;&#125;; 3 Longest Substring Without Repeating Characters难度：Medium1234567891011121314151617181920212223242526272829class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; bool exist[128]; for (int i = 0; i &lt; 128; i++) &#123; exist[i] = false; &#125; int length = 0, max = 0; for (int i = 0; i &lt; s.length(); i++) &#123; for (int j = i; j &lt; s.length(); j++) &#123; char c = s[j]; if (exist[c]) &#123; break; &#125; else &#123; exist[c] = true; length++; &#125; &#125; for (int i = 0; i &lt; 128; i++) &#123; exist[i] = false; &#125; if (length &gt; max) max = length; length = 0; &#125; return max; &#125;&#125;; 4 Median of Two Sorted Arrays.cpp难度：Hard12345678910111213141516171819202122232425262728293031class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int l1 = (nums1.size() + nums2.size() + 1) &gt;&gt; 1; int l2 = (nums1.size() + nums2.size() + 2) &gt;&gt; 1; cout &lt;&lt; l1 &lt;&lt; \" \" &lt;&lt; l2 &lt;&lt; endl; return (getkth(nums1, 0, nums1.size(), nums2, 0, nums2.size(), l1) + getkth(nums1, 0, nums1.size(), nums2, 0, nums2.size(), l2)) / 2.0; &#125;private: int getkth(vector&lt;int&gt;&amp; nums1, int begin1, int l1, vector&lt;int&gt;&amp; nums2, int begin2, int l2, int k) &#123; if (l1 &gt; l2) return getkth(nums2, begin2, l2, nums1, begin1, l1, k); if (l1 == 0) return nums2[begin2 + k - 1]; if (k == 1) return min(nums1[begin1], nums2[begin2]); int i = min(l1, k / 2), j = min(l2, k / 2); if (nums1[begin1 + i - 1] &gt; nums2[begin2 + j - 1]) &#123; return getkth(nums1, begin1, l1, nums2, begin2 + j, l2 - j, k - j); &#125; else &#123; return getkth(nums1, begin1 + i, l1 - i, nums2, begin2, l2, k - i); &#125; &#125;&#125;; 5 Longest Palindromic Substring难度：Medium123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: //动态规划 string longestPalindrome(string s) &#123; if (s.length() == 1) return s; const int MAX = 1000; int resultLength = 0; string result; bool P[MAX][MAX] = &#123;&#125;; int length, begin; for (length = 1; length &lt;= s.length(); length++) &#123; for (begin = 0; begin + length &lt;= s.length(); begin++) &#123; if (length == 1) &#123; P[begin][begin + length - 1] = true; if (resultLength &lt; 1) &#123; resultLength = 1; result = s[begin]; &#125; &#125; else if (length == 2) &#123; if (s[begin] == s[begin + length - 1]) &#123; P[begin][begin + length - 1] = true; if (resultLength &lt; 2) &#123; resultLength = 2; result = s.substr(begin, length); &#125; &#125; &#125; else if (P[begin + 1][begin + length - 2] &amp;&amp; s[begin] == s[begin + length - 1]) &#123; P[begin][begin + length - 1] = true; if (resultLength &lt; length) &#123; resultLength = length; result = s.substr(begin, length); &#125; &#125; &#125; &#125; return result; &#125;&#125;; 6 ZigZag Conversion难度：Medium12345678910111213141516171819202122232425262728class Solution &#123;public: string convert(string s, int numRows) &#123; if (numRows == 1) return s; vector&lt;string&gt; Data; for (int i = 0; i &lt; numRows; i++) &#123; string data; Data.push_back(data); &#125; int M = numRows * 2 - 2; for (int i = 0; i &lt; s.length(); i++) &#123; int num = i % M; if (num &lt; numRows) &#123; Data[num].push_back(s[i]); &#125; else &#123; int n = numRows - (num - numRows) - 2; Data[n].push_back(s[i]); &#125; &#125; string result = \"\"; for (int i = 0; i &lt; numRows; i++) &#123; result += Data[i]; &#125; return result; &#125;&#125;; 7 Reverse Integer难度：Easy12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int reverse(int x) &#123; if (x == 0) return 0; int length = getLength(x); bool isnegative = x &lt; 0; if (x &lt; 0) x = -x; int last = x % 10; int result = 0; int oldresult = result; while (x &gt; 0) &#123; result = result * 10 + x % 10; x = x / 10; &#125; if (result &lt; 0) return 0; int M = 1; for (int i = 0; i &lt; length - 1; i++) &#123; M *= 10; &#125; if (result / M != last) return 0; if (isnegative) return -result; return result; &#125;private: int getLength(int x) &#123; int length = 0; if (x &lt; 0) x = -x; while (x &gt; 0) &#123; x = x / 10; length++; &#125; return length; &#125;&#125;; 8 String to Integer(atoi)难度：Medium1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123;public: int myAtoi(string str) &#123; string s = deleteSpace(str); if (s.empty() || s.length() == 0) return 0; bool isNegative = false; if (s[0] == '-') &#123; isNegative = true; s.erase(0, 1); &#125; else if (s[0] == '+') &#123; s.erase(0, 1); &#125; if (!isdigit(s[0])) return 0; int i = 0; while (i &lt; s.length()) &#123; if (!isdigit(s[i])) break; i++; &#125; s = s.substr(0,i); if (s.length() &gt; 10) &#123; return isNegative ? INT_MIN : INT_MAX; &#125; long Number = 0; for (int i = 0; i &lt; s.length(); i++) &#123; Number = Number * 10 + s[i] - '0'; &#125; if (isNegative) &#123; Number = -Number; return Number &lt; INT_MIN ? INT_MIN : Number; &#125; else &#123; return Number &gt; INT_MAX ? INT_MAX : Number; &#125; return Number; &#125;private: string deleteSpace(string str) &#123; int i = 0; while (i &lt; str.length() &amp;&amp; isspace(str[i])) &#123; i++; &#125; if (i == str.length()) return \"\"; string s = \"\"; while (i &lt; str.length() &amp;&amp; !isspace(str[i])) &#123; s.push_back(str[i]); i++; &#125; return s; &#125;&#125;; 9 Palindrome Number难度：Easy123456789101112131415class Solution &#123;public: bool isPalindrome(int x) &#123; if (x == 0) return true; if (x &lt; 0) x = -x; int m = 0, n = x; while (n &gt; 0) &#123; m = m * 10 + n % 10; n /= 10; &#125; return m == x; &#125;&#125;; 10 Regular Expression Matching难度：Hard1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: bool isMatch(string s, string p) &#123; int sSize = s.length(); int pSize = p.length(); bool ** Checked = new bool*[sSize + 1]; for (int i = 0; i &lt; sSize + 1; i++) &#123; Checked[i] = new bool[pSize + 1]; &#125; Checked[0][0] = true; Checked[0][1] = false; for (int i = 1; i &lt;= sSize; i++) &#123; Checked[i][0] = false; &#125; for (int j = 2; j &lt;= pSize; j++) &#123; if (j == 2) &#123; if (p[1] == '*' &amp;&amp; p[0] != '*') Checked[0][2] = true; else Checked[0][2] = false; &#125; else Checked[0][j] = p[j-1] == '*' ? Checked[0][j-1] || Checked[0][j-2] : false; //cout &lt;&lt; \"[\" &lt;&lt; 0 &lt;&lt; \"][\" &lt;&lt; j &lt;&lt; \"]=\" &lt;&lt; Checked[0][j] &lt;&lt; endl; &#125; for (int i = 1; i &lt;= sSize; i++) &#123; for (int j = 1; j &lt;= pSize; j++) &#123; if (p[j-1] != '*') &#123; Checked[i][j] = Checked[i - 1][j - 1] &amp;&amp; (s[i-1] == p[j-1] || p[j-1] == '.'); //cout &lt;&lt; \"[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; j &lt;&lt; \"]=\" &lt;&lt; Checked[i][j] &lt;&lt; endl; &#125; else &#123; if (Checked[i][j - 1]) &#123; Checked[i][j] = true; &#125; else if(j &gt;= 2 &amp;&amp; Checked[i][j-2]) &#123; Checked[i][j] = true; //cout &lt;&lt; \"[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; j &lt;&lt; \"]=\" &lt;&lt; Checked[i][j] &lt;&lt; endl; &#125; else &#123; Checked[i][j] = Checked[i - 1][j] &amp;&amp; (s[i-1] == p[j - 2] || p[j-2] == '.'); //cout &lt;&lt; \"[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; j &lt;&lt; \"]=\" &lt;&lt; Checked[i][j] &lt;&lt; endl; &#125; &#125; &#125; &#125; bool result = Checked[sSize][pSize]; for (int i = 0; i &lt; sSize; i++) &#123; delete[] Checked[i]; &#125; delete[] Checked; return result; &#125;&#125;; 11 Container With Most Water难度：Medium123456789101112131415161718192021222324class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int begin = 0, end = height.size() - 1; int volume = 0; int v = 0; do &#123; v = (end - begin) * min(height[begin], height[end]); if (volume &lt; v) volume = v; if (height[begin] &lt; height[end]) &#123; begin++; &#125; else end--; &#125; while (begin &lt; end); return volume; &#125;private: int min(int n1, int n2) &#123; return n1 &lt; n2 ? n1 : n2; &#125;&#125;; 12 Integer to Roman难度：Medium1234567891011121314151617class Solution &#123;public: string intToRoman(int num) &#123; string table[4][10] = &#123; &#123; \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\" &#125;, &#123; \"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\" &#125;, &#123; \"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\" &#125;, &#123; \"\", \"M\", \"MM\", \"MMM\" &#125; &#125;; string result; int n = 0; while (num &gt; 0) &#123; result = table[n++][num % 10] + result; num /= 10; &#125; return result; &#125;&#125;; 13 Roman to Integer难度：Easy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: int romanToInt(string s) &#123; int result = 0, i = 0; while (i &lt; s.length()) &#123; switch (s[i]) &#123; case 'M': if (i &gt; 0 &amp;&amp; s[i - 1] == 'C') result += 800; else result += 1000; break; case 'C': if (i &gt; 0 &amp;&amp; s[i - 1] == 'X') result += 80; else result += 100; break; case 'D': &#123; if (i - 1 &gt;= 0 &amp;&amp; s[i - 1] == 'C') result += 300; else result += 500; break; case 'X': if (i &gt; 0 &amp;&amp; s[i - 1] == 'I') result += 8; else result += 10; break; case 'L': if (i &gt; 0 &amp;&amp; s[i - 1] == 'X') result += 30; else result += 50; break; case 'V': if (i &gt; 0 &amp;&amp; s[i - 1] == 'I') result += 3; else result += 5; break; case 'I': result += 1; break; &#125; &#125; i++; &#125; return result; &#125;&#125;; 14 Longest Common Prefix难度：Easy1234567891011121314151617181920212223242526class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if (strs.size() == 0) return \"\"; string s = strs[0]; for (int i = 1; i &lt; strs.size(); i++) &#123; s = commonPrefix(s, strs[i]); &#125; return s; &#125;private: string commonPrefix(string s1, string s2) &#123; string s; if (s1.length() == 0 || s2.length() == 0) return \"\"; int i = 0; while (i &lt; s1.length() &amp;&amp; i &lt; s2.length()) &#123; if (s1[i] == s2[i]) s.push_back(s1[i]); else return s; i++; &#125; return s; &#125;&#125;; 15 3Sum难度：Medium123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) &#123; if (num.size() &lt; 3) return&#123;&#125;; sort(num.begin(), num.end()); vector&lt;vector&lt;int&gt;&gt; result; if (num[num.size() - 1] &lt; 0 || num[0] &gt; 0) return result; vector&lt;int&gt; triple = &#123; 0,0,0 &#125;; for (int i = 0; i &lt; num.size(); i++) &#123; if (num[i] &gt; 0) break; int begin = i + 1; int end = num.size() - 1; while (begin &lt; end) &#123; int sum = num[begin] + num[end]; if (sum + num[i] &lt; 0) &#123; begin++; &#125; else if (sum + num[i] &gt; 0) &#123; end--; &#125; else &#123; triple[0] = num[i]; triple[1] = num[begin]; triple[2] = num[end]; result.push_back(triple); while (begin &lt; end &amp;&amp; num[begin] == triple[1]) begin++; while (begin &lt; end &amp;&amp; num[end] == triple[2]) end--; &#125; &#125; while (i + 1 &lt; num.size() &amp;&amp; num[i + 1] == num[i]) &#123; i++; &#125; &#125; return result; &#125;&#125;; 16 3Sum Closet难度：Medium12345678910111213141516171819202122232425262728class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int minCloset = INT_MAX; int result; for (int i = 0; i &lt; nums.size(); i++) &#123; int begin = i + 1, end = nums.size() - 1; while (begin &lt; end) &#123; int sum = nums[i] + nums[begin] + nums[end]; if (abs(sum - target) &lt; minCloset) &#123; minCloset = abs(sum - target); result = sum; &#125; if (sum - target &lt; 0) &#123; begin++; &#125; else if (sum - target &gt; 0) &#123; end--; &#125; else &#123; return result; &#125; &#125; &#125; return result; &#125;&#125;; 17 Letter Combinations of a Phone Number难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; if (digits.size() == 0) return&#123;&#125;; vector&lt;string&gt; result; vector&lt;string&gt; Data = &#123; \" \",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\" &#125;; for (int i = 0; i &lt; digits.size(); i++) &#123; if (result.size() == 0) &#123; if (Data[(digits[i] - '0')].size() &gt; 0) &#123; for (int j = 0; j &lt; Data[(digits[i] - '0')].size(); j++) &#123; string s; s.push_back(Data[(digits[i] - '0')][j]); result.push_back(s); &#125; &#125; &#125; else &#123; if (Data[(digits[i] - '0')].size() &gt; 0) &#123; int n = result.size(); for (int k = 0; k &lt; Data[(digits[i] - '0')].size() - 1; k++) &#123; for (int j = 0; j &lt; n; j++) &#123; result.push_back(result[j]); &#125; &#125; for (int k = 0; k &lt; Data[(digits[i] - '0')].size(); k++) &#123; for (int j = n * k; j &lt; n* (k + 1); j++) &#123; result[j].push_back(Data[(digits[i] - '0')][k]); &#125; &#125; &#125; &#125; &#125; return result; &#125; &#125;; 18 4Sum难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.size() &lt; 4) return&#123;&#125;; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; result; int len = nums.size(); vector&lt;int&gt; four = &#123; INT_MIN,INT_MIN,INT_MIN,INT_MIN &#125;; for (int first = 0; first &lt; len - 3; first++) &#123; for (int second = first + 1; second &lt; len - 2; second++) &#123; int begin = second + 1, end = len - 1; while (begin &lt; end) &#123; if (nums[first] + nums[second] + nums[begin] + nums[end] &lt; target) &#123; begin++; &#125; else if (nums[first] + nums[second] + nums[begin] + nums[end] &gt; target) &#123; end--; &#125; else &#123; four[0] = nums[first]; four[1] = nums[second]; four[2] = nums[begin]; four[3] = nums[end]; result.push_back(four); do &#123; begin++; &#125; while (begin &lt; end &amp;&amp; nums[begin] == four[2]); do &#123; end--; &#125; while (begin &lt; end &amp;&amp; nums[end] == four[3]); &#125; &#125; while (second &lt; len - 2 &amp;&amp; nums[second + 1] == nums[second]) second++; &#125; while (first &lt; len - 3 &amp;&amp; nums[first + 1] == nums[first]) first++; &#125; return result; &#125;&#125;; 19 Remove Nth Node From End of List难度：Medium12345678910111213141516171819202122232425262728293031class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; int N = getNum(head); if (N &lt; n) return NULL; int x = N - n; if (x == 0) &#123; head = head-&gt;next; &#125; else &#123; ListNode* p = head; ListNode* parent = head; while (x--) &#123; parent = p; p = p-&gt;next; &#125; parent-&gt;next = p-&gt;next; &#125; return head; &#125; int getNum(ListNode* head) &#123; int n = 0; ListNode* p = head; while (p != NULL) &#123; p = p-&gt;next; n++; &#125; return n; &#125;&#125;; 20 Valid Parentheses难度：Easy12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: bool isValid(string s) &#123; vector&lt;char&gt; stack = &#123;'a'&#125;; for (int i = 0; i &lt; s.length(); i++) &#123; switch (s[i]) &#123; case '[': stack.push_back(s[i]); break; case '(': stack.push_back(s[i]); break; case '&#123;': stack.push_back(s[i]); break; case ']': if (stack[stack.size() - 1] != '[') return false; else stack.pop_back(); break; case ')': if (stack[stack.size() - 1] != '(') return false; else stack.pop_back(); break; case '&#125;': if (stack[stack.size() - 1] != '&#123;') return false; else stack.pop_back(); break; default: break; &#125; &#125; if (stack.size() &gt; 1) return false; return true; &#125;&#125;; 21 ~ 40 Problems21 Merge Two Sorted Lists难度：Easy123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode * head = NULL; ListNode * l = NULL; if (l1 == NULL) return l2; if (l2 == NULL) return l1; if (l1-&gt;val &lt; l2-&gt;val) &#123; head = l1; l1 = l1-&gt;next; &#125; else &#123; head = l2; l2 = l2-&gt;next; &#125; l = head; while (l1 != NULL &amp;&amp; l2 != NULL) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; l-&gt;next = l1; l = l-&gt;next; l1 = l1-&gt;next; &#125; else &#123; l-&gt;next = l2; l = l-&gt;next; l2 = l2-&gt;next; &#125; &#125; if (l1 != NULL) &#123; l-&gt;next = l1; &#125; if (l2 != NULL) &#123; l-&gt;next = l2; &#125; return head; &#125;&#125;; 22 Generate Parentheses难度：Medium123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; if (n == 0) return&#123;&#125;; int n1 = n, n2 = n; vector&lt;string&gt; result; addString(result, \"\", n1, n2); return result; &#125; void addString(vector&lt;string&gt;&amp; result, string s ,int n1, int n2) &#123; if (n1 == 0) &#123; while (n2 &gt; 0) &#123; s.push_back(')'); n2--; &#125; result.push_back(s); return; &#125; else if (n2 &lt;= n1) &#123; s.push_back('('); addString(result, s, n1 - 1, n2); &#125; else &#123; string s1 = s; s1.push_back('('); string s2 = s; s2.push_back(')'); addString(result, s1, n1 - 1, n2); addString(result, s2, n1, n2 - 1); &#125; &#125;&#125;; 23 Merge k Sorted Lists难度：Hard123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; if (lists.size() == 0) return NULL; else if (lists.size() == 1) return lists[0]; ListNode* l = lists[0]; for (int i = 1; i &lt; lists.size(); i++) &#123; l = mergeTwoLists(l, lists[i]); &#125; return l; &#125; ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == NULL) return l2; if (l2 == NULL) return l1; ListNode* head; ListNode* l; if (l1-&gt;val &lt; l2-&gt;val) &#123; head = l1; l1 = l1-&gt;next; &#125; else &#123; head = l2; l2 = l2-&gt;next; &#125; l = head; while (l1 != NULL &amp;&amp; l2 != NULL) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; l-&gt;next = l1; l = l-&gt;next; l1 = l1-&gt;next; &#125; else &#123; l-&gt;next = l2; l = l-&gt;next; l2 = l2-&gt;next; &#125; &#125; if (l1 != NULL) l-&gt;next = l1; if (l2 != NULL) l-&gt;next = l2; return head; &#125;&#125;; 24 Swap Nodes in Pairs难度：Medium1234567891011121314151617181920212223242526272829303132class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if (head == NULL) return NULL; ListNode *l1, *l2, *l3, *l; l1 = head; l2 = head-&gt;next; if (l2 == NULL) return head; l3 = l2-&gt;next; l = NULL; head = l2; do &#123; l2-&gt;next = l1; l1-&gt;next = l3; if (l != NULL) &#123; l-&gt;next = l2; &#125; l = l1; l1 = l3; if (l1 == NULL) break; l2 = l1-&gt;next; if (l2 == NULL) break; l3 = l2-&gt;next; &#125; while (1); return head; &#125;&#125;; 25 Reverse Nodes in k-Group难度：Hard12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if (k &lt;= 1) return head; ListNode *begin, *end = head, *next, *result = head; ListNode *lastend; bool first = true; begin = head; while (begin != NULL) &#123; lastend = end; end = begin; int i = 0; for (i = 0; i &lt; k - 1; i++) &#123; if (end-&gt;next == NULL) break; end = end-&gt;next; &#125; if (i != k - 1) return result; next = end-&gt;next; reverse(begin, end); end-&gt;next = next; if (first) &#123; result = begin; first = false; &#125; else &#123; lastend-&gt;next = begin; &#125; begin = next; &#125; return result; &#125;private: void reverse(ListNode* &amp;head, ListNode* &amp;end) &#123; if (head == NULL || head == end) return; ListNode* l1 = head; ListNode* l2 = head; ListNode* l3 = head-&gt;next; while (l2 != end) &#123; l1 = l2; l2 = l3; l3 = l3-&gt;next; l2-&gt;next = l1; &#125; end = head; head = l2; &#125;&#125;; 26 Reverse Duplciates from Sorted Array难度：Easy12345678910111213141516class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 0; int length = 0; int i = 0; while (i &lt; nums.size()) &#123; length++; while (i + 1 &lt; nums.size() &amp;&amp; nums[i] == nums[i + 1]) nums.erase(nums.begin() + i); i++; &#125; return length; &#125;&#125;; 27 Remove Element难度：Easy1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; if (nums.size() == 0) return 0; int warp = nums.size() - 1; int i = 0; for (i = 0; i &lt;= warp; i++) &#123; if (nums[i] == val) &#123; warp = findLast(nums, val, warp); if (warp == -1) return 0; else if (warp &lt;= i) return i; int tem = nums[warp]; nums[warp] = nums[i]; nums[i] = tem; warp--; &#125; &#125; return i; &#125;private: int findLast(vector&lt;int&gt;&amp; nums, int val, int n) &#123; for (int i = n; i &gt;= 0; i--) &#123; if (nums[i] != val) return i; &#125; return -1; &#125;&#125;; 28 Implement strStr()难度：Easy123456789101112131415161718class Solution &#123;public: int strStr(string haystack, string needle) &#123; //return haystack.find(needle); solution 1 if (haystack.size() &lt; needle.size()) return -1; for (int i = 0; i &lt;= haystack.size() - needle.size(); i++) &#123; int j = 0; int num = i; while (haystack[num] == needle[j]) &#123; num++; j++; &#125; if (j &gt;= needle.size()) return i; &#125; return -1; &#125;&#125;; 29 Divide Two Integers难度：Medium12345678910111213141516171819202122232425262728293031class Solution &#123;public: int divide(int dividend, int divisor) &#123; if (!divisor) return INT_MAX; if (divisor == 1) return dividend; if (divisor == -1) &#123; if (dividend == INT_MIN) return INT_MAX; else return -dividend; &#125; bool s1 = dividend &lt; 0; bool s2 = divisor &lt; 0; unsigned int nom = s1 ? -dividend : dividend; unsigned int den = s2 ? -divisor : divisor; unsigned int rem = 0; unsigned int quot = 0; for (int i = 31; i &gt;= 0; --i) &#123; rem &lt;&lt;= 1; rem |= (nom &gt;&gt; i) &amp; 1; if (rem &gt;= den) &#123; rem -= den; quot |= (1 &lt;&lt; i); &#125; &#125; return s1^s2 ? -quot : quot; &#125;&#125;; 30 Substring With Concatenation of All Words难度：Hard12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; if (words.size() == 0 || s.size() == 0) return&#123;&#125;; vector&lt;int&gt; result; vector&lt;bool&gt; ready(words.size(), false); int n = words[0].length(), N = words.size(); if (n == 0) return&#123;&#125;; if (n*N &gt; s.size()) return&#123;&#125;; for (int begin = 0; begin &lt;= (int)(s.size() - n * N); begin++) &#123; string tem = s.substr(begin, n); if (findStr(words, ready, tem)) &#123; int n1 = begin + n; if (n1 &lt;= (int)(s.size() - n)) &#123; tem = s.substr(n1, n); while (n1 &lt;= s.size() - n &amp;&amp; findStr(words, ready, tem)) &#123; n1 = n1 + n; tem = s.substr(n1, n); &#125; &#125; if (isFindAll(ready)) &#123; result.push_back(begin); &#125; ready = vector&lt;bool&gt;(words.size(), false); &#125; &#125; return result; &#125; bool findStr(vector&lt;string&gt;&amp; words, vector&lt;bool&gt;&amp; ready, string str) &#123; for (int i = 0; i &lt; words.size(); i++) &#123; if (!ready[i] &amp;&amp; words[i] == str) &#123; ready[i] = true; return true; &#125; &#125; return false; &#125; bool isFindAll(vector&lt;bool&gt;&amp; ready) &#123; for (int i = 0; i &lt; ready.size(); i++) &#123; if (ready[i] == false) return false; &#125; return true; &#125;&#125;; 31 Next Permutation难度：Medium1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return; if (isLagerest(nums,0)) changeToSmallest(nums, 0); else &#123; for (int i = nums.size() - 1; i &gt;= 0; --i) &#123; if (isLagerest(nums, i)) continue; else &#123; int x = nums[i]; int j; for (j = i + 1; j &lt; nums.size() - 1; j++) &#123; if (nums[j + 1] &lt;= x) &#123; nums[i] = nums[j]; nums[j] = x; changeToSmallest(nums, i + 1); return; &#125; &#125; nums[i] = nums[j]; nums[j] = x; changeToSmallest(nums, i + 1); return; &#125; &#125; &#125; &#125; void changeToSmallest(vector&lt;int&gt;&amp; nums, int begin) &#123; sort(nums.begin() + begin, nums.end()); &#125; bool isLagerest(vector&lt;int&gt;&amp; nums, int begin) &#123; if (nums.size() == 1) return true; if (begin &gt;= nums.size()) return false; for (int i = begin; i &lt; nums.size()- 1; i++) &#123; if (nums[i] &lt; nums[i + 1]) return false; &#125; return true; &#125;&#125;; 32 Longest Valid Parentheses难度：Hard1234567891011121314151617181920212223242526272829class Solution &#123;public: int longestValidParentheses(string s) &#123; vector&lt;bool&gt; isDouble(s.size(), 0); vector&lt;int&gt; nums1; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == '(') nums1.push_back(i); if (s[i] == ')') &#123; if (nums1.size() &gt; 0) &#123; isDouble[nums1[nums1.size() - 1]] = true; isDouble[i] = true; nums1.pop_back(); &#125; &#125; &#125; int begin = 0, end = 0, max = 0; while (begin &lt; s.size()) &#123; end = begin; while (end &lt; s.size() &amp;&amp; isDouble[end]) &#123; end++; &#125; if (end - begin &gt; max) max = end - begin; begin = end + 1; &#125; return max; &#125;&#125;; 33 Search in Rotated Sorted Array难度：Medium1234567891011121314151617181920212223242526class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.size() == 0) return -1; int min = 0; while (min &lt; nums.size() - 1 &amp;&amp; nums[min + 1] &gt; nums[min]) min++; min++; int N = nums.size(); int n = N / 2, num, left = 0, right = N; num = (n + min) % N; while (left &lt;= right) &#123; if (nums[num] &gt; target) &#123; right = n - 1; &#125; else if (nums[num] &lt; target) &#123; left = n + 1; &#125; else return num; n = (left + right) / 2; num = (n + min) % N; &#125; return -1; &#125;&#125;; 34 Search for a Range难度：Medium1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; result = &#123; -1,-1 &#125;; int right = foundRightIndex(nums, target, 0, nums.size() - 1); if (right &lt; 0 || nums[right] != target) return result; int left = foundLeftIndex(nums, target, 0, right); result[0] = left; result[1] = right; return result; &#125;private: //binary search, found two index int foundRightIndex(vector&lt;int&gt;&amp; nums, int target, int left, int right) &#123; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (nums[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; return right; &#125; int foundLeftIndex(vector&lt;int&gt;&amp; nums, int target, int left, int right) &#123; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (nums[mid] &lt; target) left = mid + 1; else right = mid - 1; &#125; return left; &#125;&#125;; 35 Search Insert Position难度：Easy123456789101112131415161718192021222324class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.size() == 0) return 0; return foudRightIndex(nums, target); &#125; int foudRightIndex(vector&lt;int&gt;&amp; nums, int target) &#123; int mid, left, right; left = 0; right = nums.size() - 1; while (left &lt;= right) &#123; mid = (left + right) / 2; if (nums[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; if (right &lt; 0) return 0; else if (nums[right] == target) return right; else return right + 1; &#125;&#125;; 36 Valid Sudoku难度：Medium12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] == '.') continue; if (!isValid(board,i,j)) return false; &#125; &#125; return true; &#125;private: bool isValid(vector&lt;vector&lt;char&gt;&gt;&amp; board, int m, int n) &#123; for (int i = 0; i &lt; 9; i++) &#123; if (i != m &amp;&amp; board[i][n] == board[m][n]) return false; if (i != n &amp;&amp; board[m][i] == board[m][n]) return false; &#125; for (int i = m / 3 * 3; i &lt; m / 3 * 3 + 3; i++) &#123; for (int j = n / 3 * 3; j &lt; n / 3 * 3 + 3; j++) &#123; if (i == m &amp;&amp; n == j) continue; if (board[i][j] == board[m][n]) return false; &#125; &#125; return true; &#125;&#125;; 37 Sudoku Solver难度：Hard123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; fillSudoku(board, 0); &#125;private: bool fillSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x) &#123; if (x == 81) return true; int m = x / 9, n = x % 9; if (board[m][n] != '.') return fillSudoku(board, x + 1); for (int k = 1; k &lt;= 9; k++) &#123; board[m][n] = k + '0'; if (isValid(board, m, n) &amp;&amp; fillSudoku(board, x + 1)) return true; board[m][n] = '.'; &#125; return false; &#125; bool isValid(vector&lt;vector&lt;char&gt;&gt;&amp; board, int m, int n) &#123; for (int i = 0; i &lt; 9; i++) &#123; if (i != m &amp;&amp; board[i][n] == board[m][n]) return false; if (i != n &amp;&amp; board[m][i] == board[m][n]) return false; &#125; for (int i = m / 3 * 3; i &lt; m / 3 * 3 + 3; i++) &#123; for (int j = n / 3 * 3; j &lt; n / 3 * 3 + 3; j++) &#123; if (i == m &amp;&amp; n == j) continue; if (board[i][j] == board[m][n]) return false; &#125; &#125; return true; &#125;&#125;; 38 Count and Say难度：Easy12345678910111213141516171819202122class Solution &#123;public: string countAndSay(int n) &#123; string s1 = \"1\"; for (int i = 1; i &lt; n; i++) &#123; string s2; int j = 0; while (j &lt; s1.size()) &#123; char c = s1[j]; int num = 0; while (j &lt; s1.size() &amp;&amp; s1[j] == c) &#123; num++; j++; &#125; s2.push_back(num + '0'); s2.push_back(c); &#125; s1 = s2; &#125; return s1; &#125;&#125;; 39 Combination Sum难度：Medium1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; temp; getResult(candidates, target, 0, result, temp); return result; &#125; void getResult(vector&lt;int&gt;&amp; candidates, int target, int begin, vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; temp) &#123; if (begin == candidates.size()) return; int num = candidates[begin]; getResult(candidates, target, begin + 1, result, temp); int i = 0; int oldtarget = target; while (target - num &gt; 0) &#123; i++; target -= num; temp.push_back(num); getResult(candidates, target, begin + 1, result, temp); &#125; if (target - num == 0) &#123; temp.push_back(num); result.push_back(temp); &#125; &#125;&#125;; 40 Comination Sum II难度：Medium1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; if (candidates.size() == 0) return&#123;&#125;; sort(candidates.begin(), candidates.end()); vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; temp; getNumber(candidates, target, result, 0, temp); return result; &#125;private: void getNumber(vector&lt;int&gt;&amp; candidates, int target, vector&lt;vector&lt;int&gt;&gt;&amp; result, int begin, vector&lt;int&gt; temp) &#123; if (begin &gt;= candidates.size()) return; if (target &lt; candidates[begin]) return; int num = candidates[begin]; if (target == num) &#123; temp.push_back(num); result.push_back(temp); return; &#125; int n = begin; while (n &lt; candidates.size() &amp;&amp; candidates[n] == num) n++; getNumber(candidates, target, result, n, temp); temp.push_back(num); getNumber(candidates, target - num, result, begin + 1, temp); &#125;&#125;; 41 ~ 60 Problems41 First Missing Positive难度：Hard12345678910111213141516171819202122class Solution &#123;public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 1; int n = nums.size(); for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] != i + 1 &amp;&amp; nums[i] &gt; 0 &amp;&amp; nums[i] &lt; n &amp;&amp; nums[i] != nums[nums[i]- 1]) &#123; int temp = nums[i]; nums[i] = nums[temp - 1]; nums[temp - 1] = temp; i--; &#125; &#125; int i = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] != i + 1) return i + 1; &#125; return nums.size() + 1; &#125;&#125;; 42 Trapping Rain Water难度：Hard1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; if (height.size() == 0) return 0; vector&lt;int&gt; storage(height.size(),0); int begin = 0, end = 0; while (begin &lt; height.size()) &#123; end = foundNextTaller(height, begin); int h = height[begin] &gt; height[end] ? height[end] : height[begin]; for (int i = begin; i &lt;= end; i++) &#123; storage[i] = h; &#125; begin = end; if (begin == height.size() - 1) break; &#125; int trap = 0; for (int i = 0; i &lt; height.size(); i++) &#123; if(storage[i] &gt; height[i]) trap += storage[i] - height[i]; &#125; return trap; &#125;private: int foundNextTaller(vector&lt;int&gt;&amp; height, int begin) &#123; if (begin == height.size() - 1) return begin; int h = height[begin]; int end = begin + 1; int maxHeight = 0, end2 = end; while (end &lt; height.size()) &#123; if (height[end] &gt;= h) return end; if (height[end] &gt; maxHeight) &#123; maxHeight = height[end]; end2 = end; &#125; end++; &#125; return end2; &#125;&#125;; 43 Multiply Strings难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123;public: string multiply(string num1, string num2) &#123; string result = \"0\"; if (num1.size() &gt; num2.size()) &#123; string tem = num1; num1 = num2; num2 = tem; &#125; string num = num2; for (int i = num1.size() - 1; i &gt;= 0; i--) &#123; int n = num1[i] - '0'; if (n &gt; 0) &#123; for (int j = 0; j &lt; n; j++) &#123; result = Add(result, num); &#125; &#125; num.push_back('0'); &#125; return result; &#125;private: string Add(string &amp;num1, string &amp;num2) &#123; int l = num1.size() &gt; num2.size() ? num2.size() : num1.size(); string result; int n1 = 0, n2 = 0; for (int i = 0; i &lt; l; i++) &#123; int x1 = num1[num1.size() - i - 1] - '0'; int x2 = num2[num2.size() - i - 1] - '0'; n2 = (n1 + x1 + x2) &gt;= 10 ? 1 : 0; n1 = (n1 + x1 + x2) &gt;= 10 ? ((n1 + x1 + x2) - 10) : (n1 + x1 + x2); result = (char)('0' + n1) + result; n1 = n2; &#125; if (num1.size() &gt; l) &#123; for (int i = 0; i &lt; num1.size() - l; i++) &#123; int x1 = num1[num1.size() - l - i - 1] - '0'; n2 = (n1 + x1) &gt;= 10 ? 1 : 0; n1 = (n1 + x1) &gt;= 10 ? ((n1 + x1) - 10) : (n1 + x1) ; result = (char)('0' + n1) + result; n1 = n2; &#125; &#125; if (num2.size() &gt; 1) &#123; for (int i = 0; i &lt; num2.size() - l; i++) &#123; int x2 = num2[num2.size() - l - i - 1] - '0'; n2 = (n1 + x2) &gt;= 10 ? 1 : 0; n1 = (n1 + x2) &gt;= 10 ? ((n1 + x2) - 10) : (n1 + x2); result = (char)('0' + n1) + result; n1 = n2; &#125; &#125; if(n1 &gt; 0) result = '1' + result; return result; &#125;&#125;; 44 Wildcard Matching难度：Hard12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool isMatch(string s, string p) &#123; bool *f[2]; int lens = s.size(), lenp = p.size(); f[0] = new bool[lenp + 1], f[1] = new bool[lenp + 1]; f[0][0] = true; for (int i = 1; i &lt;= lenp; ++i) if (p[i - 1] == '*') f[0][i] = f[0][i - 1]; else f[0][i] = false; int now = 0; for (int i = 1; i &lt;= lens; ++i) &#123; now ^= 1, f[now][0] = false; for (int j = 1; j &lt;= lenp; ++j) switch (p[j - 1]) &#123; case '*': f[now][j] = f[now ^ 1][j - 1] | f[now ^ 1][j] | f[now][j - 1]; break; case '?': f[now][j] = f[now ^ 1][j - 1]; break; default: f[now][j] = f[now ^ 1][j - 1] &amp; (s[i - 1] == p[j - 1]); break; &#125; &#125; return f[now][lenp]; &#125;&#125;; 45 Jump Game II难度：Hard1234567891011121314151617181920212223class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt;= 1) return 0; int start = 0; int end = 0; int nextend = 0; int times = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; nextend = nextend &gt; (i + nums[i]) ? nextend : (i + nums[i]); if (nextend &gt;= nums.size() - 1) return times + 1; if (i == end) &#123; times++; end = nextend; &#125; &#125; return times; &#125;&#125;; 46 Permutations难度：Medium12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; if (nums.size() == 0) return result; getpermute(result, nums, 0); return result; &#125; void getpermute(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; nums, int k) &#123; if (k == nums.size()) result.push_back(nums); for (int i = k; i &lt; nums.size(); i++) &#123; swap(nums[k], nums[i]); getpermute(result, nums, k + 1); &#125; &#125;&#125;; 47 Permutations II难度：Medium123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return&#123;&#125;; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; result; get(result, nums, 0); return result; &#125; void get(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; nums, int begin) &#123; if (begin == nums.size() - 1) &#123; result.push_back(nums); return; &#125; for (int i = begin; i &lt; nums.size(); i++) &#123; if ( i != begin &amp;&amp; nums[begin] == nums[i]) continue; swap(nums[i], nums[begin]); get(result, nums, begin + 1); &#125; &#125;&#125;; 48 Rotate Image难度：Medium12345678910111213141516171819202122232425class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.size() == 0) return; int N = matrix.size(); for (int m = 0; m &lt; N / 2; m++) &#123; for (int n = m; n &lt; N - 1 - m; n++) &#123; swap(matrix[m][n], matrix[n][N - 1 - m]); swap(matrix[m][n], matrix[N - 1 - m][N - 1 - n]); swap(matrix[m][n], matrix[N - 1 - n][m]); /*int tem[4]; tem[0] = matrix[m][n]; tem[1] = matrix[n][N - 1 - m]; tem[2] = matrix[N - 1 - m][N - 1 - n]; tem[3] = matrix[N - 1 - n][m]; matrix[m][n] = tem[3]; matrix[n][N - 1 - m] = tem[0]; matrix[N - 1 - m][N - 1 - n] = tem[1]; matrix[N - 1 - n][m] = tem[2];*/ &#125; &#125; &#125;&#125;; 49 Group Anagrams难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; if (strs.size() == 0) return&#123;&#125;; vector&lt;string&gt; sortedStrs; for (int i = 0; i &lt; strs.size(); i++) &#123; string str = strs[i]; sort(str.begin(), str.end()); sortedStrs.push_back(str); &#125; vector&lt;vector&lt;string&gt;&gt; result; map&lt;string, vector&lt;string&gt;&gt; style; for (int i = 0; i &lt; sortedStrs.size(); i++) &#123; if (style.size() &gt; 0 &amp;&amp; style.find(sortedStrs[i]) != style.end()) &#123; style[sortedStrs[i]].push_back(strs[i]); &#125; else style.insert(&#123; sortedStrs[i], &#123; strs[i] &#125; &#125;); &#125; for (auto p = style.begin(); p != style.end(); p++) &#123; result.push_back(p-&gt;second); &#125; /*for (int i = 0; i &lt; sortedStrs.size(); i++) &#123; for (int j = 0; j &lt; sortedStrs.size() - 1 - i; j++) &#123; if (sortedStrs[j] &gt; sortedStrs[j + 1]) &#123; swap(sortedStrs[j], sortedStrs[j + 1]); swap(strs[j], strs[j + 1]); &#125; &#125; &#125; int begin = 0; while (begin &lt; sortedStrs.size()) &#123; int end = begin; while (end + 1 &lt; sortedStrs.size() &amp;&amp; sortedStrs[end] == sortedStrs[end + 1]) &#123; end++; &#125; vector&lt;string&gt; line; for (int i = begin; i &lt;= end; i++) &#123; line.push_back(strs[i]); &#125; result.push_back(line); begin = end + 1; &#125;*/ return result; &#125;&#125;; 50 Pow(x,n)难度：Medium1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: double myPow(double x, int n) &#123; if (n == 0) return 1; if (x == 1) return 1; if (x == -1) if (n % 2 == 0) return 1; else return -1; bool negative = false; if (n &lt; 0) &#123; if (n == INT_MIN) return 0; negative = true; n = -n; &#125; string num = TenToTwo(n); double result = 1; for (int i = 0; i &lt; num.size(); i++) &#123; if (num[i] == '1') &#123; result = result * result * x; &#125; else result = result * result; &#125; if (negative) result = 1 / result; return result; &#125; string TenToTwo(int n) &#123; string result; while (n &gt; 0) &#123; if (n &amp; 1) result = \"1\" + result; else result = \"0\" + result; n /= 2; &#125; return result; &#125;&#125;; 51 N-Queens难度：Hard1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; if (n == 0) return&#123;&#125;; vector&lt;string&gt; block = &#123; (unsigned int)n,string((unsigned int)n,'.') &#125;; vector&lt;bool&gt; checkRow(n, false); vector&lt;bool&gt; checkColumn(n, false); vector&lt;bool&gt; checkDiagonal1(n * 2, false); vector&lt;bool&gt; checkDiagonal2(n * 2, false); vector&lt;vector&lt;string&gt;&gt; result; getResult(result, 0, checkColumn, checkDiagonal1,checkDiagonal2, block); return result; &#125;private: void getResult(vector&lt;vector&lt;string&gt;&gt;&amp; result, int row, vector&lt;bool&gt;&amp; column, vector&lt;bool&gt;&amp; diagonal1, vector&lt;bool&gt;&amp; diagonal2, vector&lt;string&gt;&amp; block) &#123; if (row &gt;= block.size()) &#123; result.push_back(block); return; &#125; int n = column.size(); for (int i = 0; i &lt; n; i++) &#123; int k = row - i + n; int w = row + i ; if (column[i] == false &amp;&amp; diagonal1[k] == false &amp;&amp; diagonal2[w] == false) &#123; column[i] = true; diagonal1[k] = true; diagonal2[w] = true; block[row][i] = 'Q'; getResult(result, row + 1, column, diagonal1,diagonal2, block); column[i] = false; diagonal1[k] = false; diagonal2[w] = false; block[row][i] = '.'; &#125; &#125; &#125;&#125;; 52 N-Queens II难度：Hard1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int totalNQueens(int n) &#123; if (n == 0) return&#123;&#125;; vector&lt;bool&gt; checkRow(n, false); vector&lt;bool&gt; checkColumn(n, false); vector&lt;bool&gt; checkDiagonal1(n * 2, false); vector&lt;bool&gt; checkDiagonal2(n * 2, false); int result = 0; getResult(result, 0, checkColumn, checkDiagonal1, checkDiagonal2,n); return result; &#125;private: void getResult(int&amp; result, int row, vector&lt;bool&gt;&amp; column, vector&lt;bool&gt;&amp; diagonal1, vector&lt;bool&gt;&amp; diagonal2,int N) &#123; if (row &gt;= N) &#123; result++; return; &#125; int n = column.size(); for (int i = 0; i &lt; n; i++) &#123; int k = row - i + n; int w = row + i; if (column[i] == false &amp;&amp; diagonal1[k] == false &amp;&amp; diagonal2[w] == false) &#123; column[i] = true; diagonal1[k] = true; diagonal2[w] = true; getResult(result, row + 1, column, diagonal1, diagonal2, N); column[i] = false; diagonal1[k] = false; diagonal2[w] = false; &#125; &#125; &#125;&#125;; 53 Maximum Subarray难度：Easy123456789101112131415161718192021222324class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 0; int begin = 0, end = begin, maxSum = INT_MIN; while (begin &lt; nums.size()) &#123; if (nums[begin] &gt; maxSum) maxSum = nums[begin]; int sum = 0; end = begin; while (end &lt; nums.size()) &#123; sum += nums[end]; if (sum &gt; maxSum) maxSum = sum; if (sum &lt; 0) break; end++; &#125; begin = end + 1; &#125; return maxSum; &#125;&#125;; 54 Jump Game难度：Medium123456789101112131415class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int maxLength = 0; for (int i = 0; i &lt; nums.size() - 1; i++) &#123; if (maxLength &lt; i) return false; if (maxLength &lt; i + nums[i]) maxLength = i + nums[i]; &#125; if (maxLength &lt; nums.size() - 1) return false; return true; &#125;&#125;; 55 Spiral Matrix难度：Medium123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(); if (m == 0) return&#123;&#125;; int n = matrix[0].size(); vector&lt;int&gt; result; int min = m &lt; n ? m : n; int loop = min / 2; for (int k = 0; k &lt; loop; k++) &#123; for (int i = k; i &lt; n - k; i++) &#123; result.push_back(matrix[k][i]); &#125; result.pop_back(); for (int i = k; i &lt; m - k; i++) &#123; result.push_back(matrix[i][n - k - 1]); &#125; result.pop_back(); for (int i = n - k - 1; i &gt;= k; i--) &#123; result.push_back(matrix[m - k - 1][i]); &#125; result.pop_back(); for (int i = m - k - 1; i &gt;= k; i--) &#123; result.push_back(matrix[i][k]); &#125; result.pop_back(); &#125; if (m &lt;= n &amp;&amp; m % 2) &#123; for (int i = m / 2; i &lt; n - m / 2; i++) &#123; result.push_back(matrix[m / 2][i]); &#125; &#125; else if (n &lt; m &amp;&amp; n % 2) &#123; for (int i = n / 2; i &lt; m - n / 2; i++) &#123; result.push_back(matrix[i][n / 2]); &#125; &#125; return result; &#125;&#125;; 56 Merge Intervals难度：Medium12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; if (intervals.size() == 0) return&#123;&#125;; map&lt;int,int&gt; list; vector&lt;Interval&gt; result; for (int i = 0; i &lt; intervals.size(); i++) &#123; if (list.size() == 0 || list.find(intervals[i].start) == list.end()) &#123; list.insert(&#123; intervals[i].start, intervals[i].end &#125;); &#125; else &#123; if (list[intervals[i].start] &lt; intervals[i].end) &#123; list[intervals[i].start] = intervals[i].end; &#125; &#125; &#125; for (auto p = list.begin(); p != list.end(); p++) &#123; if (result.size() != 0 &amp;&amp; result.back().end &gt;= p-&gt;first) &#123; if(result.back().end &lt; p-&gt;second) result.back().end = p-&gt;second; &#125; else &#123; Interval x(p-&gt;first, p-&gt;second); result.push_back(x); &#125; &#125; return result; &#125;&#125;; 57 Insert Interval难度：Hard1234567891011121314151617181920212223class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; temp = intervals; temp.push_back(newInterval); sort(temp.begin(), temp.end(), [](Interval a, Interval b) &#123; return a.start &lt; b.start; &#125; ); vector&lt;Interval&gt; result; for (int i = 0; i &lt; temp.size(); i++) &#123; if (result.size() != 0 &amp;&amp; temp[i].start &lt;= result.back().end) &#123; if (temp[i].end &gt; result.back().end) result.back().end = temp[i].end; &#125; else &#123; result.push_back(temp[i]); &#125; &#125; return result; &#125;&#125;; 58 Length of Last Word难度：Easy12345678910111213141516class Solution &#123;public: int lengthOfLastWord(string s) &#123; if (s.size() == 0) return 0; int length = 0; int i = s.size() - 1; while (i &gt;= 0 &amp;&amp; s[i] == ' ') i--; while (i &gt;= 0 &amp;&amp; s[i] != ' ') &#123; i--; length++; &#125; return length; &#125;&#125;; 59 Spiral Matrix II难度：Medium123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; if (n &lt;= 0) return&#123;&#125;; vector&lt;vector&lt;int&gt;&gt; result(n, vector&lt;int&gt;(n, 0)); int x = 1; for (int i = 0; i &lt; n / 2; i++) &#123; for (int k = i; k &lt; n - i; k++) &#123; result[i][k] = x++; &#125; x--; for (int k = i; k &lt; n - i; k++) &#123; result[k][n - i - 1] = x++; &#125; x--; for (int k = n - i - 1; k &gt;= i; k--) &#123; result[n - i - 1][k] = x++; &#125; x--; for (int k = n - i - 1; k &gt;= i + 1; k--) &#123; result[k][i] = x++; &#125; &#125; if (n % 2) &#123; result[n / 2][n / 2] = x; &#125; return result; &#125;&#125;; 60 Permutation Sequence难度：Medium1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: string getPermutation(int n, int k) &#123; if (n == 0) return \"\"; vector&lt;bool&gt; exist(n + 1, true); int f = getFactorial(n); int k2 = k; string result; for (int i = n; i &gt;= 1; i--) &#123; f = f / i; int num = (k2 - 1) / f + 1; int x = 1; while (num &gt; 1) &#123; if (exist[x]) num--; x++; &#125; while (!exist[x]) x++; exist[x] = false; result += (char)(x + '0'); k2 = (k2 - 1) % f + 1; &#125; return result; &#125;private: int getFactorial(int n) &#123; int result = 1; for (int i = 2; i &lt;= n; i++) &#123; result *= i; &#125; return result; &#125;&#125;; 61 ~ 80 Problems61 Rotate List难度：Medium1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if (head == NULL) return head; int n = 0; ListNode* p1 = head; while (p1 != NULL) &#123; p1 = p1-&gt;next; n++; &#125; k = k % n; if (k == 0) return head; ListNode *tail = head, *p = head; int num = 0; while (p-&gt;next != NULL) &#123; p = p-&gt;next; num++; if (num &gt; k) tail = tail-&gt;next; &#125; p-&gt;next = head; ListNode* nhead = tail-&gt;next; tail-&gt;next = NULL; return nhead; &#125;&#125;; 62 Unique Paths难度：Medium1234567891011121314151617181920class Solution &#123;public: int uniquePaths(int m, int n) &#123; if (m &lt;= 1 || n &lt;= 1) return 1; vector&lt;vector&lt;int&gt;&gt; path(2, vector&lt;int&gt;(n, 0)); bool now = 0; for (int i = 0; i &lt; n; i++) &#123; path[0][i] = 1; &#125; for (int i = 1; i &lt; m; i++) &#123; now = !now; path[now][0] = 1; for (int j = 1; j &lt; n; j++) &#123; path[now][j] = path[!now][j] + path[now][j - 1]; &#125; &#125; return path[now][n - 1]; &#125;&#125;; 63 Unique Paths ||难度：Medium12345678910111213141516171819202122232425262728class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(); if (m &lt;= 0) return 0; int n = obstacleGrid[0].size(); if (n &lt;= 0) return 0; int line = 0; vector&lt;vector&lt;int&gt;&gt; path(2, vector&lt;int&gt;(n, 0)); bool now = 0; path[now][0] = obstacleGrid[line][0] == 0 ? 1 : 0;; for (int i = 1; i &lt; n; i++) &#123; path[now][i] = obstacleGrid[line][i] == 0 ? path[now][i-1]: 0; &#125; for (int i = 1; i &lt; m; i++) &#123; line++; now = !now; path[now][0] = obstacleGrid[line][0] == 0 ? path[!now][0] : 0; for (int j = 1; j &lt; n; j++) &#123; path[now][j] = obstacleGrid[line][j] == 0 ? path[!now][j] + path[now][j - 1] : 0; &#125; &#125; return path[now][n - 1]; &#125;&#125;; 64 Minimum Path Sum难度：Medium12345678910111213141516171819202122232425262728class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); if (m &lt;= 0) return 0; int n = grid[0].size(); if (n &lt;= 0) return 0; vector&lt;vector&lt;int&gt;&gt; pathSum(2, vector&lt;int&gt;(n, 0)); bool now = 0; int line = 0; pathSum[0][0] = grid[0][0]; for (int j = 0; j &lt; n; j++) &#123; pathSum[now][j] = grid[line][j] + pathSum[now][j-1]; &#125; for (line = 1; line &lt; m; line++) &#123; now = !now; pathSum[now][0] = grid[line][0] + pathSum[!now][0]; for (int j = 1; j &lt; n; j++) &#123; pathSum[now][j] = min(pathSum[!now][j], pathSum[now][j - 1]) + grid[line][j]; &#125; &#125; return pathSum[now][n - 1]; &#125;&#125;; 65 Valid Number难度：Hard123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution &#123;public: bool isNumber(string s) &#123; if (s.size() == 0) return false; int begin = 0; int end = s.size() - 1; while (begin &lt; s.size() &amp;&amp; isspace(s[begin])) begin++; if (s[begin] == '-' || s[begin] == '+') begin++; while (end &gt;= 0 &amp;&amp; isspace(s[end])) end--; if (begin &gt; end) return false; int p = begin; bool haspoint = false; bool afterE = false; bool hasPulse = false;; bool hasSub = false; while (p &lt;= end) &#123; char c = s[p]; switch (c) &#123; case '+': if (!afterE || p == end || hasPulse) return false; hasPulse = true; break; case '-': if (!afterE || p == end || hasSub) return false; hasSub = true; break; case '.': if (afterE) return false; if (p == begin) &#123; if (p == end) return false; else if (s[p + 1] == 'e') return false; &#125; if (!haspoint) &#123; haspoint = true; &#125; else return false; break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': break; case 'e': if (afterE) return false; if (p == end || p == begin) return false; //if (isZero(s.substr(begin, p - begin))) //return false; afterE = true; break; default: return false; break; &#125; p++; &#125; return true; &#125;&#125;; 66 Plus One难度：Easy123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; int n = digits.size(); vector&lt;int&gt; tem = digits; int i = n - 1; while (i &gt;= 0) &#123; if (tem[i] == 9) tem[i] = 0; else &#123; tem[i] += 1; break; &#125; i--; &#125; if (i &lt; 0) &#123; vector&lt;int&gt; result(n + 1, 0); result[0] = 1; return result; &#125; return tem; &#125;&#125;; 67 Add Binary难度：Easy12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: string addBinary(string a, string b) &#123; if (a.size() == 0) return b; else if (b.size() == 0) return a; int now = 0, next = 0; string result; int n1 = a.size() - 1, n2 = b.size() - 1; while (n1 &gt;= 0 &amp;&amp; n2 &gt;= 0) &#123; now = (a[n1] - '0' + b[n2] - '0' + next) &amp; 1; next = ((a[n1] - '0' + b[n2] - '0' + next) &gt;&gt; 1) &amp; 1; result = (char)('0' + now) + result; n1--; n2--; &#125; while (n1 &gt;= 0) &#123; now = (a[n1] - '0' + next) &amp; 1; next = ((a[n1] - '0' + next) &gt;&gt; 1) &amp; 1; result = (char)('0' + now) + result; n1--; &#125; while (n2 &gt;= 0) &#123; now = (b[n2] - '0' + next) &amp; 1; next = ((b[n2] - '0' + next) &gt;&gt; 1) &amp; 1; result = (char)('0' + now) + result; n2--; &#125; if (next &gt; 0) result = '1' + result; return result; &#125;&#125;; 68 Text Justification难度：Hard12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) &#123; int n = words.size(); if (n == 0 || maxWidth == 0) return&#123;\"\"&#125;; vector&lt;string&gt; result; int begin = 0; while (begin &lt; words.size()) &#123; int end = begin; int length = 0; while (end &lt; words.size() &amp;&amp; length + words[end].size() &lt;= maxWidth - end + begin) &#123; length += words[end].size(); end++; &#125; if (end == words.size()) &#123; string str; for (int i = begin; i &lt; end; i++) &#123; if (i != end - 1) &#123; str += words[i] + ' '; &#125; else str += words[i]; &#125; if(str.size() &lt; maxWidth) str += string(maxWidth - str.size(),' '); result.push_back(str); &#125; else &#123; int NSpace = maxWidth - length; int average = (end - begin - 1) == 0 ? 0 : NSpace / (end - begin - 1); int extra = (end - begin - 1) == 0 ? 0 : NSpace % (end - begin - 1); string str; for (int i = begin; i &lt; end; i++) &#123; if (i != end - 1) &#123; if (i &lt; begin + extra) &#123; str += words[i] + string(average + 1, ' '); &#125; else str += words[i] + string(average, ' '); &#125; else str += words[i]; &#125; if (str.size() &lt; maxWidth) str += string(maxWidth - str.size(), ' '); result.push_back(str); &#125; begin = end; &#125; return result; &#125;&#125;; 69 Sqrt(x)难度：Easy1234567891011121314151617181920212223242526class Solution &#123;public: int mySqrt(int x) &#123; if (x == 0) return 0; int begin = 1, end = x; int mid; while (begin &lt;= end) &#123; mid = (begin + end) / 2; int y = x / mid; if (mid == y) return mid; else if (mid &lt; y) &#123; if ((mid + 1) * (mid + 1) &gt; x) return mid; else &#123; begin = mid + 1; &#125; &#125; else if (mid &gt; y) &#123; end = mid - 1; &#125; &#125; return min(begin,end); &#125;&#125;; 70 Climbing Stairs难度：Easy12345678910111213141516class Solution &#123;public: int climbStairs(int n) &#123; if (n == 1) return 1; //vector&lt;int&gt; stepNum = vector&lt;int&gt;(n + 1, 0); int a = 1, b = 1, c; for (int i = 2; i &lt;= n; i++) &#123; c = a + b; a = b; b = c; &#125; return c; &#125;&#125;; 71 Simplify Path难度：Medium1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: string simplifyPath(string path) &#123; vector&lt;string&gt; s; s.push_back(\"/\"); int begin = 0, end; while (begin &lt; path.size()) &#123; if (path[begin] == '/') &#123; begin++; continue; &#125; end = begin; while (end &lt; path.size() &amp;&amp; path[end] != '/') end++; string str = path.substr(begin, end - begin); if (str == \".\") &#123; &#125; else if (str == \"..\") &#123; if(s.size() &gt; 1) s.pop_back(); &#125; else s.push_back(str); begin = end + 1; &#125; if (s.size() == 1) return \"/\"; string result; for (int i = 1; i &lt; s.size(); i++) &#123; result += \"/\" + s[i]; &#125; return result; &#125;&#125;; 72 Edit Distance难度：Hard123456789101112131415161718192021222324252627282930class Solution &#123;public: int minDistance(string word1, string word2) &#123; if (word1.size() == 0) return word2.size(); else if (word2.size() == 0) return word1.size(); int m = word1.size(), n = word2.size(); vector&lt;vector&lt;int&gt;&gt; check(2, vector&lt;int&gt;(n+ 1, 0)); bool now = 0; int line = 0; for (int i = 0; i &lt;= n; i++) &#123; check[now][i] = i; &#125; for (int line = 1; line &lt;= m; line++) &#123; now = !now; check[now][0] = line; for (int i = 1; i &lt;= n; i++) &#123; if (word1[line - 1] == word2[i -1]) &#123; check[now][i] = min(min(check[!now][i - 1], check[now][i - 1] + 1), check[!now][i] + 1); &#125; else check[now][i] = min(min(check[!now][i - 1] + 1, check[now][i - 1] + 1), check[!now][i] + 1); &#125; &#125; return check[now][n]; &#125;&#125;; 73 Set Marix Zeros难度：Medium123456789101112131415161718192021222324252627class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.size() == 0) return; vector&lt;int&gt; row,column; for (int i = 0; i &lt; matrix.size(); i++) &#123; for (int j = 0; j &lt; matrix[0].size(); j++) &#123; if (matrix[i][j] == 0) &#123; row.push_back(i); column.push_back(j); &#125; &#125; &#125; for (int i = 0; i &lt; row.size(); i++) &#123; for (int j = 0; j &lt; matrix[0].size(); j++) &#123; matrix[row[i]][j] = 0; &#125; &#125; for (int i = 0; i &lt; column.size(); i++) &#123; for (int j = 0; j &lt; matrix.size(); j++) &#123; matrix[j][column[i]] = 0; &#125; &#125; &#125;&#125;; 74 Search a 2D Matrix难度：Medium12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int row = matrix.size(); if (row == 0) return false; int column = matrix[0].size(); int length = row * column; int begin = 0, end = length - 1, mid; while (begin &lt;= end) &#123; mid = (begin + end) / 2; int x = getNumber(matrix, mid); if (x &gt; target) &#123; end = mid - 1; &#125; else if (x &lt; target) &#123; begin = mid + 1; &#125; else return true; &#125; return false; &#125;private: int getNumber(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int length) &#123; int r = length / (matrix[0].size()); int c = length % (matrix[0].size()); return matrix[r][c]; &#125;&#125;; 75 Sort Colors难度：Medium12345678910111213141516171819202122232425class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int begin = 0, end = n - 1; while (begin &lt; end) &#123; while (begin &lt; n &amp;&amp; nums[begin] == 0) begin++; while (end &gt;= 0 &amp;&amp; nums[end] != 0) end--; if(begin &lt; end) swap(nums[begin], nums[end]); &#125; begin = 0, end = n - 1; while (begin &lt; end) &#123; while (begin &lt; n &amp;&amp; nums[begin] != 2) begin++; while (end &gt;= 0 &amp;&amp; nums[end] == 2) end--; if (begin &lt; end) swap(nums[begin], nums[end]); &#125; &#125;&#125;; 76 Minimum Window Substring难度：Hard1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string minWindow(string s, string t) &#123; if (s.size() &lt; t.size()) return \"\"; int digit[128] = &#123;&#125;; bool exist[128] = &#123;&#125;; for (int i = 0; i &lt; t.size(); i++) &#123; digit[t[i]]++; exist[t[i]] = true; &#125; int remender = t.size(); int begin = 0, end = -1; int rb = -1, re = -1; while (end &lt; (int)s.size()) &#123; if (remender == 0) &#123; if (re == -1 || end - begin + 1 &lt; re - rb + 1) &#123; re = end; rb = begin; &#125; if (exist[s[begin]]) &#123; if (digit[s[begin]] &gt;= 0) remender++; digit[s[begin]]++; &#125; begin++; &#125; else &#123; end++; if (exist[s[end]]) &#123; if (digit[s[end]] &gt; 0) remender--; digit[s[end]]--; &#125; &#125; &#125; if (rb == -1) return \"\"; else return s.substr(rb, re - rb + 1); &#125;&#125;; 77 Combinations难度：Medium12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; if (k &lt;= 0) return&#123;&#125;; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; list; getResult(result, list, k, 1, n); return result; &#125; void getResult(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; list,int k,int num,int n) &#123; if (list.size() == k) &#123; result.push_back(list); return; &#125; for (int i = num; i &lt;= n; i++) &#123; list.push_back(i); getResult(result, list, k, i+1, n); list.pop_back(); &#125; &#125;&#125;; 78 Subsets难度：Medium1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; list; getList(result, list, nums, 0); return result; &#125; void getList(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; list,vector&lt;int&gt;&amp; nums, int num) &#123; result.push_back(list); for (int i = num; i &lt; nums.size(); i++) &#123; list.push_back(nums[i]); getList(result, list, nums, i + 1); list.pop_back(); &#125; &#125;&#125;; 79 Word Search难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (board.size() == 0) return false; vector&lt;vector&lt;bool&gt;&gt; check(board.size(), vector&lt;bool&gt;(board[0].size(), 0)); for (int i = 0; i &lt; board.size(); i++) &#123; for (int j = 0; j &lt; board[0].size(); j++) &#123; if (board[i][j] == word[0]) &#123; check[i][j] = true; if (depthSearch(board, check, word, 1, i, j)) return true; check[i][j] = false; &#125; &#125; &#125; return false; &#125;private: bool depthSearch(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;bool&gt;&gt;&amp; check, string&amp; word, int k, int x, int y) &#123; if (k == word.size()) return true; if (x &gt; 0) &#123; if (board[x - 1][y] == word[k] &amp;&amp; !check[x - 1][y] ) &#123; check[x - 1][y] = true; if (depthSearch(board, check, word, k + 1, x - 1, y)) return true; check[x - 1][y] = false; &#125; &#125; if (x &lt; board.size() - 1) &#123; if (board[x + 1][y] == word[k] &amp;&amp; !check[x + 1][y]) &#123; check[x + 1][y] = true; if (depthSearch(board, check, word, k + 1, x + 1, y)) return true; check[x + 1][y] = false; &#125; &#125; if (y &gt; 0) &#123; if (board[x][y - 1] == word[k] &amp;&amp; !check[x][y - 1]) &#123; check[x][y - 1] = true; if (depthSearch(board, check, word, k + 1, x, y - 1)) return true; check[x][y - 1] = false; &#125; &#125; if (y &lt; board[0].size() - 1) &#123; if (board[x][y + 1] == word[k] &amp;&amp; !check[x][y + 1]) &#123; check[x][y + 1] = true; if (depthSearch(board, check, word, k + 1, x, y + 1)) return true; check[x][y + 1] = false; &#125; &#125; return false; &#125;&#125;; 80 Remove Duplicates from Sorted Array II难度：Medium12345678910111213141516class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt;= 2) return nums.size(); int length = 2; for (int i = 2; i &lt; nums.size(); i++) &#123; if (nums[length - 2] != nums[i]) &#123; length++; if (i &gt; length - 1) swap(nums[i], nums[length - 1]); &#125; &#125; return length; &#125;&#125;; 81 ~ 100 Problems81 Search in Rotated Sorted Array II难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.size() == 0) return false; int begin = 0, end = nums.size() - 1, mid; int min = getMin(nums); while (begin &lt;= end) &#123; mid = (begin + end) / 2; int x = nums[(mid + min) % nums.size()]; if (x &gt; target) &#123; end = mid - 1; &#125; else if (x &lt; target) begin = mid + 1; else return true; &#125; return false; &#125;private: int getMin(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 1 || nums.back() &gt; nums[0]) return 0; int begin = 0, end = nums.size() - 1, mid; while (begin &lt;= end) &#123; mid = (begin + end) / 2; if (mid &gt; 0 &amp;&amp; nums[mid] &lt; nums[mid - 1]) return mid; if (nums[mid] &gt; nums[end]) &#123; begin = mid + 1; &#125; else if (nums[mid] &lt; nums[begin]) &#123; end = mid - 1; &#125; else if (nums[end] == nums[begin]) end--; else break; &#125; if (begin &gt; 0 &amp;&amp; nums[begin] &lt; nums[begin - 1]) return begin; else return end + 1; &#125;&#125;; 82 Remove Duplicates from Sorted List II难度：Medium123456789101112131415161718192021222324252627class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (head == NULL) return NULL; ListNode *mhead = new ListNode(0); mhead-&gt;next = head; ListNode *low = head, *far = head; ListNode *oldlow = mhead; int old = far-&gt;val; while (far != NULL) &#123; if (far-&gt;next != NULL &amp;&amp; far-&gt;val == far-&gt;next-&gt;val) &#123; old = far-&gt;val; while (far != NULL &amp;&amp; far-&gt;val == old) far = far-&gt;next; &#125; else &#123; low-&gt;val = far-&gt;val; oldlow = low; low = low-&gt;next; far = far-&gt;next; &#125; &#125; oldlow-&gt;next = NULL; return low == head ? NULL : head; &#125;&#125;; 83 Remove Duplicates from Sorted List难度：Easy123456789101112131415161718class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (head == NULL) return NULL; ListNode *far = head, *low = head, *oldlow; while (far != NULL) &#123; while (far-&gt;next != NULL &amp;&amp; far-&gt;val == far-&gt;next-&gt;val) far = far-&gt;next; low-&gt;val = far-&gt;val; oldlow = low; low = low-&gt;next; far = far-&gt;next; &#125; oldlow-&gt;next = NULL; return head; &#125;&#125;; 84 Largest Rectangle in Histogram难度：Hard12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; if (heights.size() == 0) return 0; int n = heights.size(); int maxA = 0; vector&lt;int&gt; left(n, 0); vector&lt;int&gt; right(n, 0); //left left[0] = 0; for (int i = 1; i &lt; n; i++) &#123; if (heights[i] &gt; heights[i - 1]) left[i] = 0; else &#123; int m = i - 1; while (m &gt;= 0 &amp;&amp; heights[m] &gt;= heights[i]) m -= left[m] + 1; left[i] = i - m - 1; &#125; &#125; //right right[n - 1] = 0; for (int i = n - 2; i &gt;= 0; i--) &#123; if (heights[i] &gt; heights[i + 1]) right[i] = 0; else &#123; int m = i + 1; while (m &lt; n &amp;&amp; heights[m] &gt;= heights[i]) m += right[m] + 1; right[i] = m - i - 1; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; int a = heights[i] * (left[i] + right[i] + 1); if (a &gt; maxA) maxA = a; &#125; return maxA; &#125;&#125;; 85 Maximal Rectangle难度：Hard123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution &#123;public: int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if (matrix.size() == 0) return 0; vector&lt;vector&lt;int&gt;&gt; height(matrix.size(), vector&lt;int&gt;(matrix[0].size(), 0)); for (int j = 0; j &lt; matrix[0].size(); j++) &#123; height[0][j] = matrix[0][j] - '0'; &#125; for (int i = 1; i &lt; matrix.size(); i++) &#123; for (int j = 0; j &lt; matrix[0].size(); j++) &#123; if (matrix[i][j] == '0') &#123; height[i][j] = 0; &#125; else height[i][j] = 1 + height[i - 1][j]; &#125; &#125; int maxR = 0; for (int i = 0; i &lt; matrix.size(); i++) &#123; int x = largestRectangleArea(height[i]); if (x &gt; maxR) maxR = x; &#125; return maxR; &#125;private: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; if (heights.size() == 0) return 0; int n = heights.size(); int maxA = 0; vector&lt;int&gt; left(n, 0); vector&lt;int&gt; right(n, 0); //left left[0] = 0; for (int i = 1; i &lt; n; i++) &#123; if (heights[i] &gt; heights[i - 1]) left[i] = 0; else &#123; int m = i - 1; while (m &gt;= 0 &amp;&amp; heights[m] &gt;= heights[i]) m -= left[m] + 1; left[i] = i - m - 1; &#125; &#125; //right right[n - 1] = 0; for (int i = n - 2; i &gt;= 0; i--) &#123; if (heights[i] &gt; heights[i + 1]) right[i] = 0; else &#123; int m = i + 1; while (m &lt; n &amp;&amp; heights[m] &gt;= heights[i]) m += right[m] + 1; right[i] = m - i - 1; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; int a = heights[i] * (left[i] + right[i] + 1); if (a &gt; maxA) maxA = a; &#125; return maxA; &#125;&#125;; 86 Partition List难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; if (head == NULL) return NULL; /* vector&lt;int&gt; v1; vector&lt;int&gt; v2; ListNode* p = head; while (p != NULL) &#123; if (p-&gt;val &lt; x) v1.push_back(p-&gt;val); else v2.push_back(p-&gt;val); p = p-&gt;next; &#125; p = head; for (int i = 0; i &lt; v1.size(); i++) &#123; p-&gt;val = v1[i]; p = p-&gt;next; &#125; for (int i = 0; i &lt; v2.size(); i++) &#123; p-&gt;val = v2[i]; p = p-&gt;next; &#125; return head;*/ ListNode l1(0); ListNode l2(0); ListNode* p1 = &amp;l1; ListNode* p2 = &amp;l2; while (head != NULL) &#123; if (head-&gt;val &lt; x) &#123; p1-&gt;next = head; p1 = p1-&gt;next; &#125; else &#123; p2-&gt;next = head; p2 = p2-&gt;next; &#125; head = head-&gt;next; &#125; p2-&gt;next = NULL; head = l1.next; if (head == NULL) &#123; return l2.next; &#125; else &#123; p1-&gt;next = l2.next; &#125; return head; &#125;&#125;; 87 Scramble String难度：Hard123456789101112131415161718192021222324252627282930class Solution &#123;public: bool isScramble(string s1, string s2) &#123; if (s1.size() != s2.size()) return false; if (s1.size() == 0) return true; int n = s1.size(); vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; check(n + 1, vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(n, 0))); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; check[1][i][j] = s1[i] == s2[j]; &#125; &#125; for (int l = 1; l &lt;= n; l++) &#123; for (int i = 0; i + l &lt;= n; i++) &#123; for (int j = 0; j + l &lt;= n; j++) &#123; for (int k = 1; k &lt; l; k++) &#123; check[l][i][j] = check[l][i][j] || (check[k][i][j + l - k] &amp;&amp; check[l - k][i + k][j]) || (check[k][i][j] &amp;&amp; check[l - k][i + k][j + k]); &#125; &#125; &#125; &#125; return check[n][0][0]; &#125;&#125;; 88 Merge Sorted Array难度：Easy12345678910111213141516171819class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; vector&lt;int&gt; nums(nums1.size(), 0); int i = 0, j = 0, k = 0; while (i &lt; m &amp;&amp; j &lt; n) &#123; if (nums1[i] &lt; nums2[j]) nums[k++] = nums1[i++]; else nums[k++] = nums2[j++]; &#125; while (i &lt; m) &#123; nums[k++] = nums1[i++]; &#125; while (j &lt; n) &#123; nums[k++] = nums2[j++]; &#125; nums1 = nums; &#125;&#125;; 89 Gray Code难度：Medium12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; if (n == 0) return&#123;&#125;; vector&lt;int&gt; result = &#123; 0,1 &#125;; if (n == 1) return result; result.push_back(3); result.push_back(2); for (int i = 3; i &lt;= n; i++) &#123; int num = result.size() / 2; for (int j = 0; j &lt; num; j++) &#123; result.push_back(result[j] + (3 &lt;&lt; (i - 2))); &#125; for (int j = num - 1; j &gt;= 0; j--) &#123; result.push_back(result[j] + (2 &lt;&lt; (i - 2))); &#125; &#125; return result; &#125;&#125;; 90 Subsets II难度：Medium12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return&#123; &#123;&#125; &#125;; sort(nums.begin(), nums.end()); int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; result; result.push_back(&#123;&#125;); int newnum = 1, samenum = 1; for (int i = 0; i &lt; n; i++) &#123; if (i == 0 || nums[i] != nums[i - 1]) &#123; newnum = result.size(); //ÖØ¸´Ö®Ç°µÄresultÖÐµÄ¸öÊý samenum = 1; //ÖØÖÃÖØ¸´¸öÊý int k = result.size(); for (int j = 0; j &lt; k; j++) &#123; result.push_back(result[j]); result.back().push_back(nums[i]); &#125; &#125; else &#123; samenum++; //ÖØ¸´µÄ¸öÊý for (int j = 0; j &lt; newnum; j++) &#123; result.push_back(result[j]); for (int m = 0; m &lt; samenum; m++) &#123; result.back().push_back(nums[i]); &#125; &#125; &#125; &#125; return result; &#125;&#125;; 91 Decode Ways难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: int numDecodings(string s) &#123; if (s.size() == 0 || s[0] == '0') return 0; vector&lt;int&gt; f(s.size(),0); f[0] = 1; if (s.size() == 1) return 1; if (s[1] == '0') &#123; if (s[0] == '1' || s[0] == '2') f[1] = 1; else return 0; &#125; else &#123; if (s[0] == '1') f[1] = 2; else if (s[0] == '2') &#123; if (s[1] &gt;= '1' &amp;&amp; s[1] &lt;= '6') f[1] = 2; else f[1] = 1; &#125; else f[1] = 1; &#125; for (int i = 2; i &lt; s.size(); i++) &#123; if (s[i] == '0') &#123; if (s[i - 1] == '1' || s[i - 1] == '2') f[i] = f[i - 2]; else return 0; &#125; else &#123; if (s[i - 1] == '1') &#123; f[i] = f[i - 1] + f[i - 2]; &#125; else if (s[i -1] == '2' &amp;&amp; (s[i] &gt;= '1' &amp;&amp; s[i] &lt;= '6')) f[i] = f[i - 1] + f[i - 2]; else f[i] = f[i - 1]; &#125; &#125; return f[s.size()- 1]; &#125;&#125;; 92 Reverse Linked List II难度：Medium12345678910111213141516171819202122232425262728293031class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; if (m == n) return head; ListNode* h = new ListNode(0); h-&gt;next = head; int num = 1; ListNode* p = h; while (num &lt; m) &#123; num++; p = p-&gt;next; &#125; ListNode* n1 = p; p = p-&gt;next; ListNode *p2 = p-&gt;next, *p3 = p2-&gt;next; ListNode* n2 = p; while (num &lt; n) &#123; p2-&gt;next = p; p = p2; p2 = p3; if(p3) p3 = p3-&gt;next; num++; &#125; n2-&gt;next = p2; n1-&gt;next = p; p = h-&gt;next; return h-&gt;next; &#125;&#125;; 93 Restore IP Address难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; int n = s.size(); if (s.size() &lt; 4) return&#123;&#125;; int N = s.size(); vector&lt;string&gt; result; for (int i = 1; i &lt;= 3; i++) &#123; if (!isvaild(s.substr(0, i))) continue; for (int j = 1; j &lt;= 3; j++) &#123; if (!isvaild(s.substr(i, j))) continue; for (int m = 1; m &lt;= 3; m++) &#123; int n = N - i - j - m; if (n &gt; 3 || n &lt;= 0) continue; if (!isvaild(s.substr(i + j, m))) continue; if (!isvaild(s.substr(i + j + m, n))) continue; result.push_back(s.substr(0, i) + \".\" + s.substr(i, j) + \".\" + s.substr(i + j, m) + \".\" + s.substr(i + j + m, n)); &#125; &#125; &#125; return result; &#125;private: bool isvaild(string str) &#123; if (str.size() == 1) return true; if (str[0] == '0') return false; if (str.size() &lt; 3) return true; if (str[0] &gt; '2') return false; else if (str[0] == '2') &#123; if (str[1] &gt; '5') return false; else if (str[1] == '5') &#123; if (str[2] &gt; '5') return false; &#125; &#125; return true; &#125;&#125;; 94 Binary Tree Inorder Traversal难度：Medium123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; if (root == NULL) return&#123;&#125;; vector&lt;int&gt; result; inorderTraversal(result, root); return result; &#125;private: void inorderTraversal(vector&lt;int&gt;&amp; result, TreeNode* node) &#123; if (node == NULL) return; if (node-&gt;left != NULL) inorderTraversal(result, node-&gt;left); result.push_back(node-&gt;val); if (node-&gt;right != NULL) inorderTraversal(result, node-&gt;right); &#125;&#125;; 95 Unique Binary Search Trees II难度：Medium123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123;public: vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if (n &lt;= 0) return&#123;&#125;; vector&lt;TreeNode*&gt; result; TreeNode* node = new TreeNode(1); result.push_back(node); for (int i = 2; i &lt;= n; i++) &#123; int n = result.size(); for (int k = 0; k &lt; n; k++) &#123; TreeNode * p = result[k]; int num = 0; while (p != NULL) &#123; TreeNode * p2 = copyTree(result[k]); TreeNode * p3 = p2; for (int j = 0; j &lt; num; j++) p3 = p3-&gt;right; TreeNode* right = p3-&gt;right; p3-&gt;right = new TreeNode(i); p3-&gt;right-&gt;left = right; result.push_back(p2); p = p-&gt;right; num++; &#125; p = new TreeNode(i); p-&gt;left = result[k]; result[k] = p; &#125; &#125; return result; &#125;private: TreeNode* copyTree(TreeNode* root) &#123; if (root == NULL) return NULL; TreeNode* node = new TreeNode(root-&gt;val); copy(root, node); return node; &#125; void copy(TreeNode* node1, TreeNode* node2) &#123; if (node1-&gt;left != NULL) &#123; node2-&gt;left = new TreeNode(node1-&gt;left-&gt;val); copy(node1-&gt;left, node2-&gt;left); &#125; if (node1-&gt;right != NULL) &#123; node2-&gt;right = new TreeNode(node1-&gt;right-&gt;val); copy(node1-&gt;right, node2-&gt;right); &#125; &#125;&#125;; 96 Unique Binary Search Trees难度：Medium123456789101112131415161718192021222324252627282930class Solution &#123;public: int numTrees(int n) &#123; if (n == 0) return 0; vector&lt;int&gt; result; result.push_back(1); result.push_back(1); for (int i = 2; i &lt;= n; i++) &#123; result.push_back(0); int num, oldnum; for (int j = 1; j &lt;= i; j++) &#123; num = result[j]; for (int k = j + 1; k &lt;= i; k++) &#123; result[j] += result[k]; &#125; if (j &gt; 1) result[j] += oldnum; oldnum = num; &#125; &#125; int r = 0; for (int i = 1; i &lt;= n; i++) r += result[i]; return r; &#125;&#125;; 97 Interleaving String难度：Hard1234567891011121314151617181920212223242526272829303132class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if (s1.size() == 0) return s2 == s3; if (s2.size() == 0) return s1 == s3; if (s1.size() + s2.size() != s3.size()) return false; vector&lt;vector&lt;bool&gt;&gt; check(s1.size() + 1, vector&lt;bool&gt;(s2.size() + 1, false)); check[0][0] = true; for (int i = 1; i &lt;= s1.size(); i++) &#123; check[i][0] = check[i - 1][0] &amp;&amp; (s1[i - 1] == s3[i - 1]); &#125; for (int j = 1; j &lt;= s2.size(); j++) &#123; check[0][j] = check[0][j - 1] &amp;&amp; (s2[j - 1] == s3[j - 1]); &#125; int i = 0, j = 0; for (int l = 1; l &lt;= s3.size(); l++) &#123; for (i = 1; i &lt;= s1.size() &amp;&amp; i &lt;= l; i++) &#123; j = l - i; if (j &gt; s2.size() || j &lt;= 0 ) continue; if (s1[i - 1] == s3[l - 1]) check[i][j] = check[i][j] || check[i - 1][j] ; if (s2[j - 1] == s3[l - 1]) check[i][j] = check[i][j] || check[i][j - 1]; &#125; &#125; return check[s1.size()][s2.size()]; &#125;&#125;; 98 Validate Binary Search Tree难度：Medium123456789101112131415161718192021222324class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; return judgeTree(root, INT_MIN, INT_MAX); &#125;private: bool judgeTree(TreeNode* node, int min, int max) &#123; if (node == NULL) return true; if (node-&gt;val &lt; min || node-&gt;val &gt; max) return false; else if (node-&gt;val == INT_MIN) &#123; if (node-&gt;left) return false; &#125; else if (node-&gt;val == INT_MAX) &#123; if (node-&gt;right) return false; &#125; return judgeTree(node-&gt;left, min, node-&gt;val - 1) &amp;&amp; judgeTree(node-&gt;right, node-&gt;val + 1, max); &#125;&#125;; 99 Recover Binary Search Tree难度：Hard1234567891011121314151617181920212223242526272829303132class Solution &#123;public: TreeNode* first = NULL, *second = NULL, *prev = NULL; void recoverTree(TreeNode* root) &#123; if (root == NULL) return; mid(root); if (first &amp;&amp; second) &#123; int tem = first-&gt;val; first-&gt;val = second-&gt;val; second-&gt;val = tem; &#125; &#125;private: void mid(TreeNode* node) &#123; if (node == NULL) return; mid(node-&gt;left); if (prev) &#123; if (node-&gt;val &lt;= prev-&gt;val) &#123; second = node; if (!first) first = prev; &#125; &#125; prev = node; mid(node-&gt;right); &#125;&#125;; 100 Same Tree难度：Easy12345678910111213141516171819202122class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if (p == NULL || q == NULL) return p == q; return isSame(p, q); &#125;private: bool isSame(TreeNode* p, TreeNode* q) &#123; if (p == NULL || q == NULL) return p == q; if (p-&gt;val != q-&gt;val) return false; return isSame(p-&gt;left, q-&gt;left) &amp;&amp; isSame(p-&gt;right, q-&gt;right); &#125;&#125;; 101 ~ 120 Problems101 Symmetric Tree难度：Easy123456789101112131415161718192021class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if (root == NULL) return true; return isMirror(root-&gt;left, root-&gt;right); &#125;private: bool isMirror(TreeNode* node1, TreeNode* node2) &#123; if (!node1 || !node2) return node1 == node2; if (node1-&gt;val != node2-&gt;val) return false; return isMirror(node1-&gt;left, node2-&gt;right) &amp;&amp; isMirror(node1-&gt;right, node2-&gt;left); &#125;&#125;; 102 Binary Tree Level Order Traversal难度：Medium1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; if (root == NULL) return&#123;&#125;; queue&lt;TreeNode*&gt; q1; q1.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (q1.size() &gt; 0) &#123; int n = q1.size(); vector&lt;int&gt; tem; for (int i = 0; i &lt; n; i++) &#123; tem.push_back(q1.front()-&gt;val); if (q1.front()-&gt;left) q1.push(q1.front()-&gt;left); if (q1.front()-&gt;right) q1.push(q1.front()-&gt;right); q1.pop(); &#125; result.push_back(tem); &#125; return result; &#125;&#125;; 103 Bianry Tree Zigzag Level Order Traversal难度：Medium123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; if (root == NULL) return&#123;&#125;; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;TreeNode*&gt; q1; bool order = true; q1.push_back(root); while (q1.size() &gt; 0) &#123; vector&lt;TreeNode*&gt; q2; for (int i = 0; i &lt; q1.size(); i++) &#123; if (q1[i]-&gt;left) q2.push_back(q1[i]-&gt;left); if (q1[i]-&gt;right) q2.push_back(q1[i]-&gt;right); &#125; vector&lt;int&gt; tem; if (order) &#123; for (int i = 0; i &lt; q1.size(); i++) &#123; tem.push_back(q1[i]-&gt;val); &#125; &#125; else &#123; for (int i = q1.size() - 1; i &gt;= 0; i--) &#123; tem.push_back(q1[i]-&gt;val); &#125; &#125; order = !order; result.push_back(tem); q1 = q2; &#125; return result; &#125;&#125;; 104 Maximum Depth of Binary Tree难度：Easy1234567891011121314151617181920class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (root == NULL) return 0; mid(root, 1); return md; &#125;private: int md = 1; void mid(TreeNode* node, int height) &#123; if (node == NULL) return; if (height &gt; md) md = height; mid(node-&gt;left, height + 1); mid(node-&gt;right, height + 1); &#125;&#125;; 105 Construct Binary Tree from Preorder and Inorder Traversal难度：Medium1234567891011121314151617181920212223242526272829303132class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; if (preorder.size() == 0) return NULL; return getNode(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1); &#125;private: TreeNode* getNode(vector&lt;int&gt;&amp; preorder,int begin1, int end1, vector&lt;int&gt;&amp; inorder, int begin2, int end2) &#123; if (begin1 &gt; end1 || begin2 &gt; end2) return NULL; if (begin1 == end1) &#123; TreeNode* node = new TreeNode(preorder[begin1]); return node; &#125; int r = preorder[begin1]; int i; for (i = begin2; i &lt;= end2; i++) &#123; if (inorder[i] == r) break; &#125; int l = i - begin2; TreeNode* node = new TreeNode(preorder[begin1]); node-&gt;left = getNode(preorder, begin1 + 1, begin1 + l, inorder, begin2, begin2 + l - 1); node-&gt;right = getNode(preorder, begin1 + l + 1, end1, inorder, begin2 + l + 1, end2); return node; &#125;&#125;; 106 Construct Binary Tree from Inorder and Postorder Traversal难度：Medium1234567891011121314151617181920212223242526272829class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; if (inorder.size() == 0) return NULL; return getNode(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1); &#125;private: TreeNode* getNode(vector&lt;int&gt;&amp; inorder, int begin1, int end1, vector&lt;int&gt;&amp; postorder, int begin2, int end2) &#123; if (begin1 &gt; end1 || begin2 &gt; end2) return NULL; if (begin1 == end1) &#123; TreeNode* node = new TreeNode(inorder[begin1]); return node; &#125; int r = postorder[end2]; int l = 0; for (int i = begin1; i &lt;= end1; i++) &#123; if (inorder[i] == r) &#123; l = i - begin1; break; &#125; &#125; TreeNode* node = new TreeNode(postorder[end2]); node-&gt;left = getNode(inorder, begin1, begin1 + l - 1, postorder, begin2, begin2 + l - 1); node-&gt;right = getNode(inorder, begin1 + l + 1, end1, postorder, begin2 + l, end2 - 1); return node; &#125;&#125;; 107 Binary Tree Level Order Traversal II难度：Easy1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; if (root == NULL) return&#123;&#125;; vector&lt;vector&lt;int&gt;&gt; result; pre(result, 1, root); reverse(result.begin(), result.end()); return result; &#125;private: void pre(vector&lt;vector&lt;int&gt;&gt;&amp; result, int height, TreeNode* node) &#123; if (node == NULL) return; if (result.size() &lt; height) &#123; result.push_back(&#123; node-&gt;val &#125;); &#125; else &#123; result[height - 1].push_back(node-&gt;val); &#125; pre(result, height + 1, node-&gt;left); pre(result, height + 1, node-&gt;right); &#125;&#125;; 108 Convert Sorted Array to Binary Search Tree难度：Easy1234567891011121314151617181920212223class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return NULL; return getNode(nums, 0, nums.size() - 1); &#125;private: TreeNode* getNode(vector&lt;int&gt;&amp; nums, int begin, int end) &#123; if (begin &gt; end) return NULL; if (begin == end) &#123; TreeNode* node = new TreeNode(nums[begin]); return node; &#125; int l = (end - begin + 1) / 2; TreeNode* node = new TreeNode(nums[begin + l]); node-&gt;left = getNode(nums, begin, begin + l - 1); node-&gt;right = getNode(nums, begin + l + 1, end); return node; &#125;&#125;; 109 Convert Sorted List to Binary Search Tree难度：Medium12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: TreeNode* sortedListToBST(ListNode* head) &#123; if (head == NULL) return NULL; ListNode* p = head; while (p-&gt;next) p = p-&gt;next; return getNode(head, p); &#125;private: TreeNode* getNode(ListNode* begin, ListNode* end) &#123; if (!begin || end-&gt;val &lt; begin-&gt;val) return NULL; if (begin-&gt;val == end-&gt;val) &#123; TreeNode* node = new TreeNode(begin-&gt;val); return node; &#125; ListNode* mid = begin, *omid; ListNode* p = begin; while (1) &#123; if (p == NULL || p-&gt;val &gt;= end-&gt;val) break; p = p-&gt;next-&gt;next; omid = mid; mid = mid-&gt;next; &#125; TreeNode* node = new TreeNode(mid-&gt;val); node-&gt;left = getNode(begin, omid); node-&gt;right = getNode(mid-&gt;next, end); return node; &#125;&#125;; 110 Balanced Binary Tree难度：Easy123456789101112131415161718192021222324class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; return getHeight(root) &gt;= 0; &#125;private: int getHeight(TreeNode* node) &#123; if (node == NULL) return 0; int hl = 0, hr = 0; hl = getHeight(node-&gt;left); if (hl &lt; 0) return -1; hr = getHeight(node-&gt;right); if (hr &lt; 0) return -1; if (hr - hl &gt; 1 || hl - hr &gt; 1) return -1; return max(hr, hl) + 1; &#125;&#125;; 111 Minimum Depth of Binary Tree难度：Easy12345678910111213141516171819class Solution &#123;public: int minDepth(TreeNode* root) &#123; if (root == NULL) return 0; dfs(root,1); return minh; &#125;private: int minh = INT_MAX; void dfs(TreeNode* node, int h) &#123; if (node-&gt;left) dfs(node-&gt;left,h+1); if (node-&gt;right) dfs(node-&gt;right, h + 1); if (!node-&gt;left &amp;&amp; !node-&gt;right) minh = min(h, minh); &#125;&#125;; 112 Path Sum难度：Easy123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if (root == NULL) return false; this-&gt;sum = sum; dfs(root); return exist; &#125;private: int sum; int s = 0; bool exist = false; void dfs(TreeNode* node) &#123; if (!exist) &#123; s += node-&gt;val; if (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; s == sum) exist = true; else &#123; if (node-&gt;left) dfs(node-&gt;left); if (node-&gt;right) dfs(node-&gt;right); &#125; s -= node-&gt;val; &#125; &#125;&#125;; 113 Path Sum II难度：Medium12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; if (root == NULL) return&#123;&#125;; this-&gt;sum = sum; getPath(root); return result; &#125;private: vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; result; int sum; int s = 0; void getPath(TreeNode* node) &#123; s += node-&gt;val; path.push_back(node-&gt;val); if (s == sum &amp;&amp; !node-&gt;left &amp;&amp; !node-&gt;right) result.push_back(path); if (node-&gt;left) getPath(node-&gt;left); if (node-&gt;right) getPath(node-&gt;right); s -= node-&gt;val; path.pop_back(); &#125;&#125;; 114 Flatten Bianry Tree to Linked List难度：Medium123456789101112131415161718192021222324252627282930class Solution &#123;public: void flatten(TreeNode* root) &#123; if (root) conn(root); &#125;private: TreeNode* conn(TreeNode* node) &#123; if (!node-&gt;left &amp;&amp; !node-&gt;right) return node; TreeNode *lp = node-&gt;left, *rp = node-&gt;right; if (node-&gt;left) lp = conn(node-&gt;left); if (node-&gt;right) rp = conn(node-&gt;right); if (lp) &#123; lp-&gt;right = node-&gt;right; node-&gt;right = node-&gt;left; node-&gt;left = NULL; &#125; if (rp) return rp; else return lp; &#125;&#125;; 115 Distinct Subsequences难度：Hard123456789101112131415161718192021222324class Solution &#123;public: int numDistinct(string s, string t) &#123; if (s.size() &lt; t.size()) return 0; vector&lt;vector&lt;int&gt;&gt; data(t.size() + 1, vector&lt;int&gt;(s.size() + 1, 0)); for (int i = 0; i &lt;= s.size(); i++) data[0][i] = 1; for (int n = 1; n &lt;= t.size(); n++) &#123; for (int m = n; m &lt;= s.size(); m++) &#123; if (s[m - 1] == t[n - 1]) &#123; data[n][m] = data[n][m - 1] + data[n - 1][m - 1]; //s[m]¿ÉÒÔºÍt[n]Æ¥£¬Ò²¿ÉÒÔ²»ºÍt[n]Æ¥Åä &#125; else &#123; data[n][m] = data[n][m - 1]; //ÊÇs[m]²»ºÍt[n]Æ¥Åä &#125; &#125; &#125; return data[t.size()][s.size()]; &#125;&#125;; 116 Populating Next Right Pointers in Each Node难度：Medium123456789101112131415class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (root == NULL) return; if (root-&gt;left) &#123; root-&gt;left-&gt;next = root-&gt;right; if (root-&gt;next) &#123; root-&gt;right-&gt;next = root-&gt;next-&gt;left; &#125; &#125; connect(root-&gt;left); connect(root-&gt;right); &#125;&#125;; 117 Populating Next Right Pointers in Each Node II难度：Medium1234567891011121314151617181920212223242526272829303132class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (root == NULL) return; TreeLinkNode* p = root-&gt;next, *next = NULL; while (p &amp;&amp; !p-&gt;left &amp;&amp; !p-&gt;right) p = p-&gt;next; if (p) &#123; if (p-&gt;left) next = p-&gt;left; else if (p-&gt;right) next = p-&gt;right; &#125; if (root-&gt;left &amp;&amp; root-&gt;right) &#123; root-&gt;left-&gt;next = root-&gt;right; root-&gt;right-&gt;next = next; &#125; else if (root-&gt;right) &#123; root-&gt;right-&gt;next = next; &#125; else if (root-&gt;left) &#123; root-&gt;left-&gt;next = next; &#125; connect(root-&gt;right); connect(root-&gt;left); &#125;&#125;; 118 Pascal’s Triangle难度：Easy1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; if (numRows == 0) return&#123;&#125;; vector&lt;vector&lt;int&gt;&gt; result; result.push_back(&#123; 1 &#125;); if (numRows == 1) return result; result.push_back(&#123; 1,1 &#125;); for (int i = 2; i &lt; numRows; i++) &#123; vector&lt;int&gt; tem; tem.push_back(1); for (int j = 1; j &lt; result[i - 1].size(); j++) &#123; tem.push_back(result[i - 1][j - 1] + result[i - 1][j]); &#125; tem.push_back(1); result.push_back(tem); &#125; return result; &#125;&#125;; 119 Pcscal’s Triangle II难度：Easy123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;vector&lt;int&gt;&gt; result(2, vector&lt;int&gt;(1, 1)); result[1].push_back(1); bool now = false; if (rowIndex == 0) return result[now]; now = !now; if (rowIndex == 1) return result[now]; for (int i = 2; i &lt;= rowIndex; i++) &#123; result[!now] = vector&lt;int&gt;(1, 1); for (int j = 1; j &lt; result[now].size(); j++) &#123; result[!now].push_back(result[now][j - 1] + result[now][j]); &#125; result[!now].push_back(1); now = !now; &#125; return result[now]; &#125;&#125;; 120 Triangle难度：Medium123456789101112131415161718192021222324252627282930class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; int n = triangle.size(); if (n &lt;= 0) return 0; int l = triangle[n - 1].size(); vector&lt;vector&lt;int&gt;&gt; result(2, vector&lt;int&gt;(l, 0)); bool now = false; result[now] = triangle[0]; now = !now; for (int i = 1; i &lt; triangle.size(); i++) &#123; for (int j = 0; j &lt; triangle[i].size(); j++) &#123; if (j == 0) result[now][j] = result[!now][j] + triangle[i][j]; else if (j == triangle[i].size() - 1) result[now][j] = result[!now][j - 1] + triangle[i][j]; else result[now][j] = min(result[!now][j], result[!now][j - 1]) + triangle[i][j]; &#125; now = !now; &#125; int min = result[!now][0]; for (int i = 1; i &lt; result[!now].size(); i++) &#123; if (result[!now][i] &lt; min) min = result[!now][i]; &#125; return min; &#125;&#125;; 121 ~ 140 Problems121 Best Time to Buy and Sell Stock难度：Easy1234567891011121314151617181920212223class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.size() == 0) return 0; int profit = 0; int begin = 0, end = 0; while (end &lt; prices.size()) &#123; if (prices[end] &lt; prices[begin]) &#123; begin = end; &#125; else &#123; if (prices[end] - prices[begin] &gt; profit) &#123; profit = prices[end] - prices[begin]; &#125; &#125; end++; &#125; return profit; &#125;&#125;; 122 Best Time to Buy and Sell Stock II难度：Easy1234567891011121314151617181920212223242526class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.size() &lt;= 1) return 0; int profit = 0; int begin = 0, end = 1; int n = prices.size(); while (begin &lt; prices.size()) &#123; while (begin + 1 &lt; prices.size() &amp;&amp; prices[begin] &gt;= prices[begin + 1]) begin++; end = begin + 1; while (end + 1 &lt; prices.size() &amp;&amp; prices[end + 1] &gt;= prices[end]) end++; if (end &lt; prices.size() &amp;&amp; begin &lt; prices.size()) profit += prices[end] - prices[begin]; begin = end + 1; &#125; return profit; &#125;&#125;; 123 Best Time to Buy and Sell Stock III难度：Hard12345678910111213141516171819202122class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int buy1 = INT_MIN, sell1 = 0; int buy2 = INT_MIN, sell2 = 0; for (int price : prices) &#123; // µÚÒ»´Î¹ºÂò if (buy1 &lt; -price) buy1 = -price; // µÚÒ»´ÎÂô³öÈ¥µÄ¿ÉÄÜµÄ×î´óÀûÈó if (sell1 &lt; buy1 + price) sell1 = buy1 + price; //×¢ÒâµÚ¶þ´ÎµÄÀûÈóÒÑ¾­°üº¬µÚÒ»´ÎµÄÁË //Í¬Àí£¬µÚ¶þ´Î¹ºÂò,×¢ÒâÕâÀïÊÇ if (buy2 &lt; sell1 - price) buy2 = sell1 - price; //×îºóÒ»´Î if (sell2 &lt; buy2 + price) sell2 = buy2 + price; &#125; return sell2; &#125;&#125;; 124 Binary Tree Maximum Path Sum难度：Hard123456789101112131415161718192021222324252627class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; if (root == NULL) return 0; maxOnePath(root); return maxSum; &#125;private: int maxSum = INT_MIN; int maxOnePath(TreeNode* node) &#123; if (node == NULL) return 0; int n1 = maxOnePath(node-&gt;left); int n2 = maxOnePath(node-&gt;right); int x = 0; if (n1 &gt; 0) x += n1; if (n2 &gt; 0) x += n2; x += node-&gt;val; if (x &gt; maxSum) maxSum = x; if (n1 &lt;= 0 &amp;&amp; n2 &lt;= 0) return node-&gt;val; else return max(n1, n2) + node-&gt;val; &#125;&#125;; 125 Valid Palindrome难度：Easy1234567891011121314151617181920212223242526272829303132class Solution &#123;public: bool isPalindrome(string s) &#123; if (s.size() == 0) return true; int begin = 0, end = s.size() - 1; while (begin &lt; end) &#123; int c1, c2; while (begin &lt; end &amp;&amp; (c1 = getLow(s[begin])) &lt; 0) &#123; begin++; &#125; while (begin &lt; end &amp;&amp; (c2 = getLow(s[end])) &lt; 0) &#123; end--; &#125; if (c1 != c2 &amp;&amp; begin &lt; end) return false; begin++; end--; &#125; return true; &#125;private: int getLow(char c) &#123; if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') return c; else if (c &gt;= '0' &amp;&amp; c &lt;= '9') return c; else if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') return c + 32; else return -1; &#125;&#125;; 127 Word Ladder难度：Medium1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123;public: int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; if (wordList.size() == 0) return 0; int endnum = -1; for (int i = 0; i &lt; wordList.size(); i++) &#123; if (wordList[i] == endWord) &#123; endnum = i; break; &#125; &#125; if (endnum &lt; 0) return 0; int n = wordList.size(); vector&lt;vector&lt;bool&gt;&gt; trans(n, vector&lt;bool&gt;(n, 0)); vector&lt;bool&gt; already(n, 1); for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (couldTrans(wordList[i], wordList[j])) &#123; trans[i][j] = trans[j][i] = 1; &#125; &#125; &#125; int length = 2; set&lt;int&gt; find; for (int i = 0; i &lt; n; i++) &#123; if (couldTrans(beginWord, wordList[i])) &#123; if (i == endnum) return length; if (already[i]) &#123; find.insert(i); already[i] = false; &#125; &#125; &#125; while (find.size() &gt; 0) &#123; set&lt;int&gt; tem; length++; for (auto p = find.begin(); p != find.end(); p++) &#123; for (int i = 0; i &lt; n; i++) &#123; if (trans[*p][i]) &#123; if (already[i]) &#123; tem.insert(i); already[i] = false; if (i == endnum) return length; &#125; &#125; &#125; &#125; find = tem; &#125; return 0; &#125;private: bool couldTrans(string&amp; s1, string&amp; s2) &#123; if (s1.size() != s2.size()) return false; int n = s1.size(); int num = 0; for (int i = 0; i &lt; n; i++) &#123; if (s1[i] != s2[i]) &#123; num++; if (num &gt; 1) return false; &#125; &#125; return true; &#125;&#125;; 128 Longest Consecutive Sequence难度：Hard123456789101112131415161718192021222324class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 0; unordered_set&lt;int&gt; data(nums.begin(), nums.end()); int length = 1; for (int num : nums) &#123; if (data.find(num) == data.end()) continue; data.erase(num); int begin = num - 1, end = num + 1; while (data.find(begin) != data.end()) data.erase(begin--); while (data.find(end) != data.end()) data.erase(end++); length = max(length, end - begin - 1); &#125; return length; &#125;&#125;; 129 Sum Root to Leaf Numbers难度：Medium1234567891011121314151617181920212223class Solution &#123;public: int sum = 0; int sumNumbers(TreeNode* root) &#123; deepSearch(root,0); return sum; &#125; void deepSearch(TreeNode* node,int num) &#123; num = num * 10 + node-&gt;val; if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; sum += num; return; &#125; else &#123; if (node-&gt;left) deepSearch(node-&gt;left, num); if (node-&gt;right) deepSearch(node-&gt;right, num); &#125; &#125;&#125;; 130 Surrounded Regions难度：Medium12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if (board.size() == 0) return; for (int k = 0; k &lt; board[0].size(); k++) &#123; breadthSearch(0, k, board); &#125; for (int k = 0; k &lt; board[0].size(); k++) &#123; breadthSearch(board.size() - 1, k, board); &#125; for (int k = 0; k &lt; board.size(); k++) &#123; breadthSearch(k, 0, board); &#125; for (int k = 0; k &lt; board.size(); k++) &#123; breadthSearch(k, board[0].size() - 1, board); &#125; for (int i = 0; i &lt; board.size(); i++) &#123; for (int j = 0; j &lt; board[0].size(); j++) &#123; if (board[i][j] == 'Z') board[i][j] = 'O'; else board[i][j] = 'X'; &#125; &#125; &#125; void breadthSearch(int i, int j, vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if (board[i][j] == 'X' || board[i][j] == 'Z') return; board[i][j] = 'Z'; if (j &gt; 1) &#123; breadthSearch(i, j - 1, board); &#125; if (j &lt; board[0].size() - 1) &#123; breadthSearch(i, j + 1, board); &#125; if (i &gt; 1) &#123; breadthSearch(i - 1, j, board); &#125; if (i &lt; board.size() - 1) &#123; breadthSearch(i + 1, j, board); &#125; &#125;&#125;; 131 Palindrome Partitioning难度：Medium123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; if (s.size() == 0) return&#123;&#125;; check = vector&lt;vector&lt;bool&gt;&gt;(s.size(), vector&lt;bool&gt;(s.size(), 0)); for (int i = 0; i &lt; s.size(); i++) check[i][i] = true; for (int i = 0; i &lt; s.size() - 1; i++) check[i][i + 1] = s[i] == s[i + 1]; for (int l = 2; l &lt; s.size(); l++) &#123; for (int i = 0; i + l &lt; s.size(); i++) &#123; check[i][i + l] = check[i + 1][i + l - 1] &amp;&amp; (s[i] == s[i + l]); &#125; &#125; vector&lt;string&gt; tem; getResult(s, 0, tem); return result; &#125;private: vector&lt;vector&lt;bool&gt;&gt; check; vector&lt;vector&lt;string&gt;&gt; result; void getResult(string&amp; s, int begin, vector&lt;string&gt;&amp; tem) &#123; if (begin &gt;= s.size()) &#123; result.push_back(tem); return; &#125; for (int i = begin; i &lt; s.size(); i++) &#123; if (check[begin][i]) &#123; string str = s.substr(begin, i - begin + 1); tem.push_back(str); getResult(s, i + 1, tem); tem.pop_back(); &#125; &#125; &#125;&#125;; 132 Plaindrome Partitioning II难度：Hard1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int minCut(string s) &#123; if (s.size() == 0) return 0; check = vector&lt;vector&lt;bool&gt;&gt;(s.size(), vector&lt;bool&gt;(s.size(), 0)); for (int i = 0; i &lt; s.size(); i++) check[i][i] = true; for (int i = 0; i &lt; s.size() - 1; i++) check[i][i + 1] = s[i] == s[i + 1]; for (int l = 2; l &lt; s.size(); l++) &#123; for (int i = 0; i + l &lt; s.size(); i++) &#123; check[i][i + l] = check[i + 1][i + l - 1] &amp;&amp; (s[i] == s[i + l]); &#125; &#125; vector&lt;int&gt; cut(s.size(), 0); for (int i = 0; i &lt; s.size(); i++) &#123; if (check[0][i]) cut[i] = 0; else &#123; int m = INT_MAX; for (int j = 1; j &lt;= i; j++) &#123; if (check[j][i] &amp;&amp; m &gt; cut[j - 1] + 1) &#123; m = cut[j - 1] + 1; &#125; &#125; cut[i] = m; &#125; &#125; return cut[s.size() - 1]; &#125;private: vector&lt;vector&lt;bool&gt;&gt; check;&#125;; 133 Clone Graph难度：Medium1234567891011121314class Solution &#123;public: UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) &#123; if (!node) return NULL; if (mp.find(node) == mp.end()) &#123; mp[node] = new UndirectedGraphNode(node-&gt;label); for (UndirectedGraphNode* neigh : node-&gt;neighbors) mp[node]-&gt;neighbors.push_back(cloneGraph(neigh)); &#125; return mp[node]; &#125;private: unordered_map&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; mp;&#125;; 134 Gas Station难度：Medium12345678910111213141516171819202122232425262728class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; if (gas.size() == 0) return -1; if (gas.size() == 1) return gas[0] &gt;= cost[0] ? 0 : -1; int begin = 0, end = 0; int total = 0; total += gas[end] - cost[end]; end = end == gas.size() - 1 ? 0 : end + 1; while (begin != end) &#123; while (total &gt;= 0 &amp;&amp; begin != end) &#123; total += gas[end] - cost[end]; end = end == gas.size() - 1 ? 0 : end + 1; &#125; while (total &lt; 0 &amp;&amp; begin != end) &#123; begin = begin == 0 ? gas.size() - 1 : begin - 1; total += gas[begin] - cost[begin]; &#125; &#125; if (total &gt;= 0) return begin; else return -1; &#125;&#125;; 135 Candy难度：Hard123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int result = 0; if (ratings.size() == 0) return result; int begin = 0, end = 0; int now = 1, i = 0, high = 1; while (i &lt; ratings.size()) &#123; result += now; if (i + 1 &lt; ratings.size() &amp;&amp; ratings[i + 1] &gt; ratings[i]) &#123; begin = i + 1; end = begin; now += 1; high = now; &#125; else if (i + 1 &lt; ratings.size() &amp;&amp; ratings[i + 1] &lt; ratings[i]) &#123; now = 1; result += end - begin; if (now + end - begin &gt;= high) &#123; high += 1; result += 1; &#125; end = i + 1; &#125; else if (i + 1 &lt; ratings.size() &amp;&amp; ratings[i + 1] == ratings[i]) &#123; now = 1; begin = i + 1; end = begin; high = 1; &#125; i++; &#125; return result; &#125;&#125;; 136 Single Number难度：Easy12345678910class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int result = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; result ^= nums[i]; &#125; return result; &#125;&#125;; 137 Single Number II难度：Medium1234567891011121314151617class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int result = 0; for (int i = 0; i &lt; 32; i++) &#123; int tem = 1 &lt;&lt; i; int num = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] &amp; tem) num++; &#125; if (num % 3) result |= tem; &#125; return result; &#125;&#125;; 138 Copy List With Random Pointer难度：Medium123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; if (!head) return NULL; RandomListNode *node = head; while (node) &#123; RandomListNode *new_node = new RandomListNode(node-&gt;label); new_node-&gt;next = node-&gt;next; node-&gt;next = new_node; node = new_node-&gt;next; &#125; node = head; while (node) &#123; RandomListNode* new_node = node-&gt;next; new_node-&gt;random = node-&gt;random == NULL ? NULL : node-&gt;random-&gt;next; node = new_node-&gt;next; &#125; node = head; RandomListNode *new_head = node-&gt;next; RandomListNode* new_node = node-&gt;next; while (node) &#123; RandomListNode* next_node = new_node-&gt;next; node-&gt;next = next_node; new_node-&gt;next = next_node ? next_node-&gt;next : NULL; node = next_node; new_node = next_node ? next_node-&gt;next : NULL; &#125; return new_head; &#125;&#125;; 139 Word Break难度：Medium1234567891011121314151617181920class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; if (wordDict.size() &lt;= 0) return false; unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); vector&lt;bool&gt; check(s.size() + 1, false); check[0] = true; for (int i = 1; i &lt;= s.size(); i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (check[j] &amp;&amp; wordSet.find(s.substr(j, i - j)) != wordSet.end()) &#123; check[i] = true; break; &#125; &#125; &#125; return check[s.size()]; &#125;&#125;; 140 Word Break II难度：Hard123456789101112131415161718192021222324252627282930class Solution &#123; unordered_map&lt;string, vector&lt;string&gt;&gt; m; vector&lt;string&gt; combine(string word, vector&lt;string&gt; prev) &#123; for (int i = 0; i&lt;prev.size(); ++i) &#123; prev[i] += \" \" + word; &#125; return prev; &#125;public: vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; dict(wordDict.begin(), wordDict.end()); if (m.count(s)) return m[s]; //take from memory vector&lt;string&gt; result; if (dict.count(s)) &#123; //a whole string is a word result.push_back(s); &#125; for (int i = 1; i&lt;s.size(); ++i) &#123; string word = s.substr(i); if (dict.count(word)) &#123; string rem = s.substr(0, i); vector&lt;string&gt; prev = combine(word, wordBreak(rem, wordDict)); result.insert(result.end(), prev.begin(), prev.end()); &#125; &#125; m[s] = result; //memorize return result; &#125;&#125;; 141 ~ 160 Problems141 Linked List Cycle难度：Easy12345678910111213141516171819class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if (!head || !head-&gt;next || !head-&gt;next-&gt;next) return false; ListNode *p1 = head, *p2 = head; p1 = head-&gt;next; p2 = p1-&gt;next; while (p1 != p2) &#123; if (!p2 || !p2-&gt;next) return false; p2 = p2-&gt;next-&gt;next; p1 = p1-&gt;next; &#125; return true; &#125;&#125;; 142 Linked List Cycle II难度：Medium12345678910111213141516171819202122class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (!head || !head-&gt;next || !head-&gt;next-&gt;next) return NULL; ListNode* p1 = head-&gt;next, *p2 = head-&gt;next-&gt;next; while (p1 != p2) &#123; if (!p2 || !p2-&gt;next) return NULL; p1 = p1-&gt;next; p2 = p2-&gt;next-&gt;next; &#125; p1 = head; while (p1 != p2) &#123; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; return p1; &#125;&#125;; 143 Reorder List难度：Medium12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: void reorderList(ListNode* head) &#123; if (!head || !head-&gt;next || !head-&gt;next-&gt;next) return; ListNode *fast = head, *slow = head; while (fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next; if (!fast-&gt;next) break; fast = fast-&gt;next; &#125; ListNode* head2 = slow-&gt;next; ListNode* tail = fast; slow-&gt;next = NULL; ListNode *p1 = head2, *p2 = head2-&gt;next, *p3 = head2; while (p2) &#123; p3 = p2-&gt;next; p2-&gt;next = p1; p1 = p2; p2 = p3; &#125; head2-&gt;next = NULL; ListNode *m1 = head, *n1 = tail, *m2,*n2; while (m1 &amp;&amp; n1) &#123; m2 = m1-&gt;next; n2 = n1-&gt;next; m1-&gt;next = n1; n1-&gt;next = m2; m1 = m2; n1 = n2; &#125; &#125;&#125;; 144 Binary Tree Perorder Travelsal难度：Medium1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; if (!root) return&#123;&#125;; stack&lt;TreeNode*&gt; nodeStack; vector&lt;int&gt; result; TreeNode* node = root; while (node || nodeStack.size()) &#123; while (node) &#123; result.push_back(node-&gt;val); if (node-&gt;right) nodeStack.push(node-&gt;right); node = node-&gt;left; &#125; node = nodeStack.size() &gt; 0 ? nodeStack.top() : NULL; if (nodeStack.size() &gt; 0) nodeStack.pop(); &#125; return result; &#125;&#125;; 145 Binary Tree Postorder Travelsal难度：Medium1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; if (!root) return&#123;&#125;; stack&lt;TreeNode*&gt; *nodeStack = new stack&lt;TreeNode*&gt;(); vector&lt;int&gt; result; TreeNode* node = root; nodeStack-&gt;push(node); while (nodeStack-&gt;size() &gt; 0) &#123; if (node-&gt;right &amp;&amp; node-&gt;left) &#123; nodeStack-&gt;push(node-&gt;right); nodeStack-&gt;push(node-&gt;left); node = node-&gt;left; &#125; else if (node-&gt;left) &#123; nodeStack-&gt;push(node-&gt;left); node = node-&gt;left; &#125; else if (node-&gt;right) &#123; nodeStack-&gt;push(node-&gt;right); node = node-&gt;right; &#125; else &#123; result.push_back(node-&gt;val); if (nodeStack-&gt;size() &gt; 0) nodeStack-&gt;pop(); while (nodeStack-&gt;size() &gt; 0 &amp;&amp; (nodeStack-&gt;top()-&gt;left == node || nodeStack-&gt;top()-&gt;right == node)) &#123; result.push_back(nodeStack-&gt;top()-&gt;val); node = nodeStack-&gt;top(); nodeStack-&gt;pop(); &#125; if (nodeStack-&gt;size() &gt; 0) &#123; node = nodeStack-&gt;top(); &#125; &#125; &#125; return result; &#125;&#125;; 146 LRU Cache难度：Medium123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118class LRUCache &#123;public: Node* head; Node* tail; unordered_map&lt;int, Node*&gt; Map; int Cap; int nowCap = 0; LRUCache(int capacity) &#123; head = new Node(0,0); Cap = capacity; &#125; int get(int key) &#123; if (Map.find(key) != Map.end()) &#123; if (nowCap == 1) &#123; return Map[key]-&gt;value; &#125; Node* node = Map[key]; if (node == tail) &#123; tail = node-&gt;last; &#125; Node* first = node-&gt;last; Node* second = node-&gt;next; if (!second) &#123; first-&gt;next = NULL; &#125; else &#123; first-&gt;next = second; second-&gt;last = first; &#125; second = head-&gt;next; node-&gt;last = head; node-&gt;next = second; head-&gt;next = node; second-&gt;last = node; return Map[key]-&gt;value; &#125; else return -1; &#125; void put(int key, int value) &#123; if (Map.find(key) != Map.end()) &#123; if (nowCap == 1) &#123; Map[key]-&gt;value = value; return; &#125; Node* node = Map[key]; if (node == tail) &#123; tail = node-&gt;last; &#125; node-&gt;value = value; Node* first = node-&gt;last; Node* second = node-&gt;next; if (!second) &#123; first-&gt;next = NULL; &#125; else &#123; first-&gt;next = second; second-&gt;last = first; &#125; second = head-&gt;next; node-&gt;last = head; node-&gt;next = second; head-&gt;next = node; second-&gt;last = node; &#125; else &#123; if (nowCap &lt; Cap) &#123; nowCap++; Node* node = new Node(key, value); Node* first = head-&gt;next; head-&gt;next = node; node-&gt;last = head; if (first) &#123; node-&gt;next = first; first-&gt;last = node; &#125; if (nowCap == 1) &#123; tail = node; &#125; Map.insert(&#123; key,node &#125;); &#125; else &#123; Node* node = new Node(key, value); Node* first = head-&gt;next; head-&gt;next = node; node-&gt;last = head; if (nowCap == 1) &#123; delete tail; tail = node; return; &#125; else &#123; node-&gt;next = first; first-&gt;last = node; &#125; Map.erase(tail-&gt;key); tail = tail-&gt;last; delete tail-&gt;next; tail-&gt;next = NULL; Map.insert(&#123; key,node &#125;); &#125; &#125; &#125;&#125;; 147 Insertion Sort List难度：Medium123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if (head == NULL) return head; ListNode* title = new ListNode(0); ListNode* tail = title; ListNode* newHead = new ListNode(0); newHead-&gt;next = head; int min; ListNode* node = newHead; ListNode* minLast, *minNode; while (newHead-&gt;next) &#123; minLast = newHead; minNode = newHead-&gt;next; min = minNode-&gt;val; while (node-&gt;next) &#123; if (node-&gt;next-&gt;val &lt; min) &#123; minLast = node; minNode = node-&gt;next; min = node-&gt;next-&gt;val; &#125; node = node-&gt;next; &#125; minLast-&gt;next = minNode-&gt;next; tail-&gt;next = minNode; minNode-&gt;next = NULL; tail = tail-&gt;next; node = newHead; &#125; return title-&gt;next; &#125;&#125;;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://uyouii.github.io/categories/algorithm/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://uyouii.github.io/tags/c/"},{"name":"algorithm","slug":"algorithm","permalink":"https://uyouii.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"https://uyouii.github.io/tags/leetcode/"}]},{"title":"libevent 服务端客户端 简单实例","slug":"libevent-服务端客户端-简单实例","date":"2017-12-12T03:26:17.000Z","updated":"2018-01-30T10:19:59.575Z","comments":true,"path":"2017/12/12/libevent-服务端客户端-简单实例/","link":"","permalink":"https://uyouii.github.io/2017/12/12/libevent-服务端客户端-简单实例/","excerpt":"","text":"最近了解了下libevent，简单的实现了一个客户端服务端通信的demo，服务端会转发客户端发送的数据包给其他客户端，并测试每秒转发的数据量和数据包的个数。 包格式简单的定义了数据包头的格式，12个字节，包含三个变量，分别是targetID（目的地的id），sourceID（源id）和length（数据的长度，不包含header的长度）。 暂时client的id分配由服务器分配，客户端编号从1开始，id为0代表是服务器发送的原始消息，不是转发的其他客户端发送的数据。 数据发送客户端每隔一段时间发送一个数据包给其他客户端，服务器收到数据包后转发给其他客户端。 为了测试libevent的最大负载，现在设置只要客户端检测到write_buffer为空，则向其中填入SEND_TIMES个packet。 目前测试结果为再最大负载的情况下，多个client同时向服务器发送packet，平均结果为服务器每秒转发40000个packet 代码服务端12345678910111213141516171819202122#ifndef _MESSAGE_H_#define _MESSAGE_H_#include&lt;string&gt;using namespace std;typedef struct msg_header &#123; unsigned int targetID; unsigned int sourceID; unsigned int length;&#125; Header;void listener_cb(struct evconnlistener *, evutil_socket_t, struct sockaddr *, int socklen, void *);void conn_writecb(struct bufferevent *, void *);void conn_readcb(struct bufferevent *, void *);void conn_eventcb(struct bufferevent *, short, void *);unsigned int get_client_id(struct bufferevent*);string inttostr(int);void write_buffer(string&amp;, struct bufferevent*, Header&amp;);#endif // !_MESSAGE_H_ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;event2/bufferevent.h&gt; #include &lt;event2/buffer.h&gt; #include &lt;event2/listener.h&gt; #include &lt;event2/util.h&gt; #include &lt;event2/event.h&gt; #include &lt;vector&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include \"message.h\"using namespace std;#define PORT 1234#define HEADER_LENGTH 12#define BUFFER_SIZE (16 * 1024) #define READ_SIZE (16 * 1024)#define MAX_PACKET_SIZE 256#define TIME_INTERVAL 5000const char ip_address[] = \"127.0.0.1\";map&lt;unsigned int, bufferevent*&gt; ClientMap; //client id 对应的buffereventint conectNumber = 0;int dataSize = 0;int lastTime = 0;int receiveNumber = 0;int sendNumber = 0;int main(int argc, char **argv) &#123;#ifdef WIN32 WSAData wsaData; WSAStartup(MAKEWORD(2, 0), &amp;wsaData);#endif cout &lt;&lt; \"Server begin running!\" &lt;&lt; endl; struct sockaddr_in sin; memset(&amp;sin, 0, sizeof(sin)); sin.sin_family = AF_INET; sin.sin_addr.S_un.S_addr = inet_addr(ip_address); sin.sin_port = htons(PORT); struct evconnlistener *listener; struct event_base *base = event_base_new(); if (!base) &#123; cout &lt;&lt; \"Could not initialize libevent\" &lt;&lt; endl;; return 1; &#125; //默认情况下，链接监听器接收新套接字后，会将其设置为非阻塞的 listener = evconnlistener_new_bind(base, listener_cb, (void *)base, LEV_OPT_REUSEABLE | LEV_OPT_CLOSE_ON_FREE, -1, (struct sockaddr*)&amp;sin, sizeof(sin)); if (!listener) &#123; cout &lt;&lt; \"Could not create a listener\" &lt;&lt; endl; return 1; &#125; event_base_dispatch(base); evconnlistener_free(listener); event_base_free(base); return 0;&#125;void listener_cb(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *sa, int socklen, void *user_data) &#123; cout &lt;&lt; \"Detect an connection\" &lt;&lt; endl; struct event_base *base = (struct event_base *)user_data; struct bufferevent *bev; //BEV_OPT_CLOSE_ON_FREE close the file descriptor when this bufferevent is freed bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); if (!bev) &#123; cout &lt;&lt; \"Could not create a bufferevent\" &lt;&lt; endl; event_base_loopbreak(base); return; &#125; ClientMap[++conectNumber] = bev; //read write event bufferevent_setcb(bev, conn_readcb, NULL, conn_eventcb, NULL); bufferevent_enable(bev, EV_READ | EV_WRITE); //send a message to client when connect is succeeded string msg = \"connedted\"; Header header; header.sourceID = 0; header.targetID = conectNumber; header.length = msg.size(); write_buffer(msg, bev, header);&#125;void conn_writecb(struct bufferevent *bev, void *user_data) &#123; Sleep(2000); int len = 0; Header header; unsigned int toID = get_client_id(bev); string msg = \"hello client \" + inttostr(toID); header.targetID = toID; header.sourceID = 0; header.length = msg.size(); write_buffer(msg, bev, header);&#125;void conn_readcb(struct bufferevent *bev, void *user_data) &#123; struct evbuffer *input = bufferevent_get_input(bev); size_t sz = evbuffer_get_length(input); unsigned int sourceID = get_client_id(bev); while (sz &gt;= MAX_PACKET_SIZE) &#123; char msg[MAX_PACKET_SIZE] = &#123; 0 &#125;; char *ptr = msg; bufferevent_read(bev, ptr, HEADER_LENGTH); unsigned int len = ((Header*)ptr)-&gt;length; unsigned int targetID = ((Header*)ptr)-&gt;targetID; ((Header*)ptr)-&gt;sourceID = sourceID; ptr += HEADER_LENGTH; if (sz &lt; len + HEADER_LENGTH) &#123; break; &#125; bufferevent_read(bev, ptr, len); receiveNumber++; dataSize += len + HEADER_LENGTH; if (ClientMap.find(targetID) != ClientMap.end()) &#123; sendNumber++; bufferevent_write(ClientMap[targetID], msg, len + HEADER_LENGTH); &#125; else &#123; //can't find &#125; sz = evbuffer_get_length(input); &#125; //calculate the speed of data and packet clock_t nowtime = clock(); if (lastTime == 0) &#123; lastTime = nowtime; &#125; else &#123; cout &lt;&lt; \"client number: \" &lt;&lt; ClientMap.size() &lt;&lt; \" \"; cout &lt;&lt; \"data speed: \" &lt;&lt; (double)dataSize / (nowtime - lastTime) &lt;&lt; \"k/s \"; cout &lt;&lt; \"packet speed: receive \" &lt;&lt; (double)receiveNumber / (nowtime - lastTime) &lt;&lt; \"k/s \"; cout &lt;&lt; \"send \" &lt;&lt; (double)sendNumber / (nowtime - lastTime) &lt;&lt; \"k/s\" &lt;&lt; endl; if (nowtime - lastTime &gt; TIME_INTERVAL) &#123; dataSize = 0; lastTime = nowtime; receiveNumber = 0; sendNumber = 0; &#125; &#125;&#125;void conn_eventcb(struct bufferevent *bev, short events, void *user_data) &#123; if (events &amp; BEV_EVENT_EOF) &#123; cout &lt;&lt; \"Connection closed\" &lt;&lt; endl; &#125; else if (events &amp; BEV_EVENT_ERROR) &#123; cout &lt;&lt; \"Got an error on the connection: \" &lt;&lt; strerror(errno) &lt;&lt; endl; &#125; bufferevent_free(bev);&#125;unsigned int get_client_id(struct bufferevent* bev) &#123; for (auto p = ClientMap.begin(); p != ClientMap.end(); p++) &#123; if (p-&gt;second == bev) &#123; return p-&gt;first; &#125; &#125; return 0;&#125;void write_buffer(string&amp; msg, struct bufferevent* bev, Header&amp; header) &#123; char send_msg[BUFFER_SIZE] = &#123; 0 &#125;; char* ptr = send_msg; int len = 0; memcpy(ptr, &amp;header, sizeof(Header)); len += sizeof(Header); ptr += sizeof(Header); memcpy(ptr, msg.c_str(), msg.size()); len += msg.size(); bufferevent_write(bev, send_msg, len);&#125;string inttostr(int num) &#123; string result; bool neg = false; if (num &lt; 0) &#123; neg = true; num = -num; &#125; if (num == 0) &#123; result += '0'; &#125; else &#123; while (num &gt; 0) &#123; int rem = num % 10; result = (char)(rem + '0') + result; num /= 10; &#125; &#125; if (neg) &#123; result = '-' + result; &#125; return result;&#125; 客户端1234567891011121314151617181920#ifndef _MESSAGE_H_#define _MESSAGE_H_#include&lt;string&gt;using namespace std;typedef struct msg_header &#123; unsigned int targetID; unsigned int sourceID; unsigned int length;&#125; Header;void conn_writecb(struct bufferevent *, void *);void conn_readcb(struct bufferevent *, void *);void conn_eventcb(struct bufferevent *, short, void *);string inttostr(int);void write_buffer(string&amp;, struct bufferevent*, Header&amp;);#endif // !_MESSAGE_H_ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;event2/bufferevent.h&gt; #include &lt;event2/buffer.h&gt; #include &lt;event2/listener.h&gt; #include &lt;event2/util.h&gt; #include &lt;event2/event.h&gt; #include &lt;iostream&gt;#include &lt;string&gt;#include \"message.h\"using namespace std;#define PORT 1234#define BUFFER_SIZE (16 * 1024) #define READ_SIZE (16 * 1024)#define SEND_INTERVAL 0#define CLIENT_NUMBER 2#define SEND_TIMES 10#define MAX_PACKET_SIZE 1024#define HEADER_LENGTH 12#define DATA_LENGTH 1000const char ip_address[] = \"127.0.0.1\";int main() &#123; cout &lt;&lt; \"Client running\" &lt;&lt; endl;#ifdef WIN32 WSAData wsaData; WSAStartup(MAKEWORD(2, 0), &amp;wsaData);#endif struct sockaddr_in srv; memset(&amp;srv, 0, sizeof(srv)); srv.sin_addr.S_un.S_addr = inet_addr(ip_address); srv.sin_family = AF_INET; srv.sin_port = htons(PORT); struct event_base *base = event_base_new(); if (!base) &#123; cout &lt;&lt; \"Could not initialize libevent\" &lt;&lt; endl; return 1; &#125; struct bufferevent* bev = bufferevent_socket_new(base, -1,BEV_OPT_CLOSE_ON_FREE); bufferevent_setcb(bev, conn_readcb, conn_writecb, conn_eventcb, NULL); //连接，成功返回0，失败返回-1 int flag = bufferevent_socket_connect(bev, (struct sockaddr *)&amp;srv, sizeof(srv)); bufferevent_enable(bev, EV_READ | EV_WRITE); if (-1 == flag) &#123; cout &lt;&lt; \"Connect failed\" &lt;&lt; endl; return 1; &#125; event_base_dispatch(base); event_base_free(base); return 0;&#125;void conn_writecb(struct bufferevent *bev, void *user_data) &#123; //Sleep(SEND_INTERVAL); int len = 0; static int num[10] = &#123; 0 &#125;; unsigned int toID = rand() % CLIENT_NUMBER + 1; Header header; string msg(DATA_LENGTH - HEADER_LENGTH, '0'); header.targetID = toID; header.length = msg.size(); write_buffer(msg, bev, header);&#125;void write_buffer(string&amp; msg, struct bufferevent* bev, Header&amp; header) &#123; char send_msg[READ_SIZE] = &#123; 0 &#125;; char* ptr = send_msg; int len = 0; //多发几次，便于测试大量数据 for (int i = 0; i &lt; SEND_TIMES; i++) &#123; memcpy(ptr + len, &amp;header, sizeof(Header)); len += sizeof(Header); memcpy(ptr + len, msg.c_str(), msg.size()); len += msg.size(); &#125; bufferevent_write(bev, send_msg, len);&#125;void conn_readcb(struct bufferevent *bev, void *user_data) &#123; struct evbuffer *input = bufferevent_get_input(bev); size_t sz = evbuffer_get_length(input); //返回evbuffer储存的字节数 while (sz &gt;= MAX_PACKET_SIZE) &#123; char msg[MAX_PACKET_SIZE] = &#123; 0 &#125;; char *ptr = msg; bufferevent_read(bev, ptr, HEADER_LENGTH); unsigned int len = ((Header*)ptr)-&gt;length; unsigned int targetID = ((Header*)ptr)-&gt;targetID; unsigned int sourceID = ((Header*)ptr)-&gt;sourceID; ptr += HEADER_LENGTH; if (sz &lt; len + HEADER_LENGTH) &#123; break; &#125; bufferevent_read(bev, ptr, len); cout &lt;&lt; \"receive \" &lt;&lt; HEADER_LENGTH + strlen(ptr) &lt;&lt; \" bytes from client \" &lt;&lt; sourceID &lt;&lt; endl; sz = evbuffer_get_length(input); &#125;&#125;void conn_eventcb(struct bufferevent *bev, short events, void *user_data)&#123; if (events &amp; BEV_EVENT_EOF) &#123; cout &lt;&lt; \"Connection closed\" &lt;&lt; endl; &#125; else if (events &amp; BEV_EVENT_ERROR) &#123; cout &lt;&lt; \"Got an error on the connection: \" &lt;&lt; strerror(errno) &lt;&lt; endl; &#125; else if (events &amp; BEV_EVENT_CONNECTED) &#123; cout &lt;&lt; \"Connect succeed\" &lt;&lt; endl; string msg = \"connect to server\"; Header header; header.targetID = 0; header.length = msg.size(); write_buffer(msg, bev, header); return; &#125; bufferevent_free(bev);&#125;string inttostr(int num) &#123; string result; bool neg = false; if (num &lt; 0) &#123; neg = true; num = -num; &#125; if (num == 0) &#123; result += '0'; &#125; else &#123; while (num &gt; 0) &#123; int rem = num % 10; result = (char)(rem + '0') + result; num /= 10; &#125; &#125; if (neg) &#123; result = '-' + result; &#125; return result;&#125; 效果图片普通测试 服务器测试转发速度 客户端 client1： client2： 最大负载测试 服务器数据 测试统计libevent 测试结果，本地回环地址测试 接收的client个数 2，发送的client个数 4 packet speed代表每秒服务器转发的packet的个数 packet length packet speed data speed 20 bytes 66 k/s 1333 k/s 50 bytes 36.5 k/s 1800 k/s 100 bytes 20.0 k/s 2000 k/s 200 bytes 11.2 k/s 2200 k/s 300 bytes 8.3 k/s 2490 k/s 500 bytes 5.4 k/s 2700 k/s 800 bytes 3.45 k/s 2750 k/s 1000 bytes 2.65 k/s 2650 k/s","categories":[{"name":"network","slug":"network","permalink":"https://uyouii.github.io/categories/network/"}],"tags":[{"name":"network","slug":"network","permalink":"https://uyouii.github.io/tags/network/"},{"name":"libevent","slug":"libevent","permalink":"https://uyouii.github.io/tags/libevent/"},{"name":"c++","slug":"c","permalink":"https://uyouii.github.io/tags/c/"}]}]}