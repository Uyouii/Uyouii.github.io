{"meta":{"title":"Uyouii's Blogs","subtitle":"There are many things need to learn.","description":null,"author":"Uyouii","url":"https://uyouii.github.io"},"pages":[{"title":"categories","date":"2017-12-12T05:04:45.000Z","updated":"2017-12-12T05:05:11.952Z","comments":true,"path":"categories/index.html","permalink":"https://uyouii.github.io/categories/index.html","excerpt":"","text":""},{"title":"All Tags","date":"2017-12-12T05:01:04.000Z","updated":"2017-12-12T05:02:08.532Z","comments":true,"path":"tags/index.html","permalink":"https://uyouii.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"libevent 服务端客户端 简单实例","slug":"libevent-服务端客户端-简单实例","date":"2017-12-12T03:26:17.000Z","updated":"2017-12-15T08:33:10.527Z","comments":true,"path":"2017/12/12/libevent-服务端客户端-简单实例/","link":"","permalink":"https://uyouii.github.io/2017/12/12/libevent-服务端客户端-简单实例/","excerpt":"","text":"最近了解了下libevent，简单的实现了一个客户端服务端通信的demo，服务端会转发客户端发送的数据包给其他客户端，并测试每秒转发的数据量和数据包的个数。 包格式简单的定义了数据包头的格式，12个字节，包含三个变量，分别是targetID（目的地的id），sourceID（源id）和length（数据的长度，不包含header的长度）。 暂时client的id分配由服务器分配，客户端编号从1开始，id为0代表是服务器发送的原始消息，不是转发的其他客户端发送的数据。 数据发送客户端每隔一段时间发送一个数据包给其他客户端，服务器收到数据包后转发给其他客户端。 为了测试libevent的最大负载，现在设置只要客户端检测到write_buffer为空，则向其中填入SEND_TIMES个packet。 目前测试结果为再最大负载的情况下，多个client同时向服务器发送packet，平均结果为服务器每秒转发40000个packet 代码服务端12345678910111213141516171819202122#ifndef _MESSAGE_H_#define _MESSAGE_H_#include&lt;string&gt;using namespace std;typedef struct msg_header &#123; unsigned int targetID; unsigned int sourceID; unsigned int length;&#125; Header;void listener_cb(struct evconnlistener *, evutil_socket_t, struct sockaddr *, int socklen, void *);void conn_writecb(struct bufferevent *, void *);void conn_readcb(struct bufferevent *, void *);void conn_eventcb(struct bufferevent *, short, void *);unsigned int get_client_id(struct bufferevent*);string inttostr(int);void write_buffer(string&amp;, struct bufferevent*, Header&amp;);#endif // !_MESSAGE_H_ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;event2/bufferevent.h&gt; #include &lt;event2/buffer.h&gt; #include &lt;event2/listener.h&gt; #include &lt;event2/util.h&gt; #include &lt;event2/event.h&gt; #include &lt;vector&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include \"message.h\"using namespace std;#define PORT 1234#define HEADER_LENGTH 12#define BUFFER_SIZE (16 * 1024) #define READ_SIZE (16 * 1024)#define MAX_PACKET_SIZE 256#define TIME_INTERVAL 5000const char ip_address[] = \"127.0.0.1\";map&lt;unsigned int, bufferevent*&gt; ClientMap; //client id 对应的buffereventint conectNumber = 0;int dataSize = 0;int lastTime = 0;int receiveNumber = 0;int sendNumber = 0;int main(int argc, char **argv) &#123;#ifdef WIN32 WSAData wsaData; WSAStartup(MAKEWORD(2, 0), &amp;wsaData);#endif cout &lt;&lt; \"Server begin running!\" &lt;&lt; endl; struct sockaddr_in sin; memset(&amp;sin, 0, sizeof(sin)); sin.sin_family = AF_INET; sin.sin_addr.S_un.S_addr = inet_addr(ip_address); sin.sin_port = htons(PORT); struct evconnlistener *listener; struct event_base *base = event_base_new(); if (!base) &#123; cout &lt;&lt; \"Could not initialize libevent\" &lt;&lt; endl;; return 1; &#125; //默认情况下，链接监听器接收新套接字后，会将其设置为非阻塞的 listener = evconnlistener_new_bind(base, listener_cb, (void *)base, LEV_OPT_REUSEABLE | LEV_OPT_CLOSE_ON_FREE, -1, (struct sockaddr*)&amp;sin, sizeof(sin)); if (!listener) &#123; cout &lt;&lt; \"Could not create a listener\" &lt;&lt; endl; return 1; &#125; event_base_dispatch(base); evconnlistener_free(listener); event_base_free(base); return 0;&#125;void listener_cb(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *sa, int socklen, void *user_data) &#123; cout &lt;&lt; \"Detect an connection\" &lt;&lt; endl; struct event_base *base = (struct event_base *)user_data; struct bufferevent *bev; //BEV_OPT_CLOSE_ON_FREE close the file descriptor when this bufferevent is freed bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); if (!bev) &#123; cout &lt;&lt; \"Could not create a bufferevent\" &lt;&lt; endl; event_base_loopbreak(base); return; &#125; ClientMap[++conectNumber] = bev; //read write event bufferevent_setcb(bev, conn_readcb, NULL, conn_eventcb, NULL); bufferevent_enable(bev, EV_READ | EV_WRITE); //send a message to client when connect is succeeded string msg = \"connedted\"; Header header; header.sourceID = 0; header.targetID = conectNumber; header.length = msg.size(); write_buffer(msg, bev, header);&#125;void conn_writecb(struct bufferevent *bev, void *user_data) &#123; Sleep(2000); int len = 0; Header header; unsigned int toID = get_client_id(bev); string msg = \"hello client \" + inttostr(toID); header.targetID = toID; header.sourceID = 0; header.length = msg.size(); write_buffer(msg, bev, header);&#125;void conn_readcb(struct bufferevent *bev, void *user_data) &#123; struct evbuffer *input = bufferevent_get_input(bev); size_t sz = evbuffer_get_length(input); unsigned int sourceID = get_client_id(bev); while (sz &gt;= MAX_PACKET_SIZE) &#123; char msg[MAX_PACKET_SIZE] = &#123; 0 &#125;; char *ptr = msg; bufferevent_read(bev, ptr, HEADER_LENGTH); unsigned int len = ((Header*)ptr)-&gt;length; unsigned int targetID = ((Header*)ptr)-&gt;targetID; ((Header*)ptr)-&gt;sourceID = sourceID; ptr += HEADER_LENGTH; if (sz &lt; len + HEADER_LENGTH) &#123; break; &#125; bufferevent_read(bev, ptr, len); receiveNumber++; dataSize += len + HEADER_LENGTH; if (ClientMap.find(targetID) != ClientMap.end()) &#123; sendNumber++; bufferevent_write(ClientMap[targetID], msg, len + HEADER_LENGTH); &#125; else &#123; //can't find &#125; sz = evbuffer_get_length(input); &#125; //calculate the speed of data and packet clock_t nowtime = clock(); if (lastTime == 0) &#123; lastTime = nowtime; &#125; else &#123; cout &lt;&lt; \"client number: \" &lt;&lt; ClientMap.size() &lt;&lt; \" \"; cout &lt;&lt; \"data speed: \" &lt;&lt; (double)dataSize / (nowtime - lastTime) &lt;&lt; \"k/s \"; cout &lt;&lt; \"packet speed: receive \" &lt;&lt; (double)receiveNumber / (nowtime - lastTime) &lt;&lt; \"k/s \"; cout &lt;&lt; \"send \" &lt;&lt; (double)sendNumber / (nowtime - lastTime) &lt;&lt; \"k/s\" &lt;&lt; endl; if (nowtime - lastTime &gt; TIME_INTERVAL) &#123; dataSize = 0; lastTime = nowtime; receiveNumber = 0; sendNumber = 0; &#125; &#125;&#125;void conn_eventcb(struct bufferevent *bev, short events, void *user_data) &#123; if (events &amp; BEV_EVENT_EOF) &#123; cout &lt;&lt; \"Connection closed\" &lt;&lt; endl; &#125; else if (events &amp; BEV_EVENT_ERROR) &#123; cout &lt;&lt; \"Got an error on the connection: \" &lt;&lt; strerror(errno) &lt;&lt; endl; &#125; bufferevent_free(bev);&#125;unsigned int get_client_id(struct bufferevent* bev) &#123; for (auto p = ClientMap.begin(); p != ClientMap.end(); p++) &#123; if (p-&gt;second == bev) &#123; return p-&gt;first; &#125; &#125; return 0;&#125;void write_buffer(string&amp; msg, struct bufferevent* bev, Header&amp; header) &#123; char send_msg[BUFFER_SIZE] = &#123; 0 &#125;; char* ptr = send_msg; int len = 0; memcpy(ptr, &amp;header, sizeof(Header)); len += sizeof(Header); ptr += sizeof(Header); memcpy(ptr, msg.c_str(), msg.size()); len += msg.size(); bufferevent_write(bev, send_msg, len);&#125;string inttostr(int num) &#123; string result; bool neg = false; if (num &lt; 0) &#123; neg = true; num = -num; &#125; if (num == 0) &#123; result += '0'; &#125; else &#123; while (num &gt; 0) &#123; int rem = num % 10; result = (char)(rem + '0') + result; num /= 10; &#125; &#125; if (neg) &#123; result = '-' + result; &#125; return result;&#125; 客户端1234567891011121314151617181920#ifndef _MESSAGE_H_#define _MESSAGE_H_#include&lt;string&gt;using namespace std;typedef struct msg_header &#123; unsigned int targetID; unsigned int sourceID; unsigned int length;&#125; Header;void conn_writecb(struct bufferevent *, void *);void conn_readcb(struct bufferevent *, void *);void conn_eventcb(struct bufferevent *, short, void *);string inttostr(int);void write_buffer(string&amp;, struct bufferevent*, Header&amp;);#endif // !_MESSAGE_H_ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;event2/bufferevent.h&gt; #include &lt;event2/buffer.h&gt; #include &lt;event2/listener.h&gt; #include &lt;event2/util.h&gt; #include &lt;event2/event.h&gt; #include &lt;iostream&gt;#include &lt;string&gt;#include \"message.h\"using namespace std;#define PORT 1234#define BUFFER_SIZE (16 * 1024) #define READ_SIZE (16 * 1024)#define SEND_INTERVAL 0#define CLIENT_NUMBER 2#define SEND_TIMES 10#define MAX_PACKET_SIZE 1024#define HEADER_LENGTH 12#define DATA_LENGTH 1000const char ip_address[] = \"127.0.0.1\";int main() &#123; cout &lt;&lt; \"Client running\" &lt;&lt; endl;#ifdef WIN32 WSAData wsaData; WSAStartup(MAKEWORD(2, 0), &amp;wsaData);#endif struct sockaddr_in srv; memset(&amp;srv, 0, sizeof(srv)); srv.sin_addr.S_un.S_addr = inet_addr(ip_address); srv.sin_family = AF_INET; srv.sin_port = htons(PORT); struct event_base *base = event_base_new(); if (!base) &#123; cout &lt;&lt; \"Could not initialize libevent\" &lt;&lt; endl; return 1; &#125; struct bufferevent* bev = bufferevent_socket_new(base, -1,BEV_OPT_CLOSE_ON_FREE); bufferevent_setcb(bev, conn_readcb, conn_writecb, conn_eventcb, NULL); //连接，成功返回0，失败返回-1 int flag = bufferevent_socket_connect(bev, (struct sockaddr *)&amp;srv, sizeof(srv)); bufferevent_enable(bev, EV_READ | EV_WRITE); if (-1 == flag) &#123; cout &lt;&lt; \"Connect failed\" &lt;&lt; endl; return 1; &#125; event_base_dispatch(base); event_base_free(base); return 0;&#125;void conn_writecb(struct bufferevent *bev, void *user_data) &#123; //Sleep(SEND_INTERVAL); int len = 0; static int num[10] = &#123; 0 &#125;; unsigned int toID = rand() % CLIENT_NUMBER + 1; Header header; string msg(DATA_LENGTH - HEADER_LENGTH, '0'); header.targetID = toID; header.length = msg.size(); write_buffer(msg, bev, header);&#125;void write_buffer(string&amp; msg, struct bufferevent* bev, Header&amp; header) &#123; char send_msg[READ_SIZE] = &#123; 0 &#125;; char* ptr = send_msg; int len = 0; //多发几次，便于测试大量数据 for (int i = 0; i &lt; SEND_TIMES; i++) &#123; memcpy(ptr + len, &amp;header, sizeof(Header)); len += sizeof(Header); memcpy(ptr + len, msg.c_str(), msg.size()); len += msg.size(); &#125; bufferevent_write(bev, send_msg, len);&#125;void conn_readcb(struct bufferevent *bev, void *user_data) &#123; struct evbuffer *input = bufferevent_get_input(bev); size_t sz = evbuffer_get_length(input); //返回evbuffer储存的字节数 while (sz &gt;= MAX_PACKET_SIZE) &#123; char msg[MAX_PACKET_SIZE] = &#123; 0 &#125;; char *ptr = msg; bufferevent_read(bev, ptr, HEADER_LENGTH); unsigned int len = ((Header*)ptr)-&gt;length; unsigned int targetID = ((Header*)ptr)-&gt;targetID; unsigned int sourceID = ((Header*)ptr)-&gt;sourceID; ptr += HEADER_LENGTH; if (sz &lt; len + HEADER_LENGTH) &#123; break; &#125; bufferevent_read(bev, ptr, len); cout &lt;&lt; \"receive \" &lt;&lt; HEADER_LENGTH + strlen(ptr) &lt;&lt; \" bytes from client \" &lt;&lt; sourceID &lt;&lt; endl; sz = evbuffer_get_length(input); &#125;&#125;void conn_eventcb(struct bufferevent *bev, short events, void *user_data)&#123; if (events &amp; BEV_EVENT_EOF) &#123; cout &lt;&lt; \"Connection closed\" &lt;&lt; endl; &#125; else if (events &amp; BEV_EVENT_ERROR) &#123; cout &lt;&lt; \"Got an error on the connection: \" &lt;&lt; strerror(errno) &lt;&lt; endl; &#125; else if (events &amp; BEV_EVENT_CONNECTED) &#123; cout &lt;&lt; \"Connect succeed\" &lt;&lt; endl; string msg = \"connect to server\"; Header header; header.targetID = 0; header.length = msg.size(); write_buffer(msg, bev, header); return; &#125; bufferevent_free(bev);&#125;string inttostr(int num) &#123; string result; bool neg = false; if (num &lt; 0) &#123; neg = true; num = -num; &#125; if (num == 0) &#123; result += '0'; &#125; else &#123; while (num &gt; 0) &#123; int rem = num % 10; result = (char)(rem + '0') + result; num /= 10; &#125; &#125; if (neg) &#123; result = '-' + result; &#125; return result;&#125; 效果图片普通测试 服务器测试转发速度 客户端 client1： client2： 最大负载测试 服务器数据 测试统计libevent 测试结果，本地回环地址测试 接收的client个数 2，发送的client个数 4 packet speed代表每秒服务器转发的packet的个数 packet length packet speed data speed 20 bytes 66 k/s 1333 k/s 50 bytes 36.5 k/s 1800 k/s 100 bytes 20.0 k/s 2000 k/s 200 bytes 11.2 k/s 2200 k/s 300 bytes 8.3 k/s 2490 k/s 500 bytes 5.4 k/s 2700 k/s 800 bytes 3.45 k/s 2750 k/s 1000 bytes 2.65 k/s 2650 k/s","categories":[],"tags":[{"name":"libevent","slug":"libevent","permalink":"https://uyouii.github.io/tags/libevent/"},{"name":"c++","slug":"c","permalink":"https://uyouii.github.io/tags/c/"},{"name":"network","slug":"network","permalink":"https://uyouii.github.io/tags/network/"}]}]}