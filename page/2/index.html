<!DOCTYPE html>





<html class="theme-next gemini" lang="en">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Uyouii&#39;s Blogs">
<meta property="og:url" content="https://uyouii.github.io/page/2/index.html">
<meta property="og:site_name" content="Uyouii&#39;s Blogs">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Uyouii&#39;s Blogs">
  <link rel="canonical" href="https://uyouii.github.io/page/2/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Uyouii's Blogs</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Uyouii's Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">There are many things need to learn.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
    </ul>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/神们自己/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/神们自己/" class="post-title-link" itemprop="url">神们自己</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:15:44 / Modified: 18:22:15" itemprop="dateCreated datePublished" datetime="2019-08-03T18:15:44+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/bookread/" itemprop="url" rel="index"><span itemprop="name">bookread</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="神们自己"><a href="#神们自己" class="headerlink" title="神们自己"></a>神们自己</h2><ol>
<li>历史往往就是由这些讨厌而且毫无目的的冲动推动的。</li>
<li>有人认为，公众希望环境得以保护，人类的存续得以实现，还认为那些为了这类崇高目标而奋斗的理想主义者会得到公众的爱戴，这种想法都是错的。实际上，公众所期望的只有一件事：他们自己过上安逸舒适的生活。通过二十世纪的环境危机，我们早就看明白了。当人们知道吸烟会导致患癌症的几率上升而最有效的解决办法就是禁烟时，他们却希望能够发明一种不致癌的香烟。当人们知道内燃机会对大气造成污染而最好的办法就是不再使用这类引擎时，他们却希望能够发明不污染空气的引擎。</li>
<li>“他们只需要拒绝相信就行。面对难题，最容易的对策就是拒绝相信它的存在。”</li>
<li>凡是对自己有一点利益就会选择相信。有时候即使毫无可能，人们也会顽冥不化。</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/07-进程环境/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/07-进程环境/" class="post-title-link" itemprop="url">07 进程环境</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:11:23 / Modified: 18:12:14" itemprop="dateCreated datePublished" datetime="2019-08-03T18:11:23+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Unix环境高级编程/" itemprop="url" rel="index"><span itemprop="name">Unix环境高级编程</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>[TOC]</p>
<h1 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h1><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>c程序总是从main函数开始执行。</p>
<p>当内核执行C程序时（使用一个exec函数），在调用mian函数前先调用一个特殊的启动例程。启动例程从内核取得命令行参数和环境变量值。</p>
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>有8种方式使进程终止(termination)，其中5种为正常终止，它们是：</p>
<ol>
<li>从mian返回</li>
<li>调用exit</li>
<li>调用<code>_exit</code>或<code>_Exit</code></li>
<li>最后一个线程从其启动例程返回</li>
<li>从最后一个线程调用<code>pthread_exit</code></li>
</ol>
<p>异常终止有3种方式：</p>
<ol start="6">
<li>调用abort</li>
<li>接到一个信号</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<h3 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<p>3个函数用于正常终止一个程序：<code>_exit</code>和<code>_Exit</code>立即进入内核，<code>exit</code>则先执行一些清理处理，然后返回内核。</p>
<p><code>exit</code>函数总是执行一个标准I/O库的清理关闭操作；对于所有打开流调用<code>fclose</code>函数。这造成输出缓冲中所有的数据都被冲洗（写到文件上）。</p>
<p>3个推出函数都带一个整型参数，称为终止状态（或 退出状态，exit status）。大多数UNIX系统shell都提供检查进程终止状态的方法。如果(a)调用这些函数时不带终止状态，或(b)main执行了一个无返回值的return语句，或(c)main没有声明返回类型为整型，则该进程的终止状态是为定义的。</p>
<p>但是若main的返回类型是整型，并且mian执行到最后一条语句时返回（隐式返回），那么该进程的终止状态是0。</p>
<h3 id="函数atexit"><a href="#函数atexit" class="headerlink" title="函数atexit"></a>函数atexit</h3><p>按照ISO C的规定，一个进程可以登记至多32个函数，这些函数将由exit自动调用。这些函数为终止处理程序（exit handler），并调用<code>atexit</code>函数来登记这些函数。</p>
<p>如果程序调用exec族中的任一函数，则将清除已安装的所有终止处理程序。</p>
<h2 id="c程序的储存空间布局"><a href="#c程序的储存空间布局" class="headerlink" title="c程序的储存空间布局"></a>c程序的储存空间布局</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB8b9465fba8f6d9953f589a3be7c5b99f?method=download&amp;shareKey=0ee0ac303f8eed43158ca594f0096ca0" alt="image"></p>
<blockquote>
<p>典型储存空间安排</p>
</blockquote>
<p>c语言一直由一下几个部分组成：</p>
<ul>
<li><strong>正文段</strong>。这是CPU执行机器指令的部分。通常，正文段是可以共享的，所以即使是频繁执行的程序，在储存器中也只需要有一个副本，而且正文段通常是只读的，以防止程序由于意外而修改其指令。</li>
<li><strong>初始化数据段</strong>。通常将此段称为数据段，它包含了程序中需明确地赋初值的变量。例如，C程序中任何函数之外的声明:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int maxcount = 99;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>未初始化数据段</strong>。通常将此段称为bss段，这一名称来源于早期汇编程序一个操作符，意思是“由符号开始的块”（block started by symbol），在程序开始执行之前，内核讲此段中的数据初始化为0或空指针。函数外的声明：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long sum[1000];</span><br></pre></td></tr></table></figure>
<p>使此变量存放在非初始化数据段中。</p>
<ul>
<li><strong>栈</strong>。自动变量以及每次函数调用时所需保存的信息都存放在此段中。每次函数调用时，其返回地址以及调用者的环境信息（如某些机器寄存器的值）都存放在栈中。然后，最近被调用的函数在栈上为其自动和临时变量分配储存空间。</li>
<li><strong>堆</strong>。通常在堆中进行动态内存分配。</li>
</ul>
<p>对于32位Intel x86处理器上的linux，正文段从0x04048000单元开始，栈底则在0xC0000000之下开始。堆顶和栈顶之间未用的虚地址空间很大。</p>
<p>未初始化数据段的内容并不存放在磁盘文件中。其原因是，内核在程序开始运行前将它们都设置为0。需要存放在磁盘程序文件中的段只有正文段和初始化数据段。</p>
<h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><p>大多数UNIX系统支持共享库。</p>
<p>共享库时的可执行文件中不再需要包含公共的库函数，而只需在所有进程都可引用的储存区中保存这种库例程的一个副本。</p>
<p>程序第一次执行或者第一次调用某个库函数时，用动态链接方法将程序与共享库函数相链接。</p>
<p>这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时，或者每个共享库函数第一次被调用时。</p>
<p>共享库的另一个有点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑。</p>
<h2 id="储存空间分配"><a href="#储存空间分配" class="headerlink" title="储存空间分配"></a>储存空间分配</h2><p>ISO C 说明了3个用于储存空间分配的函数。</p>
<ol>
<li><code>malloc</code>，分配指定字节数的储存区。此储存区中的初始值不确定。</li>
<li><code>calloc</code>，为指定数量指定长度的对象分配储存空间。该空间中的每一位(bit)都初始化为0。</li>
<li><code>realloc</code>，增加或减少以前分配区的长度。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，以便在尾端提供增加的储存区，而新增区域内的初始值则不确定。</li>
</ol>
<p>函数<code>free</code>释放ptr指向的储存空间。被释放的空间通常被送入可用储存区池，以后再调用上述3个函数时再分配。</p>
<p>这些分配例程通常用<code>sbrk(2)</code>系统调用实现。该系统调用扩充（或缩小）进程的堆。</p>
<p>虽然sbrk可以扩充或者缩小进程的储存空间，但是大多数malloc和free的实现都不减小进程的储存空间。释放的空间可供以后再分配，但将它们保持在malloc池中而不返回给内核。</p>
<p>大多数实现说分配的储存空间比所要求的稍微大一些，额外的空间用来记录管理信息————分配块长度、指向下一个分配块的指针等。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/19-进程通信/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/19-进程通信/" class="post-title-link" itemprop="url">19 进程通信</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:04:14 / Modified: 18:12:53" itemprop="dateCreated datePublished" datetime="2019-08-03T18:04:14+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/深入理解Linux内核/" itemprop="url" rel="index"><span itemprop="name">深入理解Linux内核</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><h2 id="System-V-IPC"><a href="#System-V-IPC" class="headerlink" title="System V IPC"></a>System V IPC</h2><h3 id="IPC-共享内存"><a href="#IPC-共享内存" class="headerlink" title="IPC 共享内存"></a>IPC 共享内存</h3><p>共享内存机制允许两个或多个进程通过把公共数据结构放入一个共享内存区(IPC shared memory region)来访问它们。如果进程要访问这种存放在共享内存区的数据结构，就必须在自己的地址空间中增加一个新内存区，它将映射与这个共享内存区相关的页框。这样的页框可以很容易地由内核通过请求调页进行处理。</p>
<ul>
<li>调用<code>shmget()</code>函数来获得一个共享内存地IPC标识符，如果这个共享内存区不存在，就创建它。</li>
<li>调用<code>shmat()</code>函数把一个共享内存区”附加(attach)”到一个进程上。该函数使用IPC共享内存资源地标识符作为参数，并试图把一个共享内存加入到调用进程的地址空间中。调用进程可以获得这个内存区域的起始线性地址，但是这个地址通常不重要，访问这个共享内存区的每个进程都可以使用自己地址空间中的不同地址。<code>shmat()</code>函数不修改进程的页表。</li>
<li>调用<code>shmdt()</code>函数来”分离“由IPC标识符所指定的共享内存区域，也就是说把响应的共享内存区域从进程的地址空间删除。IPC共享内存资源是持久的，即使现在没有进程在使用它，相应的页也不能被丢弃，但是可以被换出。</li>
</ul>
<blockquote>
<p>IPC共享内存数据结构</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/2E9C20A4835B4AE380127F5612D04990?method=download&amp;shareKey=36dd74b524514ff32b9b3c409d7855c4" alt></p>
<blockquote>
<p>shmid_kernel数据结构中的字段</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>struct kern_ipc_perm</td>
<td>shm_perm</td>
<td>kern_ipc_perm数据结构</td>
</tr>
<tr>
<td>struct file *</td>
<td>shm_file</td>
<td>共享段的特殊文件</td>
</tr>
<tr>
<td>int</td>
<td>id</td>
<td>共享段的位置索引</td>
</tr>
<tr>
<td>unsigned long</td>
<td>shm_nattch</td>
<td>当前附加的内存区数</td>
</tr>
<tr>
<td>unsigned long</td>
<td>shm_segsz</td>
<td>内存区字节数</td>
</tr>
<tr>
<td>time_t</td>
<td>shm_atim</td>
<td>最后访问时间</td>
</tr>
<tr>
<td>time_t</td>
<td>shm_dtim</td>
<td>最后分离时间</td>
</tr>
<tr>
<td>time_t</td>
<td>shm_ctim</td>
<td>最后修改时间</td>
</tr>
<tr>
<td>pid_t</td>
<td>shm_cprid</td>
<td>创建者的PID</td>
</tr>
<tr>
<td>pid_t</td>
<td>shm_lprid</td>
<td>最后访问进程的PID</td>
</tr>
<tr>
<td>struct user_struct *</td>
<td>mlock_user</td>
<td>锁定在共享内存RAM中的用户的user_struct描述符的指针</td>
</tr>
</tbody>
</table>
<p>字段<code>shm_file</code>是存放文件对象的地址。Linux 2.6中IPC共享内存与VFS紧密结合。每个IPC共享内存区与属于shm特殊文件系统的一个普通文件关联。</p>
<p>因为shm文件系统在系统目录中没有安装点，因此，用户不能通过普通的VFS系统调用打开并访问它的文件。但是，只要进程”附加”一个内存段，内核就调用<code>do_mmap()</code>，并在进程的地址空间创建文件的一个新的共享内存映射。因此，属于shm特殊文件系统的文件只有一个文件对象方法mmap，该方法是由<code>shm_mmap()</code>函数实现的。</p>
<p>对于任何共享内存映射，通过<code>address_space</code>对象把页框包含在页高速缓存中，而<code>address_space</code>对象包含在索引节点中而且被索引节点的<code>i_mapping</code>字段引用。万一页框属于IPC共享内存区，<code>address_space</code>对象的方法就存放在全局变量<code>shmem_aops</code>中。</p>
<h4 id="换出IPC共享内存区的页"><a href="#换出IPC共享内存区的页" class="headerlink" title="换出IPC共享内存区的页"></a>换出IPC共享内存区的页</h4><p>因为IPC共享内存区映射的是在磁盘上没有映像的特殊索引节点，因此其页是可交换的。因此为了回收IPC共享内存区的页，内核必须把它写入交换区。因为IPC共享内存区是持久的——也就是说内存段不附加到进程，也必须保留这些页。因此即使这些页没有进程在使用，内核也不能简单地删除它们。</p>
<p>…</p>
<h4 id="IPC共享内存区的请求调页"><a href="#IPC共享内存区的请求调页" class="headerlink" title="IPC共享内存区的请求调页"></a>IPC共享内存区的请求调页</h4><p>通过<code>shmat()</code>加入进程的页都是哑元页(dummy page)；该函数把一个新内存区加入一个进程地址空间中，但是它不修改进程的页表。IPC共享内存区的页可以被换出。因此，可以通过请求调页机制来处理这些页。</p>
<p>当进程试图访问IPC共享内存区的一个单元，而其基本的页框还没有分配时则发生缺页异常。相应的异常处理程序确定引起的缺页的地址是在进程的地址空间内，且相应的页表项为空；因此，它就调用<code>do_no_page()</code>函数。这个函数又检查是否为了这个内存区定义了<code>nopage</code>方法。然后调用这个方法，并把页表项设置成所返回的地址。</p>
<p>IPC共享内存所使用的内存区通常定义了<code>nopage</code>方法。这是通过<code>shmem_nopage()</code>函数实现的，该函数执行以下操作：</p>
<ol>
<li>遍历VFS对象的指针链表，并导出IPC共享内存资源的索引节点对象的地址。</li>
<li>从内存区域描述符的<code>vm_start</code>字段和请求的地址计算共享内存内的逻辑页号</li>
<li>检查页是否已经在交换高速缓存中，如果是，则结束并返回描述符的地址</li>
<li>检查页是否在交换高速缓存内且是否最新，如果是，则结束并返回该描述符地址。</li>
<li>检查内嵌在索引节点对象的<code>shmem_inode_info</code>是否存放着逻辑页号对应的换出页标识符。如果是，就调用<code>read_swap_cache_async()</code>执行换入操作，并一直等到数据传送完成，然后结束并返回页描述符的地址。</li>
<li>否则，页不在交换区中；因此就从伙伴系统中分配一个新页框，把它插入到页高速缓存，并返回它的地址。</li>
</ol>
<p><code>do_no_page()</code>函数对引起缺页的地址在进程的页表中所对应表项进行设置，以使该函数指向<code>nopage</code>方法返回的页框。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/17-回收页框/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/17-回收页框/" class="post-title-link" itemprop="url">17 回收页框</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:04:05 / Modified: 18:12:50" itemprop="dateCreated datePublished" datetime="2019-08-03T18:04:05+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/深入理解Linux内核/" itemprop="url" rel="index"><span itemprop="name">深入理解Linux内核</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="回收页框"><a href="#回收页框" class="headerlink" title="回收页框"></a>回收页框</h1><h2 id="页框回收算法"><a href="#页框回收算法" class="headerlink" title="页框回收算法"></a>页框回收算法</h2><p>Linux内核的<strong>页框回收算法(page frame reclaiming algorithm, PFRA)</strong>采取从用户态进程和内核高速缓存”窃取“页框的办法补充伙伴系统的空闲链表。</p>
<h3 id="选择目标页"><a href="#选择目标页" class="headerlink" title="选择目标页"></a>选择目标页</h3><p>FPRA按照页框所含内容，可以区分成：不可回收页、可交换页、可同步页和可丢弃页。</p>
<table>
<thead>
<tr>
<th>页类型</th>
<th>说明</th>
<th>回收操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>不可回收页</td>
<td>空闲页(包含在伙伴系统列表中)<br>保留页(PG_reserved标志置位)<br>内核动态分配页<br>进程内核态堆栈页<br>临时锁定页(PG_locked标志置位)<br>内存锁定页(在线性区中且VM_LOCKED标志置位)</td>
<td>不允许也无需回收</td>
</tr>
<tr>
<td>可交换页</td>
<td>用户态地址空间的匿名页<br>tmpfs文件系统的映射页(如IPC共享内存的页)</td>
<td>将页的内容保存在交换区</td>
</tr>
<tr>
<td>可同步页</td>
<td>用户态地址空间的映射页<br>存有磁盘文件数据且在页高速缓存中的页<br>块设备缓冲页<br>某些磁盘高速缓存的页(如索引节点高速缓存)</td>
<td>必要时，与磁盘映像同步这些页</td>
</tr>
<tr>
<td>可丢弃页</td>
<td>内存高速缓存中的未使用页(如slab分配器高速缓存)<br>目录项高速缓存的未使用页</td>
<td>无需操作</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/12-虚拟文件系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/12-虚拟文件系统/" class="post-title-link" itemprop="url">12 虚拟文件系统</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:03:55 / Modified: 18:12:47" itemprop="dateCreated datePublished" datetime="2019-08-03T18:03:55+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/深入理解Linux内核/" itemprop="url" rel="index"><span itemprop="name">深入理解Linux内核</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><h3 id="虚拟文件系统（VFS）的作用"><a href="#虚拟文件系统（VFS）的作用" class="headerlink" title="虚拟文件系统（VFS）的作用"></a>虚拟文件系统（VFS）的作用</h3><p>虚拟文件系统(Virtual Filesystem)也可以称之为虚拟文件系统转换(Virtual Filesystem Switch, VFS)，是一个内核软件层，用来处理于Unix标准文件系统相关的所有系统调用。</p>
<p>VFS支持的文件系统可以划分为三种主要类型：</p>
<ul>
<li><strong>磁盘文件系统</strong><ul>
<li>这些文件系统管理在本地磁盘分区中可用的储存空间或者其他可以起到磁盘作用的设备（比如说一个USB闪存）</li>
</ul>
</li>
<li><strong>网络文件系统</strong><ul>
<li>这些文件系统允许轻易地访问属于其他网络计算机的文件系统所包含的文件。</li>
</ul>
</li>
<li><strong>特殊文件系统</strong><ul>
<li>这些文件系统部管理本地或者远程磁盘空间。/proc文件系统是特殊文件系统的一个典型范例。</li>
</ul>
</li>
</ul>
<p>Unix目录建立了一颗根目录为”/“的树。根目录包含在文件系统(root filesystem)中，在Linux中这个跟文件系统通常是Ext2或Ext3类型。其他所有文件系统都可以被”安装“在根文件系统的子目录中。</p>
<p>基于磁盘的文件系统通常放在硬件设备中，如硬盘、软盘或者CD-ROM。</p>
<h4 id="通用文件模型"><a href="#通用文件模型" class="headerlink" title="通用文件模型"></a>通用文件模型</h4><p>VFS所隐含的主要思想在于引入一个通用的文件模型(common file model)，这个模型能够表示所有支持的文件系统。不过，要实现每个具体的文件系统，必须将其物立组织结构转换为虚拟文件系统的通用文件模型。</p>
<p>从本质上说，Linux内核不能对一个特定的函数进行硬编码来执行诸如read()或ioctl()这样的操作，而是对每个操作都必须使用一个指针，指向要访问的具体文件系统的适当函数。</p>
<p>通用文件模型由下列对象组成：</p>
<ul>
<li><strong>超级块对象(superblock object)</strong><ul>
<li>存放已安装文件系统的有关信息。对基于磁盘的文件系统，这类对象通常对于存放在磁盘上的<strong>文件系统控制块(filesystem control block)</strong></li>
</ul>
</li>
<li><strong>索引节点对象(inode object)</strong><ul>
<li>存放关于具体文件的一般信息。对于基于磁盘的文件系统，这类对象通常对应于存放在磁盘上的<strong>文件控制块(file control block)</strong>。每个索引节点对象都有一个索引节点号，这个节点号唯一地标识文件系统中的文件。</li>
</ul>
</li>
<li><strong>文件对象(file object)</strong><ul>
<li>存放打开文件与进程之间进行交互的有关信息。这类信息仅当进程访问文件期间存在内核内存中。</li>
</ul>
</li>
<li><strong>目录项对象(dentry object)</strong><ul>
<li>存放目录项（也就是文件的特定名称）与对应文件进行链接的有关信息。每个磁盘文件系统都以自己特有的方式将改类信息存放在磁盘上。</li>
</ul>
</li>
</ul>
<blockquote>
<p>进程与VFS对象之间的交互</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/C4789661047241908CA97231F7444059?method=download&amp;shareKey=b519bbe0405aff597cf7ceefbb132e54" alt></p>
<p>例如：三个不同的进程已经打开同一个文件，其中两个进程使用同一个硬链接。在这种情况下，每个进程都使用自己的文件对象，但只需要两个目录项对象，每个硬链接对应一个目录项对象。这两个目录项对象指向同一个索引节点文件，该索引节点对象标识超级块对象，以及随后的普通磁盘文件。</p>
<p>最近最常使用的目录项被存放在所谓目录项高速缓存 (dentry cache)的<strong>磁盘高速缓存</strong>中，以加速从文件路径名到最后一个路径分量的索引节点的转换过程。</p>
<p>一般来说，<strong>磁盘高速缓存(disk cache)</strong>属于软件机制，它允许内核将原本存在磁盘上的某些信息保存在RAM中，以便这些数据得的进一步访问能快速进行，而不必慢速访问磁盘本身。</p>
<p>磁盘高速缓存不同于<strong>硬件高速缓存</strong>或<strong>内存高速缓存</strong>，后两者都与磁盘或者其他设备无关。硬件高速缓存是一个快速静态RAM，它加快了直接对慢速动态RAM的请求。内存高速缓存是一种软件机制，引入它是为了绕过内核内存分配器。</p>
<p>除了<strong>目录项高速缓存</strong>和<strong>索引节点高速缓存</strong>之外，Linux还使用其他磁盘高速缓存。其中最重要的一种就是<strong>页高速缓存</strong>。</p>
<h3 id="VFS数据结构"><a href="#VFS数据结构" class="headerlink" title="VFS数据结构"></a>VFS数据结构</h3><h4 id="超级块对象"><a href="#超级块对象" class="headerlink" title="超级块对象"></a>超级块对象</h4><p>所有超级块对象都以双向循环链表的形式链接在一起。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/09-进程地址空间/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/09-进程地址空间/" class="post-title-link" itemprop="url">09 进程地址空间</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:03:45 / Modified: 18:12:44" itemprop="dateCreated datePublished" datetime="2019-08-03T18:03:45+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/深入理解Linux内核/" itemprop="url" rel="index"><span itemprop="name">深入理解Linux内核</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h1><p>内核中的函数总是以相当直接了当的方式获得动态内存，这是通过调用以下几种函数中的一个达到的：<code>__get_free_pages()</code>或者<code>alloc_pages()</code>从分区页框分配器中获得页框，<code>kmem_cache_alloc()</code>或<code>kmalloc()</code>使用slab分配器为专用或通用对象分配块，而<code>vmalloc()</code>或<code>vmalloc_32()</code>获得一块非连续的内存区。如果所请求的内存区得以满足，这些函数都返回一个页描述符地址或线性地址（即所分配动态内存区的起始地址）。</p>
<p>使用这些简单方法基于以下两个原因：</p>
<ul>
<li>内核是操作系统中优先级最高的成分。如果某个内核函数请求动态内存，那么，必定有正当的理由发出那个请求，因此，没有道理试图推迟这个请求。</li>
<li>内核信任自己。所有的内核函数都被假定是没有错误的，因此内核函数不必插入针对编程错误的任何保护措施。</li>
</ul>
<p>当给用户态分配内存时，情况完全不同：</p>
<ul>
<li>进程对动态内存的请求被认为是不紧迫的。一般来说，内核总是尽量推迟给用户态进程分配动态内存。</li>
<li>由于用户进程是不可信任的，因此，内核必须能随时准备捕获用户态进程引起的所有寻址错误。</li>
</ul>
<p>内核使用了一种新的资源实现了对进程动态内存的推迟分配。当用户态进程请求动态内存时，并没有获得请求的页框，而仅仅获得对一个新的线性区间的使用权，而这一线性地址空间成为进程地址空间的一部分。这一区间叫做“线性区”(memory region)</p>
<h2 id="进程的地址空间"><a href="#进程的地址空间" class="headerlink" title="进程的地址空间"></a>进程的地址空间</h2><p>进程的地址空间（address space）由允许进程使用的全部线性地址组成。</p>
<p>内核通过所谓线性区资源来表示线性地址空间，线性区是由起始线性地址、长度和一些访问权限来描述的。为了效率起见，其实地址和线性区的长度都必须是4096的倍数，以便每个线性区所识别的数据完全填满分配给它的页框。</p>
<p>获得新线性区的一些典型情况：</p>
<ul>
<li>当用户在控制台输入一条命令时，shell进程创建一个新的进程去执行这个命令。结果是一个全新的地址空间分配给了新进程。</li>
<li>正在运行的进程有可能决定装入一个完全不同的程序。在这种情况下，进程标识符仍然保持不变，可是在装入这个程序以前所使用的线性区却被释放，并有一组新的线性区分配给这个进程。</li>
<li>正在运行的进程可能对一个文件（或它的一部分）执行“内存映射”。在这种情况下，内核给这个进程分配一个新的线性区来映射这个文件。</li>
<li>进程可能持续向它的用户态堆栈增加数据，直到映射这个堆栈的线性区用完为止。在这种情况下，内核也许会决定扩展这个线性区的大小。</li>
<li>进程可能创建一个IPC共享线性区来与其他合作进程共享数据。在这种情况下，内核给这个进程分配一个新的线性区以实现这个方案。</li>
<li>进程可能通过调用类似malloc()这样的函数扩展自己的动态区(堆)。结果是，内核可能决定扩展给这个堆分配的线性区。</li>
</ul>
<table>
<thead>
<tr>
<th>系统调用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>brk()</td>
<td>改变进程堆的大小</td>
</tr>
<tr>
<td>execve()</td>
<td>装入一个新的可执行文件，从而改变进程的地址空间</td>
</tr>
<tr>
<td>_exit()</td>
<td>结束当前进程并撤销它的地址空间</td>
</tr>
<tr>
<td>fork()</td>
<td>创建一个新的进程，并为它创建新的地址空间</td>
</tr>
<tr>
<td>mmap(), mmap2()</td>
<td>为文件创建一个内存映射，从而扩大进程的地址空间</td>
</tr>
<tr>
<td>mremap()</td>
<td>扩大或缩小线性区</td>
</tr>
<tr>
<td>remap_file_pages()</td>
<td>为文件创建非线性区映射</td>
</tr>
<tr>
<td>munmap()</td>
<td>撤销对文件的内存映射，从而缩小进程的地址空间</td>
</tr>
<tr>
<td>shmat()</td>
<td>创建一个共享线性区</td>
</tr>
<tr>
<td>shmdt()</td>
<td>撤销一个共享线性区</td>
</tr>
</tbody>
</table>
<h2 id="内存描述符"><a href="#内存描述符" class="headerlink" title="内存描述符"></a>内存描述符</h2><p>与进程地址空间的全部信息都包含在一个叫做<strong>内存描述符(memory descriptor)</strong>的数据结构中，这个结构类型为<code>mm_struct</code>，进程描述符的<code>mm</code>字段就指向这个数据结构。</p>
<p>所有的内存描述符存放在一个双向链表中。</p>
<h3 id="内核线程的内存描述符"><a href="#内核线程的内存描述符" class="headerlink" title="内核线程的内存描述符"></a>内核线程的内存描述符</h3><p>内核线程仅运行在内核态，因此，它们永远不会访问低于<code>TASK_SIZE</code>（等于<code>PAGE_OFFSET</code>，通常为0xc0000000）的地址。与普通进程相反，内核线程不用线性区，因此，内存描述符的很多字段对内核线程都是没有意义的。</p>
<p>因为大于 <code>TASK_SIZE</code>线性地址的相应页表项都应该总是相同的，因此，一个内核线程到底使用了什么样的页表集根本就没有什么关系。为了避免无用的TLB和高速缓存的刷新，内核线程使用一组最近运行的普通进程的页表。结果，在每个进程描述符中包含了两种内存描述符指针： <code>mm</code>和<code>active_mm</code>。</p>
<p>…</p>
<h2 id="线性区"><a href="#线性区" class="headerlink" title="线性区"></a>线性区</h2><p>Linux通过类型为<code>vm_area_struct</code>的对象实现线性区。</p>
<p>进程所拥有的线性区从来不重叠，并且内核尽力把新分配的线性区与紧邻的现有线性区进行合并。如果两个相邻区的访问权限相匹配，就能把它们合并到一起。</p>
<blockquote>
<p>增加或删除一个线性区地址空间</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/F7047DB0878844A0B44065826C8E0845?method=download&amp;shareKey=9281bbf08dd290fcb0005d3cc7fa712c" alt></p>
<h3 id="线性区数据结构"><a href="#线性区数据结构" class="headerlink" title="线性区数据结构"></a>线性区数据结构</h3><p>进程所拥有的所有线性区是通过一个简单的链表链接在一起的。出现在链表中的线性区是按内存地址的升序排列的；不过，每两个线性区可以由未用的内存地址隔开。</p>
<p>每个<code>vm_area_struct</code>元素的<code>vm_next</code>字段指向链表的下一个元素。内核通过进程的内存描述符的<code>mmp</code>字段来查找线性区，其中<code>mmap</code>字段指向链表中的第一个线性区描述符。</p>
<p>内存描述符的<code>map_count</code>字段存放进程所拥有的线性区数目。</p>
<blockquote>
<p>与进程地址相关的描述符</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/8326859C14CB4CB6848CC79CE64CD1F1?method=download&amp;shareKey=1b719216a8e0bdb893f9b03039123a9c" alt></p>
<p>Linux2.6把内存描述符同时放在红黑树中。</p>
<p>为了存放进程的线性区，Linux既使用了链表，也使用了红黑树。这两种数据结构包含指向同一线性区描述符的指针，当插入或删除一个线性区描述符时，内核通过红黑树搜索前后元素，并用搜索结果快速更新链表而不用扫描链表。</p>
<p>一般来说，红黑树用来确定含有指定地址的线性区，而链表通常在扫描整个线性区集合时来使用。</p>
<h3 id="分配线性区地址空间"><a href="#分配线性区地址空间" class="headerlink" title="分配线性区地址空间"></a>分配线性区地址空间</h3><p><code>do_mmap()</code>函数为当前进程创建并初始化一个新的线性区。分配成功之后，可以把这个新的饿线性区与进程已有的其他线性区进行合并。</p>
<p><code>do_mmap()</code>函数使用下面的参数：</p>
<ul>
<li><code>file</code>和<code>offest</code>：如果新的线性区把一个文件映射到内存，则使用文件描述符指针file和文件偏移量offset。</li>
<li><code>addr</code>：这个线性地址指定从何处开始查找一个空闲的区间。</li>
<li><code>len</code>：线性地址区间的长度</li>
<li><code>prot</code>：这个参数指定这个线性区所包含页的访问权限。</li>
<li><code>flag</code>：这个参数指定线性区的其他标志。<ul>
<li><code>MAP_SHARED</code>和<code>MAP_PRIVATE</code>：前一个标志指定线性区中的页可以被几个进程共享；后一个标志作用相反。这两个标志都与<code>vm_area_struct</code>描述符中的<code>VM_SHARED</code>标志有关。</li>
<li><code>MAP_FIXED</code>：区间的起始地址必须是由参数<code>addr</code>所指定的。</li>
<li><code>MAP_ANONYMOUS</code>：没有文件与这个线性区相关联</li>
<li><code>MAP_NORESERVE</code>：函数不必预先检查空闲页框的数目</li>
<li><code>MAP_POPULATE</code>：函数应该为线性区建立的映射提前分配需要的页框。该标志仅对映射文件的线性区和IPC共享的线性区有意义。</li>
<li><code>MAP_NONBLOCK</code>：只有在<code>MAP_POPULATE</code>标志置位时才有意义：提前分配页框时，函数肯定不会阻塞。</li>
</ul>
</li>
</ul>
<p><code>do_mmap()</code>函数对<code>offset</code>的值进行检查，然后执行<code>do_mmap_pgoff()</code>函数。这里仅对匿名线性区的实现进行讨论：</p>
<ol>
<li><p>检查参数是否正确，主要检查以下条件</p>
<ul>
<li>线性区地址区间的长度为0或者包含的地址大于<code>TASK_SIZE</code></li>
<li>进程已经映射了过多的线性区，因此<code>mm</code>内存描述符的<code>map_count</code>字段的值超过了允许的范围</li>
<li>flag参数指定的新线性区地址区间的页必须被锁在RAM中，但不允许进程创建上锁的线性区，或者进程加锁页的总数超过了保存在进程描述符<code>signal-&gt;rlim[RLIMIT_MENLOCK].rlim_cur</code>字段中的阈值。</li>
</ul>
<p>如果以上情况中的任何一个成立，则<code>do_mmap_pgoff()</code>函数终止并返回一个负值。如果线性区的地址空间长度为0，则函数不执行任何操作就返回。</p>
</li>
<li><p>调用<code>get_unmapped_area()</code>获得新线性区的线性地址区间</p>
</li>
<li><p>通过把存放在<code>prot</code>和<code>flags</code>参数中的值进行组合来计算新线性区描述符的标志。</p>
</li>
<li><p>调用<code>find_vma_prepare()</code>确定处于新区间之前的线性区对象的位置，以为在红黑树中线性区的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">	vma = find_vma_perpare(mm, addr, &amp;prev, &amp;rb_link, &amp;rb_parent);</span><br><span class="line">    <span class="keyword">if</span>(!vma || vma-&gt;vm_struct &gt;= addr + len)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(do_mummap(mm, addr, len))</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>find_vma_prepare()</code>函数也检查是否还存在与新区间重叠的线性区。如果返回一个非空的地址，这个地址指向一个线性区，而该区的起始位置位于新区间结束地址之前的时候。这种情况下，<code>do_mmap_pgoff()</code>调用<code>do_munmap()</code>删除新区间，然后重复这个步骤。</p>
</li>
<li><p>检查插入新的线性区是否引起进程地址空间的大小（<code>mm-&gt;total_vm &lt; PAGE_SHIFT) + len</code>）超过存放在进程描述符<code>signal-&gt;flim[RLIMIT_AS].rlim_cur</code>字段中的阈值。如果是，就返回出错码<code>-ENOMEM</code>。</p>
</li>
<li><p>如果在<code>flags</code>参数中没有设置<code>MAP_NORESERVE</code>标志，新的线性区包含私有可写页，并且没有足够的空闲页框，则返回出错码<code>-ENOMEM</code>；这最后一个检查是由<code>security_vm_enough_memory()</code>函数实现的。</p>
</li>
<li><p>如果新区间是私有的（没有设置<code>VM_SHARED</code>），且映射的不是磁盘上的一个文件，那么，调用<code>vma_merge()</code>检查前一个线性区是否可以以这样的方式进行扩展来包含新区间。要求前一个线性区必须与在<code>vm_flags</code>局部变量中存放标志的那些线性区具有完全相同的标志。如果前一个线性区可以扩展，那么，<code>vma_merge()</code>页试图把它与随后的线性区进行合并。一旦扩展前一个线性区成功，则跳转到第12步。</p>
</li>
<li><p>调用<code>slab</code>分配函数<code>kmem_cheche_alloc()</code>为新线性区分配一个<code>vm_area_struct</code>数据结构。</p>
</li>
<li><p>初始化新的线性区对象。</p>
</li>
<li><p>如果<code>MAP_SHARED</code>标志被设置（以及新的线性区不映射磁盘上的文件），则该线性区是一个共享匿名区；调用<code>shmem_zero_setup()</code>对它进行初始化。共享匿名区主要用于进程间通信。</p>
</li>
<li><p>调用<code>vma_link()</code>把新线性区插入到线性区链表和红黑树中。</p>
</li>
<li><p>增加存放在内存描述符<code>total_vm</code>字段中的进程地址空间大小。</p>
</li>
<li><p>如果设置了<code>VM_LOCKED</code>标志，就调用<code>make_pages_present()</code>连续分配线性区的所有页，并把它们锁在RAM中。</p>
</li>
<li><p>最后，函数通过返回新线性区的线性地址而终止。</p>
</li>
</ol>
<h3 id="释放线性区地址空间"><a href="#释放线性区地址空间" class="headerlink" title="释放线性区地址空间"></a>释放线性区地址空间</h3><p>内核使用<code>do_mummap()</code>函数从当前进程的地址空间中删除一个线性地址区间。参数为：进程内存描述符的地址<code>mm</code>，地址区间的起始地址<code>strat</code>和它的长度<code>len</code>。要删除的区间并不总是对应一个线性区，它或许是一个线性区的一部分，或许跨越两个或多个线性区。</p>
<h4 id="do-munmap-函数"><a href="#do-munmap-函数" class="headerlink" title="do_munmap()函数"></a><code>do_munmap()</code>函数</h4><p>该函数经过两个主要的阶段。第一阶段，扫描进程所拥有的线性区链表，并把包含在进程地址空间的线性地址空间中的所有线性区从链表中解除链接。第二阶段，更新进程的页表，并把第一阶段找到并标识出的线性区删除。函数利用稍后要说明的<code>split_vma()</code>和<code>unmap_region()</code>函数。<code>do_munmap()</code>执行下面的步骤：</p>
<ol>
<li><p>对参数值进行一些初步检查：如果线性地址区间所含的地址大于<code>TASK_SIZE</code>，如果<code>start</code>不是4096的倍数，或者线性区地址区间的长度为0，则函数返回一个错误代码<code>-EINVAL</code>。</p>
</li>
<li><p>确定要删除的线性区地址区间之后的第一个线性区<code>mpnt</code>的位置(<code>mpnt-&gt;end &gt; start</code>)，如果有这样的线性区：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpnt = find_vma_prev(mm, start, &amp;prev);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有这样的线性区，也没有与线性区间重叠的线性区，就什么都不做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">end = start + len;</span><br><span class="line"><span class="keyword">if</span>(!mpnt || mpnt-&gt;vm_start &gt;= end)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果线性区的起始地址在线性区<code>mpnt</code>内，就调用<code>split_vma()</code>把线性区<code>mpnt</code>划分为两个较小的区；一个区在线性区间外部，而另一个在区间内部。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(start &gt; mpnt-&gt;vm_start) &#123;</span><br><span class="line">	<span class="keyword">if</span>(split_vma(mm, mpnt, start, <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	prev = mpnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新局部变量<code>prev</code>，以前它存储的是指向线性区<code>mpnt</code>前面一个线性区的指针，现在要让它指向<code>mpnt</code>，即指向线性地址区间外部的那个新线性区。<code>prev</code>仍然指向要删除的第一个线性区前面的那个线性区。</p>
</li>
<li><p>如果线性区地址区间的结束地址在一个线性区内部，就再次调用<code>split_vma()</code>把最后重叠的那个线性区划分成两个较小的区：一个区在线性区地址区间的内部，而另一个在区间外部。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">last = find_vma(mm, end);</span><br><span class="line"><span class="keyword">if</span>(last &amp;&amp; end &gt; last-&gt;vm_start) &#123;</span><br><span class="line">	<span class="keyword">if</span>(split_vma(mm, last, start, end , <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新<code>mpnt</code>的值，使它指向线性地址区间的第一个线性区。如果<code>prev</code>为NULL，即没有上述线性区，就从<code>mm-&gt;mmap</code>获得第一个线性区的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpnt = prev ? prve-&gt;vm-&gt;next : mm-&gt;mmap;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用<code>detach_vmas_to_be_unmaped()</code>从进程的线性地址空间中删除位于线性地址区间中的线性区。要删除的线性区的描述符放在一个排好序的链表中，局部变量<code>mpnt</code>指向该链表的头。</p>
</li>
<li><p>获得<code>mm-&gt;page_table_lock</code>自旋锁</p>
</li>
<li><p>调用<code>unmap_region()</code>清除与线性地址区间对应的页表项并释放相应的页框。</p>
</li>
<li><p>释放<code>mm-&gt;page_table_lock</code>自旋锁</p>
</li>
<li><p>释放在第7步建立链表时收集的线性区描述符，对在链表中的所有线性区调用<code>unmap_vma()</code>函数，它本质上执行下述步骤:</p>
<ol>
<li>更新<code>mm-&gt;total_vm</code>和<code>mm-&gt;locked_vm</code>字段</li>
<li>执行内存描述符的<code>mm-&gt;unmap_area</code>方法。</li>
<li>调用线性区的<code>close</code>方法（如果定义了的话）</li>
<li>如果线性区是匿名的，则函数把它从<code>mm-&gt;anon_vma</code>所指向的匿名线性链表中删除。</li>
<li>调用<code>kmem_cache_free()</code>释放线性区描述符</li>
</ol>
</li>
<li><p>返回0（成功）</p>
</li>
</ol>
<h2 id="缺页异常处理程序"><a href="#缺页异常处理程序" class="headerlink" title="缺页异常处理程序"></a>缺页异常处理程序</h2><p>Linux的缺页(Page Fault)异常处理程序必须区分两种情况：</p>
<ol>
<li>由编程引起的异常</li>
<li>由引用属于进程地址空间但还尚未分配物理页框的页引起的异常</li>
</ol>
<blockquote>
<p>缺页异常处理程序的总体方案</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/356EFBECC39849DF854DA6282719DF57?method=download&amp;shareKey=97b529725a3361a55482b424c17c7c89" alt></p>
<p><code>do_page_fault()</code>函数接收以下输入参数：</p>
<ul>
<li><code>pt_regs</code>结构的地址<code>regs</code>，改结构包含当异常发生时的微处理器寄存器的值</li>
<li>3位的<code>error_code</code>，当异常发生时由控制单元压入栈中。这些位有以下含义<ul>
<li>如果第0位被清0，则异常由访问一个不存在的页所引起；否则，如果第0位被设置，则异常由无效的访问权限所引起</li>
<li>如果第1位被清0，则异常由读访问或者执行访问所引起；如果该位置被设置，则异常由写访问所引起</li>
<li>如果第2位被清0，则异常发生在处理器处于内核态时；否则，异常发生在处理器处于用户态时。</li>
</ul>
</li>
</ul>
<blockquote>
<p>缺页处理程序流程图</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/EA3F18C0CE374C91BD933FF2658AF8E0?method=download&amp;shareKey=184c008c512944679860cdec0deba387" alt></p>
<p><code>do_page_fault()</code>首先检查引起缺页的线性地址是否属于第4个GB:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">info.si_code = SEGV_MAPERP;</span><br><span class="line"><span class="keyword">if</span>(address &gt;= TASK_SIZE) &#123;</span><br><span class="line">	<span class="keyword">if</span>(!error_code &amp; <span class="number">5</span>)</span><br><span class="line">		<span class="keyword">goto</span> vmlloc_fault;</span><br><span class="line">	<span class="keyword">goto</span> bad_area_nosemaphore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果发生了由于内核试图访问不存在的页框引起的异常，就跳转去执行<code>vmlloc_fault</code>标记处的代码，该部分代码处理可能由于在内核态访问非连续内存区而引起的缺页。否则就去跳转执行<code>bad_area_nosemaphore</code>标记处的代码。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/08-内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/08-内存管理/" class="post-title-link" itemprop="url">08 内存管理</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:03:34 / Modified: 18:12:41" itemprop="dateCreated datePublished" datetime="2019-08-03T18:03:34+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/深入理解Linux内核/" itemprop="url" rel="index"><span itemprop="name">深入理解Linux内核</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>RAM的某些部分永久地分配给内核，并用来存放内核代码以及静态内核数据结构。</p>
<p>RAM的其余部分称为动态内存(dynamic memory)</p>
<h2 id="页框管理"><a href="#页框管理" class="headerlink" title="页框管理"></a>页框管理</h2><h3 id="页描述符"><a href="#页描述符" class="headerlink" title="页描述符"></a>页描述符</h3><p>内核需要记录每个页框当前的状态。</p>
<p>例如：内核需要区分哪些页框包含的是属于进程的页，哪些页框包含的是内核代码或内核数据。内核还必须能够却东动态内存中的页是否空闲。在以下情况下页框是不空闲的：包含用户态进程的数据、某个软件高速缓存的数据、动态内存分配的内核数据结构、设备驱动程序缓冲的数据、内核模块的代码等等。</p>
<p>页框的状态信息保存在一个类型为page的也描述符中。所有的页描述符存放在<code>mem_map</code>数组中。因为每个描述符长度为32字节，所以<code>mem_map</code>所需要的空间略小于整个RAM的1%。</p>
<blockquote>
<p>页描述符字段</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>unsigned long</td>
<td>flags</td>
<td>一组标志。也对页框所在的管理区进行编号</td>
</tr>
<tr>
<td>atomic_t</td>
<td>_count</td>
<td>页框的引用计数器</td>
</tr>
<tr>
<td>atomic_t</td>
<td>_mapcount</td>
<td>页框中页表项数目（如果没有则为-1）</td>
</tr>
<tr>
<td>unsigned long</td>
<td>private</td>
<td>可用于正在使用页的内核成分（例如，在缓冲页的情况下它是一个缓冲头指针）。如果页是空闲的，则该字段由伙伴系统使用。</td>
</tr>
<tr>
<td>struct address_space *</td>
<td>mapping</td>
<td>当页被插入页高速缓存中时使用，或者当页属于匿名区时使用</td>
</tr>
<tr>
<td>unsigned long</td>
<td>index</td>
<td>作为不同含义被几种内核成分使用。例如，它在页磁盘映像或者匿名区中标识存放在页框中的数据的位置，或者它存放一个换出页标识符</td>
</tr>
<tr>
<td>struct list_head</td>
<td>lru</td>
<td>包含页的最近最少使用(LRU)双向链表的指针</td>
</tr>
</tbody>
</table>
<ul>
<li><code>_count</code>：页的引用计数器。如果该字段为-1，则相应页框空闲，并可分配给任一进程或内核本身；如果该字段的值大于0或等于0，则说明页框被分配给了一个或多个进程，或用于存放一些内核数据结构。<code>page_count()</code>函数返回<code>_count</code>加1后的值，也就是该页的使用者的数目。</li>
<li><code>flags</code>：包含多达32个用来描述页框状态的标志。</li>
</ul>
<blockquote>
<p>描述页框状态的标志</p>
</blockquote>
<table>
<thead>
<tr>
<th>标志名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>PG_locked</td>
<td>页被锁定。例如，在磁盘I/O操作中涉及的页</td>
</tr>
<tr>
<td>PG_error</td>
<td>在传输页时发生I/O错误</td>
</tr>
<tr>
<td>PG_referenced</td>
<td>刚刚访问过的页</td>
</tr>
<tr>
<td>PG_uptodate</td>
<td>在完成读操作后置位，除非发生磁盘I/O错误</td>
</tr>
<tr>
<td>PG_dirty</td>
<td>页已经被修改</td>
</tr>
<tr>
<td>PG_lru</td>
<td>页在活动或非活动页链表中</td>
</tr>
<tr>
<td>PG_active</td>
<td>页在活动页链表中</td>
</tr>
<tr>
<td>PG_slab</td>
<td>包含在slab中的页框</td>
</tr>
<tr>
<td>PG_highmem</td>
<td>页框属于<code>ZONE_HIGHMEM</code>管理区</td>
</tr>
<tr>
<td>PG_checked</td>
<td>由一些文件系统（如Ext2和Ext3）使用的标志</td>
</tr>
<tr>
<td>PG_arch_1</td>
<td>在80x86体系结构上没有使用</td>
</tr>
<tr>
<td>PG_reserved</td>
<td>页框留给内核代码或没有使用</td>
</tr>
<tr>
<td>PG_private</td>
<td>页描述符的private字段存放了有意义的数据</td>
</tr>
<tr>
<td>PG_writeback</td>
<td>正在使用<code>writepage</code>方法将页写到磁盘上</td>
</tr>
<tr>
<td>PG_nosave</td>
<td>系统挂起/唤醒时使用</td>
</tr>
<tr>
<td>PG_compound</td>
<td>通过扩展分页机制处理页框</td>
</tr>
<tr>
<td>PG_swapcache</td>
<td>页属于交换高速缓存</td>
</tr>
<tr>
<td>PG_mappedtodisk</td>
<td>页框中的所有数据对应于磁盘上分配的块</td>
</tr>
<tr>
<td>PG_reclaim</td>
<td>为回收内存对页已经做了写入磁盘的标记</td>
</tr>
<tr>
<td>PG_nosave_free</td>
<td>系统挂起/恢复时使用</td>
</tr>
</tbody>
</table>
<h3 id="非一致内存访问-NUMA"><a href="#非一致内存访问-NUMA" class="headerlink" title="非一致内存访问(NUMA)"></a>非一致内存访问(NUMA)</h3><p>Linux 2.6支持<strong>非一致内存访问(Non-Uniform Memory Access, NUMA)</strong>模型，在这种模型中，给定CPU对不同的内存单元的访问时间可能不一样。</p>
<p>系统的物理内存被划分为几个节点(node)。在一个单独的节点内，任一给定CPU访问页面所需的时间都是相同的。然而，对不同CPU，这个时间就可能不同。</p>
<h3 id="内存管理区"><a href="#内存管理区" class="headerlink" title="内存管理区"></a>内存管理区</h3><p>linux把内存节点的物理内存划分为3个管理区(zone)：</p>
<ul>
<li>ZONE_DMA：包含低于16MB的内存页框</li>
<li>ZONE_NORMAL：包含高于16MB且低于896MB的内存页框</li>
<li>ZONE_HIGHMEM：包含从896MB开始高于896MB的内存页框</li>
</ul>
<p>ZONE_DMA和ZONE_NORMAL区包含内存的”常规”页框，通常把它们线性映射到线性地址空间的第4个GB，内核就可以直接进行访问。相反，ZONE_HIGHMEM区包含的内存页就不能由内核直接访问，尽管它们也线性地映射到了线性地址空间的第4个GB。在64位体系结构上ZONE_HIGHMEM区总是空的。</p>
<h3 id="保留的页框池"><a href="#保留的页框池" class="headerlink" title="保留的页框池"></a>保留的页框池</h3><p>可以用两种不同的方法来满足内存分配请求，如果有足够的空闲内存可使用，请求就会被立刻满足。否则，必须回收一些内存，并且将发出请求的内核控制路径阻塞，直到有内存被释放。</p>
<p>但是，当请求内存时，一些内核控制路径不能被阻塞——例如，这种情况发生在处理中断或在执行临界区的代码时。在这种情况下，一条内核控制路径应当产生<strong>原子内核分配请求</strong> 。原子请求从不被阻塞，如果没有足够的空闲页，则仅仅是分配失败而已。</p>
<p>内核为原子内存分配器请求保留了一个页框池，只有在内存不足时才使用。</p>
<p>保留内存的数量(以KB为单位)存放在<code>min_free_kbytes</code>变量中。初始值在内核初始化时被设置，并取决于直接映射到内核线性地址空间的第4个GB的物理内存的数量——也就是说，取决于包含在ZONE_DMA和ZONE_NORMAL内存管理区内的页框数目:<br>$$<br>保留池的大小 = <a href="KB"> \sqrt{16 \times 直接映射内存} </a><br>$$<br>但是，<code>min_free_kbytes</code>的初始值不能小于128也不能大于65536。</p>
<h3 id="分区页框分配器"><a href="#分区页框分配器" class="headerlink" title="分区页框分配器"></a>分区页框分配器</h3><p>分区页框分配器(zoned page frame allocator)的内核子系统，处理对连续页框组的内存分配请求。</p>
<blockquote>
<p>分区页框分配器的组成</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/19185DB023764A068086F3C04D8048E0?method=download&amp;shareKey=7a9904e2e6d0bebb57a9f7a0dd9bae42" alt></p>
<p>其中，管理区分配器部分接受动态内存的分配与释放的请求。在请求分配的情况下，该部分搜索一个能满足所请求的一组连续页框内存的管理区。在每个管理区内，页框被名为”伙伴系统”的部分来处理。为达到更好的系统性能，小部分页框保留在高速缓存中用于快速地满足单个页框地分配请求。</p>
<h3 id="高端内存页框地内核映射"><a href="#高端内存页框地内核映射" class="headerlink" title="高端内存页框地内核映射"></a>高端内存页框地内核映射</h3><p>与直接映射地物理内存地末端、高端内存地始端所应对地线性地址存放在<code>high_memory</code>变量中，它被设置为896MB。896MB边界以上地页框并不映射在内核线性地址空间的第4个GB，因此，内核不能直接访问它们。也就意味着，返回所分配页框线性地址的页分配器函数不适用于高端内存，即不适用于<code>ZONE_HIGHMEM</code>内存管理区内的页框。</p>
<p>64位硬件平台上不存在这个问题，因为可使用的线性地址空间远大于能安装的RAM大小，简言之，这些体系结构的<code>ZONE_HIGHMEM</code>管理区总是空的。</p>
<h3 id="伙伴系统算法"><a href="#伙伴系统算法" class="headerlink" title="伙伴系统算法"></a>伙伴系统算法</h3><p>内存分配算法必须解决外部碎片问题(external fragmentation)。</p>
<p>从本质上说，避免外部随眠的方法有两种：</p>
<ul>
<li>利用分页单元把一组分连续的空闲页框映射到连续的线性地址空间</li>
<li>开发一种适当的技术来记录现存的空闲连续页框块的情况，以尽量避免位满足对小块的请求而分割大的空闲块。</li>
</ul>
<p>基于下面的原因，内核采取第二种方法：</p>
<ul>
<li>在某些情况下，连续的页框确实是必要的，因为连续的线性地址不足以满足请求。</li>
<li>即使连续页框的分配并不是很重要，但它在保持内核页表不变的方面所起的作用也是不容忽视的。（频繁地修改页表势必导致平均访问内存次数增加，因为这会使CPU频繁地刷新转换后援缓冲器(TLB)的内容。</li>
<li>内核通过4MB的页可以访问大块连续物理内存。这样减少了TLB的失效率，因此提高了内存的平均速度。</li>
</ul>
<p>Linux采用著名的伙伴系统(buddy system)算法来解决外部碎片的问题。把所有空闲页框分组位11块链表，每个块链表分别包含大小为1,2,4,8,16,32,64,128,256,512,1024个连续的页框。对1024个页框的最大请求对应着4MB大小的连续RAM块。</p>
<p>内核试图把大小为b的一对空闲伙伴合并为要给大小为2b的单都块。满足以下条件的两个块称为伙伴：</p>
<ul>
<li>两个块具有相同的大小，记作b。</li>
<li>它们的物理地址是连续的。</li>
<li>第一块的第一个页框的物理地址是$2 \times b \times 2^{12}$的倍数</li>
</ul>
<p>该算法是迭代的，如果它成功合并所释放的块，它会试图合并2b的块，以再次试图形成更大的块。</p>
<h3 id="每CPU页框高速缓存"><a href="#每CPU页框高速缓存" class="headerlink" title="每CPU页框高速缓存"></a>每CPU页框高速缓存</h3><p>内核经常请求和释放单个页框。为了提升系统性能，每个内存管理区定义了一个”每CPU”页框高速缓存。所有”每CPU”高速缓存包含一些预先分配的页框，它们被用于满足本地CPU发出的单一内存请求。</p>
<p>实际上，这里为每个内存管理区和每个CPU提供了两个高速缓存：一个热高速缓存，它存放的页框中所包含的内容很可能就在CPU硬件高速缓存中；还有一个冷高速缓存。</p>
<p>如果内核或用户态进程在刚分配到页框后就立即向页框写，那么从热高速缓存中获取页框就对系统性能有利。实际上，每次对页框储存单元的访问都会导致从另一个页框中给硬件高速缓存“窃取”一行——当然，除非硬件高速缓存包含有一行：它映射刚被访问的“热”页框单元。</p>
<p>反过来，如果页框将要被DMA操作填充，那么从冷高速缓存中获取页框是方便的。在这种情况下，不会涉及CPU，并且硬件高速缓存的行不会被修改。冷高速缓存获得页框为其他类型的内存分配保存了热页框储备。</p>
<p>实现每CPU页框高速缓存的主要数据结构存放在内存管理区描述符的pageset字段中的一个<code>per_cpu_pageset</code>数据数据结构。该数组包含为每个CPU提供的一个元素；这个元素依次由两个<code>per_cpu_pageset</code>描述符组成，一个留给热高速缓存而另一个留给冷高速缓存。</p>
<blockquote>
<p>per_cpu_pages描述符的字段</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>count</td>
<td>高速缓存中的页框个数</td>
</tr>
<tr>
<td>int</td>
<td>low</td>
<td>下界，表示高速缓存需要补充</td>
</tr>
<tr>
<td>int</td>
<td>high</td>
<td>上界，表示高速缓存用尽</td>
</tr>
<tr>
<td>int</td>
<td>batch</td>
<td>在高速缓存中将要添加或删去的页框个数</td>
</tr>
<tr>
<td>struct list_head</td>
<td>list</td>
<td>高速缓存中包含的页框描述符链表</td>
</tr>
</tbody>
</table>
<p>内核使用两个位标志来监视热高速缓存和冷高速缓存大小：</p>
<ul>
<li>如果页框个数低于下界low，内核通过从伙伴系统中分配batch个单一页框来补充对应的高速缓存</li>
<li>如果页框个数高于上界high，内核从高速缓存释放batch个页框到伙伴系统中。</li>
</ul>
<p>值batch、low和high本质上取决于内存管理区中包含的页框个数。</p>
<h2 id="内存区管理"><a href="#内存区管理" class="headerlink" title="内存区管理"></a>内存区管理</h2><p>伙伴算法系统采用页框作为基本内存区，这适合对于大块内存的请求。</p>
<p>为了存放很少的字节而分配一整个页框这显然是一种浪费，取而代之的正确方法就是引入一种新的数据结构来描述在同一页框中如何分配小内存区。但是也引出了一个新的问题，即所谓的内部碎片(internal fragmentation)。内部碎片的产生主要是由于请求内存大小与分配给它的大小不匹配造成的。</p>
<h3 id="slab分配器"><a href="#slab分配器" class="headerlink" title="slab分配器"></a>slab分配器</h3><p>算法基于以下前提：</p>
<ul>
<li>所存放的数据结构的类型可以影响内存区的分配方式。slab分配器概念扩充了这种思想，并把内存区看作对象(object)。为了避免重复初始化对象，slab分配器并不丢弃已经分配的对象，而是释放它们但把它们保存在内存中。当以后又要请求新的对象时，就可以从内存获取而不用重新初始化。</li>
<li>内核函数倾向于反复请求同一类型的内存区。例如，只要内核创建一个新进程，它就要为一些固定大小的表[如进程描述符、打开文件对象等]分配内存区。当进程结束时，包含这些表的内存区还可以被重新使用。因为进程的创建和撤销非常频繁，在没有slab分配器时，内核把时间浪费在反复分配和回收哪些包含在同一内存区的页框上；slab分配器把那些页框保存在高速缓存中并很快地重新使用它们。</li>
<li>对内存区地请求可以根据它们发生地频率来分类。对于预期频繁请求一个特定大小地内存区而言，可以通过创建一组具有适当大小地专用对象来高效地处理，由此以避免内部碎片的产生。另一种情况，对于很少遇到的内存区的大小，可以通过基于一系列几何分布大小（如早期linux版本使用的2的幂次方大小）的对象的分配模式来处理，即使这种方法会导致内部碎片的产生。</li>
<li>在引入对象的大小不是几何分布的情况下，也就是说，数据结构的起始物理地址不是2的幂次，这可以借助处理器硬件高速缓存而导致较好的性能。</li>
<li>硬件高速缓存的高性能又是尽可能地限制对伙伴系统分配器调用的另一个理由，因为对伙伴系统函数的每次调用都”弄脏”硬件高速缓存，所以增加了对内存的平均访问时间。内核函数对硬件高速缓存的影响就是所谓的函数“足迹(footprint)”，其定义为函数结束时重写高速缓存的百分比。显而易见，大的“足迹”导致内核函数刚执行之后较慢的代码执行，因为硬件高速缓存此时填满了无用的信息。</li>
</ul>
<p>slab分配器把对象分组放进高速缓存。每个高速缓存都是同种类型对象的一种“储备”。</p>
<p>包含高速缓存的主内存区被划分为多个slab，每个slab由一个或多个连续的页框组成，这些页框中既包含已分配的对象，也包含空闲的对象。</p>
<blockquote>
<p>slab分配器组成</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/B97BC13B41B548DCA7A209C42D6560A1?method=download&amp;shareKey=b788201cea31b0592f8bb945f2f55b34" alt></p>
<h3 id="高速缓存描述符"><a href="#高速缓存描述符" class="headerlink" title="高速缓存描述符"></a>高速缓存描述符</h3><p>每个高速缓存描述符由kmem_cache_t(等价于struct kmem_cache_s类型)类型的数据结构来描述的。</p>
<p>……</p>
<h3 id="slab-描述符"><a href="#slab-描述符" class="headerlink" title="slab 描述符"></a>slab 描述符</h3><p>高速缓存中的每个slab都有自己的类型为slab的描述符。</p>
<blockquote>
<p>slab 描述符字段</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>struct list_head</td>
<td>list</td>
<td>slab描述符的三个双向循环链表中的一个(在高速缓存描述符的kmem_list3结构中的slabs_full、slabs_partial或slabs_free链表)使用的指针</td>
</tr>
<tr>
<td>unsigned long</td>
<td>colouroff</td>
<td>slab中第一个对象的偏移</td>
</tr>
<tr>
<td>void *</td>
<td>s_mem</td>
<td>slab中的第一个对象(或者已被分配，或者空闲)的地址</td>
</tr>
<tr>
<td>unsigned int</td>
<td>inuse</td>
<td>当前正在使用的（分空闲）slab中的对象个数</td>
</tr>
<tr>
<td>kmem_bufctl_t</td>
<td>free</td>
<td>slab中下一个空闲对象的下标，如果没有剩下空闲对象则为BUFCTL_END</td>
</tr>
</tbody>
</table>
<p>slab描述符可能存放在两个地方：</p>
<ul>
<li>外部slab描述符 ：存放在slab外部，位于cache_sizes指向的一个不适合ISA DMA的普通高速缓存中。</li>
<li>内部slab描述符：存放在slab内部，位于分配给slab的第一个页框的起始位置。</li>
</ul>
<p>当对象小于512MB时，或者当内部碎片为slab描述符和对象描述符在slab中留下足够的空间时，slab分配器选择第二种方案。如果slab描述符存放在slab外部，那么高速缓存描述符的flags字段中的CFLGS_OFF_SLAB标志置为1；否则它被置为0。</p>
<blockquote>
<p>高速缓存描述符与slab描述符之间的关系</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/A2E1AA35EC40482EB3333DAA984B4726?method=download&amp;shareKey=20335df2a5c4d6d42efce4eebb63b0fb" alt></p>
<h3 id="给高速缓存分配slab"><a href="#给高速缓存分配slab" class="headerlink" title="给高速缓存分配slab"></a>给高速缓存分配slab</h3><p>一个新创建的高速缓存没有包含任何slab。只有当以下两个条件都为真时，才给高速缓存分配slab：</p>
<ul>
<li>已发出一个分配新对象的请求</li>
<li>高速缓存不包含任何空闲对象</li>
</ul>
<h3 id="从高速缓存撤销slab"><a href="#从高速缓存撤销slab" class="headerlink" title="从高速缓存撤销slab"></a>从高速缓存撤销slab</h3><p>在两种条件下才能撤销slab：</p>
<ul>
<li>slab高速缓存中有太多空闲的对象</li>
<li>被周期性调用的定时器函数确定是否有完全未使用的slab能被释放</li>
</ul>
<h3 id="对齐内存中的对象"><a href="#对齐内存中的对象" class="headerlink" title="对齐内存中的对象"></a>对齐内存中的对象</h3><p>slab分配器所管理的对象可以在内存中进行对齐，也就是说，存放它们的内存单元的起始物理地址是一个给定常量的倍数，通常是2的倍数。这个常量就是对齐因子（alignment factor)。</p>
<p>slab分配器所允许的最大对其因子是4096，即页框大小。</p>
<p>通常情况下，如果内存单元的物理地址是字大小（即计算机的内部内存总线的宽度）对齐的，那么，微机对内存单元的存取会非常快。</p>
<h3 id="slab着色"><a href="#slab着色" class="headerlink" title="slab着色"></a>slab着色</h3><p>同一硬件高速缓存行可以映射RAM中很多不同的块。相同大小的对象倾向于存放在高速缓存内相同的偏移量处。</p>
<p>在不同slab内具有相同偏移量的对象最终很可能映射在同一高速缓存行中。</p>
<p>高速缓存的硬件可能因此而花费内存周期在同一高速缓存行与RAM内存单元之间来来往往传送两个对象，而其他的高速缓存行并未充分使用。</p>
<p>slab通过一种叫做slab着色（slab coloring）的策略，尽量降低高速缓存这种不愉快的行为。</p>
<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>内存池（memery pool）是linux 2.6的一个新特性。基本上将，一个内存池允许一个内核成分，如块设备子系统，仅在内存不足的紧急情况下分配一些动态内存来使用。</p>
<p>与保留的页框池不同，保留的页框池只用于满足中断处理程序或内部临界区发出的原子内存分配请求。</p>
<p>内存池则是动态内存的储备，只能被特定的内核成分（内存池的拥有者）使用。拥有着通常不使用储备，但是，如果动态内存变得极其稀有以至于普通内存分配请求都将失败的话，那么作为最后的解决手段，内核成分就能调用特定的内存池函数提取得到储备所需的内存。</p>
<p>一个内存池通常叠加在slab分配器之上——也就是说，它被用来保存slab对象的储备。</p>
<p>内存池通常可以被用来分配任何一种类型的动态内存，从整个页框到使用<code>kmalloc()</code>分配的小内存区。</p>
<h2 id="非连续内存区管理"><a href="#非连续内存区管理" class="headerlink" title="非连续内存区管理"></a>非连续内存区管理</h2><p>把内存区映射到一组连续的页框是最好的选择，这样会充分利用高速缓存并获得较低的平均访问时间。如果对内存区的请求不是很频繁，通过连续的线性地址访问非连续的页框这样一种分配模式就会很有意义。这种模式的主要优点是避免了外部碎片，而缺点是必须打乱内核页表。</p>
<p>。。。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/07-进程调度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/07-进程调度/" class="post-title-link" itemprop="url">07 进程调度</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:03:25 / Modified: 18:12:35" itemprop="dateCreated datePublished" datetime="2019-08-03T18:03:25+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/深入理解Linux内核/" itemprop="url" rel="index"><span itemprop="name">深入理解Linux内核</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h2><p><strong>进程分类方法</strong></p>
<p>传统上把进程分类为<strong>“I/O受限(I/O-bound)</strong>“或”<strong>CPU受限(CPU-bound)</strong>“。前者频繁的使用I/O设备，并花费很多时间等待I/O操作完成；后者则需要大量的CPU时间的数值计算应用程序。</p>
<p>另一种分类方法把进程区分为三类：</p>
<ul>
<li><strong>交互式进程(interactive process)</strong>: 这些进程经常与用户进行交互，因此，需要花费很多时间等待键盘和鼠标操作。当接受了输入后，进程必须很快被唤醒，否则用户将发现系统反应迟钝。典型的交互式程序是命令shell、文本编辑器及图形应用程序。</li>
<li><strong>批处理程序(batch process)</strong>: 这些进程不必与用户交互，因此经常在后台运行。这样的进程不必很快地响应，因此常受到调度程序地影响。典型地批处理进程是程序设计语言地编译程序、数据库搜索引擎及科学计算。</li>
<li><strong>实时进程(real-time process)</strong>: 这些进程有很强地调度需要。这样的进程决不会被低优先级的进程阻塞，它们应该有一个短的响应时间，更重要的是，响应时间的变化应该很小。典型的实时程序有视频和音频应用程序、机器人控制程序及从物理传感器上收集数据的程序。</li>
</ul>
<h3 id="进程的抢占"><a href="#进程的抢占" class="headerlink" title="进程的抢占"></a>进程的抢占</h3><p>Linux的进程是抢占式的。如果进程进入TASK_RUNNING状态，内核检查它的动态优先级是否大于当前正在运行的进程的优先级。如果是，current的执行被中断，并调用调度程序选择另一个进程运行（通常是刚变为可运行的进程）。</p>
<p>当然，进程在它的时间片到期时也可以被抢占。此时，当前进程thread_info结构中的TIF_NEED_RESCHED标志被设置，以便时钟中断处理程序终止时调度程序被调用。</p>
<p>注：被强占的进程没有被挂起，因为它还处于TASK_RUNNING状态，只不过不再使用CPU。</p>
<h3 id="一个时间片必须持续多长？"><a href="#一个时间片必须持续多长？" class="headerlink" title="一个时间片必须持续多长？"></a>一个时间片必须持续多长？</h3><p>如果平均时间片太短，有进程切换引起的系统额外开销就会变得非常高。</p>
<p>如果平均时间片太长，进程看起来就不再是并发执行。</p>
<p>对时间片大小的选择始终是一种折衷。Linux采取单凭经验的方法，即选择尽可能长、同时能保持良好响应时间的时间片。</p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>调度程序总能成功地找到要执行地进程。总是至少有一个可运行进程，即swapper进程，它地PID等于0，而且它只有再CPU不能执行其他进程时才执行。</p>
<p>每个Linux进程总是按照下面地调度类型被调度：</p>
<ul>
<li><strong>SCHED_FIFO</strong><ul>
<li>先进先出地实时进程。当调度程序把CPU分配给进程地时候，它把改进程描述符保留在运行队列链表地当前位置。如果没有其他可运行的更高优先级实时进程，进程就继续使用CPU，想用多久就用多久，计师还有其他具有相同优先级的实时进程处于可运行状态。</li>
</ul>
</li>
<li><strong>SCHED_RR</strong><ul>
<li>时间片轮转的实时进程。当调度程序把CPU分配给进程的时候，它把该进程的描述符放在运行队列链表的末尾。这种策略保证对所有具有相同优先级的SCHED_RR实时进程公平的分配CPU时间。</li>
</ul>
</li>
<li><strong>SCHED_NORMAL</strong><ul>
<li>普通的分时进程</li>
</ul>
</li>
</ul>
<p>调度算法根据进程是普通进程还是实时进程有很大不同。</p>
<h3 id="普通进程的调度"><a href="#普通进程的调度" class="headerlink" title="普通进程的调度"></a>普通进程的调度</h3><h3 id="实时进程的调度"><a href="#实时进程的调度" class="headerlink" title="实时进程的调度"></a>实时进程的调度</h3>
          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/03-进程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/03-进程/" class="post-title-link" itemprop="url">03 进程</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:03:13 / Modified: 18:12:31" itemprop="dateCreated datePublished" datetime="2019-08-03T18:03:13+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/深入理解Linux内核/" itemprop="url" rel="index"><span itemprop="name">深入理解Linux内核</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程、轻量级进程和线程"><a href="#进程、轻量级进程和线程" class="headerlink" title="进程、轻量级进程和线程"></a>进程、轻量级进程和线程</h3><p>从内核观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的实体。</p>
<p>Linux使用轻量级进程(lightweight process)对多线程应用程序提供更好的支持。两个轻量级进程基本上可以共享一些资源，诸如地址空间、打开的文件等等。</p>
<h3 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h3><p>进程描述符(process descriptor)——进程描述符都是task_struct类型结构，它的字段包含了与一个进程相关的所有信息。</p>
<blockquote>
<p>linux 进程描述符</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/5383C027E84442578519B055EB01E101?method=download&amp;shareKey=26e9eaa6aea258d172b4b84db68a2520" alt></p>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>进程描述符中的state字段描述了进程当前所处的状态。它由一组标志组成，其中每个标志描述一种可能的进程状态。在当前的Linux版本中，这些状态是互斥的，因此，严格意义上说，只能设置一种状态；其余的标志将被清除。</p>
<ul>
<li><strong>可运行状态(TASK_RUNNING)</strong><ul>
<li>进程要么在CPU上执行，要么装备执行</li>
</ul>
</li>
<li><strong>可中断的等待状态(TASK_INTERRUPTIBLE)</strong><ul>
<li>进程被挂起（睡眠），直到某个条件变为真。产生一个硬件中断，释放进程正等待的系统资源，或传递一个信号都是可以唤醒进程的条件（把进程的状态放回到TASK_RUNNING）。</li>
</ul>
</li>
<li><strong>不可中断的等待状态(TASK_UNINTERRUPTIBLE)</strong><ul>
<li>与可中断的等待状态类似，但有一个例外，把信号传递到睡眠进程不能改变它的状态。这种状态很少用到，但在一些特殊的情况下（进程必须等待，直到一个不能被中断的事件发生），这种状态是很有用的。</li>
<li>例如，当进程打开一个设备文件，其相应的设备驱动程序开始探测相应的硬件设备时会用到这种状态。探测完成以前，设备驱动程序不能被中断，否则，硬件设备会处于不可预知的状态。</li>
</ul>
</li>
<li><strong>暂停状态(TASK_STOPPED)</strong><ul>
<li>进程的执行被暂停。当进程接收到SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU信号后，进入暂停状态。</li>
</ul>
</li>
<li><strong>跟踪状态(TASK_TRACED)</strong><ul>
<li>进程的执行已由debugger程序暂停。当一个进程被另一个进程监控时，任何信号都可以把这个进程置于TASK_TRACED状态。</li>
</ul>
</li>
</ul>
<p>还有两个进程状态既可以存放在进程描述符的state字段中，也可以存放在exit_state字段中。从这两个字段名称可以看出，只有当进程的执行被终止时，进程的状态才会改变为这两种状态中的一种。</p>
<ul>
<li><strong>僵死状态(EXIT_ZOMBIE)</strong><ul>
<li>进程的执行被终止，但是，父进程还没有发布wait4()或waitpid()系统调用来返回有关死亡进程的信息。发布wait()类系统调用前，内核不能丢弃包含在死进程描述符中的数据，因为父进程可能还需要它。</li>
</ul>
</li>
<li><strong>僵死撤销状态(EXIT_DEAD)</strong><ul>
<li>最终状态：由于父进程刚发出wait4()或waitpid()系统调用，因而进程由系统删除。为了防止其他执行线程在同一个进程上也执行wait()类系统调用(这是一种竞争状态)，而把进程的状态由僵死(EXIT_ZOMBIE)状态改为僵死撤销状态(EXIT_DEAD)。</li>
</ul>
</li>
</ul>
<h4 id="标识一个进程"><a href="#标识一个进程" class="headerlink" title="标识一个进程"></a>标识一个进程</h4><p>能够独立调度的每个执行上下文都必须拥有它自己的进程描述符。</p>
<p>进程和进程描述符有非常严格的一一对应关系，使得32位的进程描述符地址可以很容易的标识进程。进程描述符指针指向这些地址，内核对进程的大部分引用是通过进程描述符指针进行的。</p>
<p>类Unix操作系统允许用户使用一个叫进程描述符processID(或PID)的数来标识进程，PID存放在进程描述符的pid字段中。</p>
<p>PID的值有一个上限，默认情况下，最大的PID号时32767(<code>PID_MAX_DEFAULT</code> - 1)；系统管理员可以通过往<code>/proc/sys/kernel/pid_max</code>这个文件中写入一个更小的值来减小PID的上限值。在64位的体系结构中，系统管理员可以把PID的上限扩大到4194303。</p>
<p>由于循环使用PID编号，内核必须通过管理一个<code>pidmap_array</code>位图来表示当前已分配的PID号和闲置的PID号。因为一个页框包含32768个位，所以在32位体系结构中<code>pidmap_array</code>位图存放在一个单独的页中。然而在64位体系结构中，需要为PID位图增加更多的页。系统会一直保存这些页不被释放。</p>
<p>Unix希望同一组的线程有共同的PID。例如，可以把信号发送给指定PID的一组线程，这个信号会作用于该组中的所有线程。</p>
<p>Linux遵照这个标准引入了线程组的表示。一个线程组的所有线程使用和该线程组的领头线程(thread group leader)相同的PID，也就是该组中的第一个轻量级进程的PID，它被存入进程描述符的<code>tgid</code>字段中。<code>getpid()</code>系统调用返回当前进程的<code>tgid</code>值而不是<code>pid</code>值，因此，一个多线程应用的所有线程共享相同的PID。</p>
<h5 id="进程描述符处理"><a href="#进程描述符处理" class="headerlink" title="进程描述符处理"></a>进程描述符处理</h5><p>进程是动态实体，内核必须能够同时处理很多进程，并把进程描述符存放在动态内存中。</p>
<p>对每个进程来说，Linux都把两个不同的数据结构紧凑地存放在一个单独为进程分配的储存区域：一个是与进程描述符相关的小数据结构<code>thread_info</code>，叫做线程描述符。另一个是内核态的进程堆栈。这块储存区域的大小通常为8192个字节(两个页框)。考虑到效率的因素，内核让这8K空间占据连续的两个页框并让第一个页框的起始地址是2^13的倍数。</p>
<p>内核态的进程访问处于内核数据段的栈，这个栈不同于用户态的进程所用的栈。因为内核控制器路径使用很少的栈，因此只需要几千字节的内核态堆栈。所以，对于内核栈和<code>thread_info</code>结构来说，8KB足够了。</p>
<blockquote>
<p>thread_info 结构和进程内核存放在两个连续的页框中</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/D0B0C46090864F248B3F60DB36567363?method=download&amp;shareKey=952119ee0f466af5385c6c8bb7efe9da" alt></p>
<p>esp寄存器是CPU栈指针，用来存放栈顶单元的地址。从用户态切换到内核态以后，进程的内核栈总是空的，因此，esp寄存器指向这个栈的顶端。</p>
<p>c语言使用下列的联合结构方便的表示一个进程的线程描述符和内核栈:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union thread_union &#123;</span><br><span class="line">	struct thread_info thread_info;</span><br><span class="line">    unsigned long stack[2048]; /* 对4K的栈数组下标是1024 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="标识当前进程"><a href="#标识当前进程" class="headerlink" title="标识当前进程"></a>标识当前进程</h5><p><code>thread_info</code>结构与内核态堆栈之间紧密结合提供的主要好处是：内核可以很容易从esp寄存器的值获取当前在CPU运行进程的<code>thread_info</code>结构的地址。如果<code>thread_union</code>结构长度是8K，内核则屏蔽掉esp的低13位有效位就可以获得<code>thread_info</code>结构的基地址；而如果<code>thread_union</code>结构长度是4K，内核则需要屏蔽掉esp的低12位有效地址。</p>
<p>进程最常用的是进程描述符地址而不是<code>thread_info</code>结构的地址，通过<code>thread_info</code>的task指针可以很容易的获取到进程描述符。</p>
<h5 id="进程链表"><a href="#进程链表" class="headerlink" title="进程链表"></a>进程链表</h5><p>每个<code>task_struct</code>结构都包含一个<code>list_head</code>类型的<code>tasks</code>字段，这个类型的<code>prev</code>和<code>next</code>字段分别指向前面和后面的<code>task_struct</code>元素。</p>
<h5 id="TASK-RUNNING状态的进程链表"><a href="#TASK-RUNNING状态的进程链表" class="headerlink" title="TASK_RUNNING状态的进程链表"></a>TASK_RUNNING状态的进程链表</h5><p>当内核寻找一个新进程在CPU运行时，必须只考虑可运行进程(即处在TASK_RUNNING状态的进程)</p>
<p>提高调度程序运行速度的诀窍是建立多个可运行进程链表，每种进程优先权对应一个不同的链表。每个<code>task_struct</code>描述符包含一个<code>list_head</code>类型的字段<code>run_list</code>。如果进程的优先权等于k，run_list字段把该进程链入优先权为k的可运行进程的链表中。</p>
<h4 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h4><blockquote>
<p>进程描述符中表示进程亲属关系的字段描述</p>
</blockquote>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>real_parent</td>
<td>指向创建了P的进程的描述符，如果P的父进程不再存在，就指向进程1(init)的描述符（因此，如果用户运行一个后台进程而且推出了shell，后台进程就会成为init的子进程）</td>
</tr>
<tr>
<td>parent</td>
<td>指向P的当前父进程（这种进程的子进程终止时，必须向父进程发信号）。它的值通常与<code>real_parent</code>一致，但偶尔也可以不同，例如，当另一个进程发出监控P的ptrace()系统调用请求时</td>
</tr>
<tr>
<td>children</td>
<td>链表的头部，链表中的所有元素都是P创建的子进程</td>
</tr>
<tr>
<td>sibling</td>
<td>指向兄弟进程链表的下一个元素或前一个元素的指针，这些兄弟进程的父进程都是P</td>
</tr>
</tbody>
</table>
<h5 id="pidhash表及链表"><a href="#pidhash表及链表" class="headerlink" title="pidhash表及链表"></a>pidhash表及链表</h5><p>由于需要跟踪进程间的关系，PID散列表中使用的数据结构非常复杂。</p>
<p>PID散列表的数据结构是四个pid结构的数组，它在进程描述符的pids字段中。</p>
<blockquote>
<p>pid结构的字段</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> nr;							<span class="comment">// pid的数值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">pid_chain</span>;</span>	<span class="comment">// 链接散列表的下一个和前一个元素</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pid_list</span>;</span>		<span class="comment">// 每个pid的进程链表头</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PID散列表</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/25275D69697641F3AFD4888FF798D311?method=download&amp;shareKey=571ba311ddbb61859cf21834698725fe" alt></p>
<h4 id="如何组织进程"><a href="#如何组织进程" class="headerlink" title="如何组织进程"></a>如何组织进程</h4>
          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/02-内存寻址/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/02-内存寻址/" class="post-title-link" itemprop="url">02 内存寻址</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:03:05 / Modified: 18:12:28" itemprop="dateCreated datePublished" datetime="2019-08-03T18:03:05+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/深入理解Linux内核/" itemprop="url" rel="index"><span itemprop="name">深入理解Linux内核</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h1><h2 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h2><h2 id="硬件中的分段"><a href="#硬件中的分段" class="headerlink" title="硬件中的分段"></a>硬件中的分段</h2><h2 id="Linux中的分段"><a href="#Linux中的分段" class="headerlink" title="Linux中的分段"></a>Linux中的分段</h2><h2 id="硬件中的分页"><a href="#硬件中的分页" class="headerlink" title="硬件中的分页"></a>硬件中的分页</h2><h3 id="硬件高速缓存"><a href="#硬件高速缓存" class="headerlink" title="硬件高速缓存"></a>硬件高速缓存</h3><p>为了缩小CPU和RAM之间的速度不匹配，引入了<strong>硬件高速缓存内存(hardware cache memory)</strong></p>
<p>硬件高速缓存基于著名的<strong>局部性原理(locality principle)</strong>，该原理既适用程序结构也适用于数据结构。这表明由于程序的循环结构及相关数组可以组织成线性数组，最近最常用的相邻地址在最近的将来又被用到的可能性极大。</p>
<p>高速缓存单元插在分页单元和主内存之间。它包含一个<strong>硬件高速缓存内存(hardware cache memory)</strong>和一个<strong>高速缓存控制器(cache controller)</strong>。高速缓存内存中存放内存真正的行。高速缓存控制器存放一个表项数组，每个表项对应高速缓存内存中的一个行。每个表项有一个标签(tag)和描述高速缓存行状态的几个标志(flag)。</p>
<p>这种物理内存地址通常分为3组：最高几位对应标签，中间几位对应高速缓存控制器的字集索引，最低几位对应行内的偏移量。</p>
<blockquote>
<p>处理器硬件高速缓存</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/CEF362F1ECF54FF093D2A854A9EB8940?method=download&amp;shareKey=65e9dfee767bbb515abe16c432a89fab" alt></p>
<p>当访问一个RAM储存单元时，CPU从物理地址中提取出子集的索引号并把子集中所有行的标签与物理地址的高几位比较。如果发现某一行的标签与这个物理地址的高位相同，则CPU命中一个高速缓存(cache hit)；否则，高速缓存没有命中(cache miss)。</p>
<p>当命中一个高速缓存时，高速缓存控制器执行不同的操作。</p>
<p>对于读操作，控制器从高速缓存行中选择数据并送到CPU寄存器；不需要访问RAM因而节约了CPU时间，因此，高速缓存系统起到了应有的作用。</p>
<p>对于写操作，控制器可能采用以下两个基本策略之一：</p>
<ul>
<li><strong>通写(write-through)</strong>：控制器总是既写RAM也写高速缓存行</li>
<li><strong>回写(write-back)</strong>：回写的方式只更新高速缓存行，不改变RAM内容，提供了更快的功效。只有当CPU执行一条要求刷新高速缓存表项的指令时，或者当一个FLUSH硬件信号产生时（通常在高速缓存不命中之后），高速缓存控制器才把高速缓存行写回到RAM中。</li>
</ul>
<p>当高速缓存没有命中时，高速缓存行被写回到内存中，如果有必要的话，把正确的行从RAM中取出放到高速缓存行的表项中。</p>
<h2 id="Linux中的分页"><a href="#Linux中的分页" class="headerlink" title="Linux中的分页"></a>Linux中的分页</h2>
          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/logo1.jpg"
      alt="Uyouii">
  <p class="site-author-name" itemprop="name">Uyouii</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/Uyouii" title="GitHub &rarr; https://github.com/Uyouii" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:taiyoudong@gmail.com" title="E-Mail &rarr; mailto:taiyoudong@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Uyouii</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
    
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  <script src="/js/utils.js?v=7.3.0"></script>

  
  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>



  

  <script src="/js/next-boot.js?v=7.3.0"></script>

  

  

  


  

































    


</body>
</html>
