<!DOCTYPE html>





<html class="theme-next gemini" lang="en">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Uyouii&#39;s Blogs">
<meta property="og:url" content="https://uyouii.github.io/page/4/index.html">
<meta property="og:site_name" content="Uyouii&#39;s Blogs">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Uyouii&#39;s Blogs">
  <link rel="canonical" href="https://uyouii.github.io/page/4/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Uyouii's Blogs</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Uyouii's Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">There are many things need to learn.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
    </ul>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/05/14/ENet 源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/14/ENet 源码分析/" class="post-title-link" itemprop="url">ENet 源码分析</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-14 17:23:00" itemprop="dateCreated datePublished" datetime="2018-05-14T17:23:00+08:00">2018-05-14</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-02 11:28:18" itemprop="dateModified" datetime="2019-08-02T11:28:18+08:00">2019-08-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p><a href="http://enet.bespin.org/index.html" target="_blank" rel="noopener">ENet官方文档地址</a></p>
<p>首先看一下ENet官方给出的ENet的特性(Feature)。</p>
<h1 id="ENet-特性"><a href="#ENet-特性" class="headerlink" title="ENet 特性"></a>ENet 特性</h1><p>ENet是一个具有TCP和UDP各自优点的基于UDP封装的一个网络库。</p>
<p>UDP缺少排序，连接管理，带宽管理，包大小限制等。TCP不能同时打开多个套接字故缺少多流的通信，并且由于其缓冲特性，其包管理机制过于复杂。</p>
<p>ENet则致力于将TCP和UDP的优点结合实现一个统一的网络协议库。</p>
<h2 id="连接管理-Connection-Management"><a href="#连接管理-Connection-Management" class="headerlink" title="连接管理 (Connection Management)"></a>连接管理 (Connection Management)</h2><p>ENet提供了一个简单的与外部主机通信的接口。连接的生命周期通过频繁的ping外部主机动态监管，同时通过主机与外部机器的包的往返时间和丢包情况来监管网络状况。</p>
<h2 id="排序-Sequencing"><a href="#排序-Sequencing" class="headerlink" title="排序 (Sequencing)"></a>排序 (Sequencing)</h2><p>ENet提供了多个的合理排序的网络包流而不是一个单一的比特流从而简化了不同类型数据的传输。</p>
<p>ENet通过为每个发送的网络包编号来实现对包的排序。这些序号会随着包的发送而增长。ENet保证序列号低的包优先发送，从而确保了所有的网络包都按次序发送。</p>
<p>对于不可靠的网络包，如果具有高序号的网络包已经到达，ENet则会简单的丢弃那些低序号的网络包。这样就保证了网络包到达后就可以立即被接收，从而减少了网络延时。对于可靠的网络包，如果一个高序号的包已经到达，但是之前的包确没有到达，ENet会推迟高序号包的接受直到其之前相应序号的网络包均已到达。</p>
<h2 id="通道-Channels"><a href="#通道-Channels" class="headerlink" title="通道 (Channels)"></a>通道 (Channels)</h2><p>既然ENet会推迟可靠网络包的提交来确保网络包的序号，但是无论到达的包是可靠的还是不可靠的，如果之前的网络包是可靠的包，他们都要被推迟提交，这样做可能会造成一些不需要严格保证次序的包同样被推迟提交，从而造成额外的延时。</p>
<p>为了解决上述问题并减少对包的次序的限制，ENet为一个连接提供了多个交流的通道(channel)。每个通道下的网络包可以独立排序，所以一个通道下的包的传送状态不会影响其他通道下的包的传送。</p>
<h2 id="可靠性-Reliability"><a href="#可靠性-Reliability" class="headerlink" title="可靠性 (Reliability)"></a>可靠性 (Reliability)</h2><p>ENet为传送的包提供了可靠性选择，并确保外部主机会确认收到所有的可靠的网络包。如果外部主机在特定时间内没有确认收到网络包，ENet会尝试在合理的次数内重传这个网络包。 重传超时的时间会根据失败次数的增加变得更加宽松便于应对网络临时的混乱和拥塞。</p>
<h2 id="拆分和重组-Fragmentation-and-Reassembly"><a href="#拆分和重组-Fragmentation-and-Reassembly" class="headerlink" title="拆分和重组 (Fragmentation and Reassembly)"></a>拆分和重组 (Fragmentation and Reassembly)</h2><p>ENet在发送包的时候不会考虑包的大小。大的网络包会被分成若干个大小合适的网络包，并在外部机器上重组为发送前的网络包便于远程机器接收。整个过程对于开发者来说都是透明的。</p>
<h2 id="聚合-Aggregation"><a href="#聚合-Aggregation" class="headerlink" title="聚合 (Aggregation)"></a>聚合 (Aggregation)</h2><p>ENet包括了大部分协议指令，包括acknowledgement，packet transfer，确保连接的可用性，减少丢包的机会及其可能造成的延时等。</p>
<h2 id="适应性-Adaptability"><a href="#适应性-Adaptability" class="headerlink" title="适应性 (Adaptability)"></a>适应性 (Adaptability)</h2><p>ENet为可靠包提供了一个动态适应的数据窗口以确保连接不会大量的网络包淹没掉。它也提供了一个静态的带宽分配机制以确保机器在发送和接受包时不会超过这个机器承载的范围。更近一步，ENet提供了一个动态的阀门来响应网络连接时带来的偏差，通过限制发送发送包的数量来应对各种类型的网络拥塞问题。</p>
<h1 id="ENet数据结构"><a href="#ENet数据结构" class="headerlink" title="ENet数据结构"></a>ENet数据结构</h1><h2 id="ENetHost"><a href="#ENetHost" class="headerlink" title="ENetHost"></a>ENetHost</h2><p>ENetHost即ENet的客户端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetHost</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetSocket           socket;</span><br><span class="line">   ENetAddress          address;                    </span><br><span class="line">   enet_uint32          incomingBandwidth;          </span><br><span class="line">   enet_uint32          outgoingBandwidth;          </span><br><span class="line">   enet_uint32          bandwidthThrottleEpoch;</span><br><span class="line">   enet_uint32          mtu;</span><br><span class="line">   enet_uint32          randomSeed;</span><br><span class="line">   <span class="keyword">int</span>                  recalculateBandwidthLimits;</span><br><span class="line">   ENetPeer *           peers;                      </span><br><span class="line">   <span class="keyword">size_t</span>               peerCount;                   </span><br><span class="line">   <span class="keyword">size_t</span>               channelLimit;                </span><br><span class="line">   enet_uint32          serviceTime;</span><br><span class="line">   ENetList             dispatchQueue;</span><br><span class="line">   <span class="keyword">int</span>                  continueSending;</span><br><span class="line">   <span class="keyword">size_t</span>               packetSize;</span><br><span class="line">   enet_uint16          headerFlags;</span><br><span class="line">   ENetProtocol         commands [ENET_PROTOCOL_MAXIMUM_PACKET_COMMANDS];</span><br><span class="line">   <span class="keyword">size_t</span>               commandCount;</span><br><span class="line">   ENetBuffer           buffers [ENET_BUFFER_MAXIMUM];</span><br><span class="line">   <span class="keyword">size_t</span>               bufferCount;</span><br><span class="line">   ENetChecksumCallback checksum;                    </span><br><span class="line">   ENetCompressor       compressor;</span><br><span class="line">   enet_uint8           packetData [<span class="number">2</span>][ENET_PROTOCOL_MAXIMUM_MTU];</span><br><span class="line">   ENetAddress          receivedAddress;</span><br><span class="line">   enet_uint8 *         receivedData;</span><br><span class="line">   <span class="keyword">size_t</span>               receivedDataLength;</span><br><span class="line">   enet_uint32          totalSentData;               </span><br><span class="line">   enet_uint32          totalSentPackets;            </span><br><span class="line">   enet_uint32          totalReceivedData;           </span><br><span class="line">   ENetInterceptCallback intercept;                  </span><br><span class="line">   <span class="keyword">size_t</span>               connectedPeers;</span><br><span class="line">   <span class="keyword">size_t</span>               bandwidthLimitedPeers;</span><br><span class="line">   <span class="keyword">size_t</span>               duplicatePeers;              </span><br><span class="line">   <span class="keyword">size_t</span>               maximumPacketSize;           </span><br><span class="line">   <span class="keyword">size_t</span>               maximumWaitingData;          </span><br><span class="line">&#125; ENetHost;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">内部变量</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>socket</strong></td>
<td style="text-align:left">用于数据传输和连接的UDP套接字句柄</td>
</tr>
<tr>
<td style="text-align:left"><strong>address</strong></td>
<td style="text-align:left">host的socket地址</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingBandwidth</strong></td>
<td style="text-align:left">host接收数据的带宽，即download bandwidth</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingBandwidth</strong></td>
<td style="text-align:left">host上传数据的带宽，即upstream bandwidth</td>
</tr>
<tr>
<td style="text-align:left"><strong>bandwidthThrottleEpoch</strong></td>
<td style="text-align:left">记录host流量控制的时间戳，如果流量控制的时间间隔超过<code>bandwidthThrottleEpoch</code>，则进行流量控制。host流量控制时间间隔设置为1000ms。</td>
</tr>
<tr>
<td style="text-align:left"><strong>mtu</strong></td>
<td style="text-align:left">即最大传输单元，当需要发送的单个packet的大小超过该值时会进行分片操作</td>
</tr>
<tr>
<td style="text-align:left"><strong>randomSeed</strong></td>
<td style="text-align:left">用于生成connectID的随机数种子</td>
</tr>
<tr>
<td style="text-align:left"><strong>recalculateBandwidthLimits</strong></td>
<td style="text-align:left">用于记录是否需要重新计算带宽的标记变量，当有peer连接或者断开连接时会被置为1</td>
</tr>
<tr>
<td style="text-align:left"><strong>peers</strong></td>
<td style="text-align:left">host中用于储存peer的数组，在host初始化时设置，大小为<code>peerCount</code>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>peerCount</strong></td>
<td style="text-align:left">创建host时指定的peerCount，即最大的peer数。如果此时的peer数为<code>peerCount</code>，则在发起连接或者被动连接（收到connect command）时会失败，没有空间容纳新的peer。</td>
</tr>
<tr>
<td style="text-align:left"><strong>channelLimit</strong></td>
<td style="text-align:left">每个peer中可以容纳的channel数，最大为255，最小为1。</td>
</tr>
<tr>
<td style="text-align:left"><strong>serviceTime</strong></td>
<td style="text-align:left">标记host当前时间的时间戳</td>
</tr>
<tr>
<td style="text-align:left"><strong>dispatchQueue</strong></td>
<td style="text-align:left">待处理的peer队列。当peer中有event产生时，则将peer放入dispatchQueue中。</td>
</tr>
<tr>
<td style="text-align:left"><strong>continueSending</strong></td>
<td style="text-align:left">用于标记peer中的数据是否发送完的变量。在发送peer中的数据时为保证公平性，则对peer进行轮询发送，每次至多发送一个数据量小于mtu udp数据报，如果peer中数据没有发送完，则将该变量置为1，在下次循环继续发送。</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetSize</strong></td>
<td style="text-align:left">用于标记当前待发送的udp数据报中数据的大小，在添加数据前如果<code>packetSize</code>大小大于mtu，则将<code>continueSending</code>置为1，跳出循环，将当前数据发送出去，等待下次循环中发送剩余数据。</td>
</tr>
<tr>
<td style="text-align:left"><strong>headerFlags</strong></td>
<td style="text-align:left">标记发送特性的一些flag，例如是否发送当前时间，是否需要压缩等。<code>host-&gt;headerFlags</code>会携带到发送数据报的头部中发送到peer端。</td>
</tr>
<tr>
<td style="text-align:left"><strong>commands</strong></td>
<td style="text-align:left">用于储存当前待发送udp数据报中的command</td>
</tr>
<tr>
<td style="text-align:left"><strong>commandCount</strong></td>
<td style="text-align:left">记录当前待发送udp数据报中的command的数量，如果需要发送的command的数量大于<code>ENET_PROTOCOL_MAXIMUM_PACKET_COMMANDS</code>，则将当前数据报发送出去，剩余数据等待下次循环发送。</td>
</tr>
<tr>
<td style="text-align:left"><strong>buffers</strong></td>
<td style="text-align:left">储存需要发送数据的buffer，用于传递给socket接口发送数据</td>
</tr>
<tr>
<td style="text-align:left"><strong>bufferCount</strong></td>
<td style="text-align:left">记录buffers中buffer的个数，同样传递给相应socke接口用于数据发送。最大值为<code>ENET_BUFFER_MAXIMUM</code>，如果buffers中buffer的个数大于该值，则先将当前数据报发送出去，剩余数据等待下次循环发送。</td>
</tr>
<tr>
<td style="text-align:left"><strong>checksum</strong></td>
<td style="text-align:left">计算校验和的回调函数，需要用户自己设置</td>
</tr>
<tr>
<td style="text-align:left"><strong>compressor</strong></td>
<td style="text-align:left">用于压缩和解压的结构变量，需要用户自己设置</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetData</strong></td>
<td style="text-align:left">一个二维数组，其中packetData[0]用于储存接收的数据，packetData[1]用于储存压缩后待发送的数据</td>
</tr>
<tr>
<td style="text-align:left"><strong>receivedAddress</strong></td>
<td style="text-align:left">接收数据的socket地址，host和port都设为0则意味接收任意地址的数据</td>
</tr>
<tr>
<td style="text-align:left"><strong>receivedData</strong></td>
<td style="text-align:left">用于标记当前读取到packetData[0]中位置的指针</td>
</tr>
<tr>
<td style="text-align:left"><strong>receivedDataLength</strong></td>
<td style="text-align:left">当前接收的数据的长度</td>
</tr>
<tr>
<td style="text-align:left"><strong>totalSentData</strong></td>
<td style="text-align:left">host发送出的总的数据量</td>
</tr>
<tr>
<td style="text-align:left"><strong>totalSentPackets</strong></td>
<td style="text-align:left">host发送出的总的udp数据报数</td>
</tr>
<tr>
<td style="text-align:left"><strong>totalReceivedData</strong></td>
<td style="text-align:left">host接收的总的数据量</td>
</tr>
<tr>
<td style="text-align:left"><strong>totalReceivedPackets</strong></td>
<td style="text-align:left">host接收的总的udp数据报数</td>
</tr>
<tr>
<td style="text-align:left"><strong>connectedPeers</strong></td>
<td style="text-align:left">当前连接的peer的数量</td>
</tr>
<tr>
<td style="text-align:left"><strong>bandwidthLimitedPeers</strong></td>
<td style="text-align:left">需要进行流量控制的peer的数量</td>
</tr>
<tr>
<td style="text-align:left"><strong>duplicatePeers</strong></td>
<td style="text-align:left">允许重复的ip的最大的peer的数量，默认值为<code>ENET_PROTOCOL_MAXIMUM_PEER_ID</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>maximumPacketSize</strong></td>
<td style="text-align:left">允许一个单个的<code>ENetPacket</code>发送和接收的最大的数据量</td>
</tr>
<tr>
<td style="text-align:left"><strong>maximumWaitingData</strong></td>
<td style="text-align:left">允许等待在buffer中的最大的数据量</td>
</tr>
</tbody>
</table>
<h2 id="ENetPeer"><a href="#ENetPeer" class="headerlink" title="ENetPeer"></a>ENetPeer</h2><p>用于储存通信对端的信息的数据结构，同时控制数据的发送，重传等操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetPeer</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">   ENetListNode  dispatchList;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">ENetHost</span> * <span class="title">host</span>;</span></span><br><span class="line">   enet_uint16   outgoingPeerID;</span><br><span class="line">   enet_uint16   incomingPeerID;</span><br><span class="line">   enet_uint32   connectID;</span><br><span class="line">   enet_uint8    outgoingSessionID;</span><br><span class="line">   enet_uint8    incomingSessionID;</span><br><span class="line">   ENetAddress   address;           </span><br><span class="line">   <span class="keyword">void</span> *        data;               </span><br><span class="line">   ENetPeerState state;</span><br><span class="line">   ENetChannel * channels;</span><br><span class="line">   <span class="keyword">size_t</span>        channelCount;       </span><br><span class="line">   enet_uint32   incomingBandwidth;  </span><br><span class="line">   enet_uint32   outgoingBandwidth;  </span><br><span class="line">   enet_uint32   incomingBandwidthThrottleEpoch;</span><br><span class="line">   enet_uint32   outgoingBandwidthThrottleEpoch;</span><br><span class="line">   enet_uint32   incomingDataTotal;</span><br><span class="line">   enet_uint32   outgoingDataTotal;</span><br><span class="line">   enet_uint32   lastSendTime;</span><br><span class="line">   enet_uint32   lastReceiveTime;</span><br><span class="line">   enet_uint32   nextTimeout;</span><br><span class="line">   enet_uint32   earliestTimeout;</span><br><span class="line">   enet_uint32   packetLossEpoch;</span><br><span class="line">   enet_uint32   packetsSent;</span><br><span class="line">   enet_uint32   packetsLost;</span><br><span class="line">   enet_uint32   packetLoss;         </span><br><span class="line">   enet_uint32   packetLossVariance;</span><br><span class="line">   enet_uint32   packetThrottle;</span><br><span class="line">   enet_uint32   packetThrottleLimit;</span><br><span class="line">   enet_uint32   packetThrottleCounter;</span><br><span class="line">   enet_uint32   packetThrottleEpoch;</span><br><span class="line">   enet_uint32   packetThrottleAcceleration;</span><br><span class="line">   enet_uint32   packetThrottleDeceleration;</span><br><span class="line">   enet_uint32   packetThrottleInterval;</span><br><span class="line">   enet_uint32   pingInterval;</span><br><span class="line">   enet_uint32   timeoutLimit;</span><br><span class="line">   enet_uint32   timeoutMinimum;</span><br><span class="line">   enet_uint32   timeoutMaximum;</span><br><span class="line">   enet_uint32   lastRoundTripTime;</span><br><span class="line">   enet_uint32   lowestRoundTripTime;</span><br><span class="line">   enet_uint32   lastRoundTripTimeVariance;</span><br><span class="line">   enet_uint32   highestRoundTripTimeVariance;</span><br><span class="line">   enet_uint32   roundTripTime;           </span><br><span class="line">   enet_uint32   roundTripTimeVariance;</span><br><span class="line">   enet_uint32   mtu;</span><br><span class="line">   enet_uint32   windowSize;</span><br><span class="line">   enet_uint32   reliableDataInTransit;</span><br><span class="line">   enet_uint16   outgoingReliableSequenceNumber;</span><br><span class="line">   ENetList      acknowledgements;</span><br><span class="line">   ENetList      sentReliableCommands;</span><br><span class="line">   ENetList      sentUnreliableCommands;</span><br><span class="line">   ENetList      outgoingReliableCommands;</span><br><span class="line">   ENetList      outgoingUnreliableCommands;</span><br><span class="line">   ENetList      dispatchedCommands;	</span><br><span class="line">   <span class="keyword">int</span>           needsDispatch;</span><br><span class="line">   enet_uint16   incomingUnsequencedGroup;</span><br><span class="line">   enet_uint16   outgoingUnsequencedGroup;</span><br><span class="line">   enet_uint32   unsequencedWindow [ENET_PEER_UNSEQUENCED_WINDOW_SIZE / <span class="number">32</span>]; </span><br><span class="line">   enet_uint32   eventData;</span><br><span class="line">   <span class="keyword">size_t</span>        totalWaitingData;</span><br><span class="line">&#125; ENetPeer;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">内部变量</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>dispatchList</strong></td>
<td style="text-align:left">在host中的<code>dispatchQueue</code>的链表节点。每当该peer产生一个event时，便将peer放入 <code>host-&gt;disptachQueue</code>中</td>
</tr>
<tr>
<td style="text-align:left"><strong>host</strong></td>
<td style="text-align:left">peer所在的host的指针</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingPeerID</strong></td>
<td style="text-align:left">对端<code>host-&gt;peers</code>中的peer的index</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingPeerID</strong></td>
<td style="text-align:left">peer在本地<code>host-&gt;peers</code>中的index</td>
</tr>
<tr>
<td style="text-align:left"><strong>connectID</strong></td>
<td style="text-align:left">在创建host时会生成一个随机数种子，每次请求新的连接时，会将随机数种子递增1产生 connectID。用于匹配收到的 verify connect 是否对应之前connect请求。当需要计算校验和时，connectID也参与校验和的计算。</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingSessionID</strong></td>
<td style="text-align:left">本地用于发送时封装protocol header的会话号，接收端在收到数据报时会将该 sessionid 取出与接收端的<code>peer-&gt;incomingSessionID</code>进行匹配。</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingSessionID</strong></td>
<td style="text-align:left">没到收到一个udp数据报时，会将protocol header中封装的session ID 取出与本地的<code>incomingSessionID</code>匹配，用于判断收到的数据报是否属于本次会话。</td>
</tr>
<tr>
<td style="text-align:left"><strong>address</strong></td>
<td style="text-align:left">该peer的socket地址</td>
</tr>
<tr>
<td style="text-align:left"><strong>state</strong></td>
<td style="text-align:left">peer当前的状态，例如已经连接，断开连接等。</td>
</tr>
<tr>
<td style="text-align:left"><strong>channels</strong></td>
<td style="text-align:left">peer用于发送数据的channel</td>
</tr>
<tr>
<td style="text-align:left"><strong>channelCount</strong></td>
<td style="text-align:left"><code>channels</code>的大小</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingBandwidth</strong></td>
<td style="text-align:left">该peer下载的带宽(字节/秒)</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingBandwidth</strong></td>
<td style="text-align:left">该peer上传的带宽(字节/秒)</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingBandwidthThrottleEpoch</strong></td>
<td style="text-align:left">在调节packetThrottle时用于记录调节该peer下载带宽的时间戳</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingBandwidthThrottleEpoch</strong></td>
<td style="text-align:left">在调节packetThrottle时用于记录调节该peer上传带宽的时间戳</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingDataTotal</strong></td>
<td style="text-align:left">记录在流量控制的间隔时间内从该peer接收的总的数据量的大小</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingDataTotal</strong></td>
<td style="text-align:left">记录在流量控制的间隔时间内向该peer发送的总的数据量的大小</td>
</tr>
<tr>
<td style="text-align:left"><strong>lastSendTime</strong></td>
<td style="text-align:left">记录上次发送数据包的时间戳</td>
</tr>
<tr>
<td style="text-align:left"><strong>lastReceiveTime</strong></td>
<td style="text-align:left">记录上次收到ack的时间，如果超过一定时间没有收到ack，则host会向该peer发送ping包用于判断该peer是否已经断开连接</td>
</tr>
<tr>
<td style="text-align:left"><strong>nextTimeout</strong></td>
<td style="text-align:left">下次有数据包超时的时间戳。在发送command和接收ack时会根据数据包的rto设置peer下次超时的时间戳。如果检测到当前时间戳大于该值，则调用<code>enet_protocol_check_timeouts</code>进行超时检测。</td>
</tr>
<tr>
<td style="text-align:left"><strong>earliestTimeout</strong></td>
<td style="text-align:left">记录当前时间段内的最早的超时时间。每当收到ack时会将<code>earliestTimeout</code>重置为0</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetThrottle</strong></td>
<td style="text-align:left">流量控制的阀门，通过该值进行流量控制，最大值为32，最小为1</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetThrottleLimit</strong></td>
<td style="text-align:left">在进行流量控制时会根据peer设置的带宽计算出该peer的<code>packetThrottle</code>的上限，确保数据的发送不会超过host的发送能力和peer的接收能力。<code>packetThrottle</code>的大小不会超过<code>packetThrottleLimit</code>的大小</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetThrottleCounter</strong></td>
<td style="text-align:left">在发送不可靠包时会根据<code>packekThrottleCounter</code>的值和<code>packetThrottle</code>的值判断是否会在发送前丢掉该不可靠包</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetThrottleEpoch</strong></td>
<td style="text-align:left">记录当前更新<code>lastRoundTripTime</code>,<code>lastRoundTripTimeVariance</code>,<code>lowestRoundTripTime</code>,<code>highestRoundTripTimeVariance</code>的时间戳，每隔<code>packetThrottleInterval</code>的时间间隔会刷新一次</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetThrottleAcceleration</strong></td>
<td style="text-align:left">每当收到rtt时用于增加<code>packetThrottle</code>的增量</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetThrottleDeceleration</strong></td>
<td style="text-align:left">每当收到rtt试用于减少<code>packetThrottle</code>的增量</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetThrottleInterval</strong></td>
<td style="text-align:left">流量控制中相应变量更新周期的大小</td>
</tr>
<tr>
<td style="text-align:left"><strong>pingInterval</strong></td>
<td style="text-align:left">如果超过<code>pingInterval</code>的时间没有收到ack，则向peer发送一个ping包，用于探测是否断开连接</td>
</tr>
<tr>
<td style="text-align:left"><strong>lastRoundTripTime</strong></td>
<td style="text-align:left">记录上个流量控制周期中最小的rtt</td>
</tr>
<tr>
<td style="text-align:left"><strong>lowestRoundTripTime</strong></td>
<td style="text-align:left">记录当前流量控制周期中最小的rtt</td>
</tr>
<tr>
<td style="text-align:left"><strong>lastRoundTripTimeVariance</strong></td>
<td style="text-align:left">记录上个流量控制周期中最大的rtt的变化值</td>
</tr>
<tr>
<td style="text-align:left"><strong>highestRoundTripTimeVariance</strong></td>
<td style="text-align:left">记录当前流量控制周期中最大的rtt的变化值</td>
</tr>
<tr>
<td style="text-align:left"><strong>roundTripTime</strong></td>
<td style="text-align:left">该peer当前平滑的rtt</td>
</tr>
<tr>
<td style="text-align:left"><strong>roundTripTimeVariance</strong></td>
<td style="text-align:left">该peer当前平滑的rtt的变化值</td>
</tr>
<tr>
<td style="text-align:left"><strong>mtu</strong></td>
<td style="text-align:left">该peer的最大传输单元，当需要发送的单个packet的大小超过该值时会进行分片操作</td>
</tr>
<tr>
<td style="text-align:left"><strong>reliableDataInTransit</strong></td>
<td style="text-align:left">正在传输过程中的可靠包的大小（已经发送但没有收到ack的），如果其值超过由<code>packetThrottle</code>计算出的发送窗口的大小，则暂停发送</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingReliableSequenceNumber</strong></td>
<td style="text-align:left">由peer发送的ENet的系统指令的当前的包的序号。所谓系统指令指connect，disconnect，ping等指令。而reliable，unreliable数据包会在channel中发送，用的是channel的序号。</td>
</tr>
<tr>
<td style="text-align:left"><strong>acknowledgements</strong></td>
<td style="text-align:left">等待发送ack的队列</td>
</tr>
<tr>
<td style="text-align:left"><strong>sentReliableCommands</strong></td>
<td style="text-align:left">已经发送reliable但是没收到ack的队列</td>
</tr>
<tr>
<td style="text-align:left"><strong>sentUnreliableCommands</strong></td>
<td style="text-align:left">已经发送的unreliable的队列</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingReliableCommands</strong></td>
<td style="text-align:left">等待发送reliable的队列</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingUnreliableCommands</strong></td>
<td style="text-align:left">等待发送unreliable的队列</td>
</tr>
<tr>
<td style="text-align:left"><strong>dispatchedCommands</strong></td>
<td style="text-align:left">已经收到的，等待用户处理的指令队列</td>
</tr>
<tr>
<td style="text-align:left"><strong>needsDispatch</strong></td>
<td style="text-align:left">是否需要用户处理，如果<code>dispatchedCommands</code>队列中有指令，则将该值置为1</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingUnsequencedGroup</strong></td>
<td style="text-align:left">peer记录的当前到来的unsequenced数据包的该group的头部的序号</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingUnsequencedGroup</strong></td>
<td style="text-align:left">发送的unsequenced数据包的序号</td>
</tr>
<tr>
<td style="text-align:left"><strong>unsequencedWindow</strong></td>
<td style="text-align:left">用位图的方式记录当前unsequenced group的数据包有没有重复</td>
</tr>
<tr>
<td style="text-align:left"><strong>totalWaitingData</strong></td>
<td style="text-align:left">ENet已经收到的但是用户还未处理的数据大小的总和</td>
</tr>
</tbody>
</table>
<h3 id="SessionID的作用"><a href="#SessionID的作用" class="headerlink" title="SessionID的作用"></a>SessionID的作用</h3><p>ENet使用简单的SessionID的匹配防止两个具有相同ip地址和端口号的前后两次连接发送的数据发生混淆。（这种情况是在断开连接后如果发起的新的连接的端口号和之前的端口号相同，在连接时会被判定为相同的连接，这时如果之前连接发送的网络包在网络中没有消逝并发送到对端，会与本次的连接发送的数据产生混淆。TCP使主动断开连接的一方处于<code>TIME_WAIT</code>的状态来防止这种情况的发生。）</p>
<p>在每次请求连接时，接收请求连接的一方会更新相应的session并返回给该peer，在第二次握手时请求连接方会同步该Session的数值。在每次发送数据时会将SessionID包含在<code>ENetProtocolHeader.peerID</code>中，接收端在每次收到UDP数据报时会首先检测protocol header中的session ID不匹配，则丢掉该数据报中的数据，表明该数据报不是本次连接中发送的数据。</p>
<p>因为仅仅时简单的ID匹配，所以并不能像TCP那样100%防止两次连接中数据包混淆这种情况的发生，但是大部分情况下仍是有效的。</p>
<h2 id="ENet-Channel"><a href="#ENet-Channel" class="headerlink" title="ENet Channel"></a>ENet Channel</h2><p>每个peer中会有多个Channel用于数据的发送，每个Channel发送和接收数据的过程和对command的编号彼此是独立的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetChannel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   enet_uint16  outgoingReliableSequenceNumber;</span><br><span class="line">   enet_uint16  outgoingUnreliableSequenceNumber;</span><br><span class="line">   enet_uint16  usedReliableWindows;</span><br><span class="line">   enet_uint16  reliableWindows [ENET_PEER_RELIABLE_WINDOWS];</span><br><span class="line">   enet_uint16  incomingReliableSequenceNumber;</span><br><span class="line">   enet_uint16  incomingUnreliableSequenceNumber;</span><br><span class="line">   ENetList     incomingReliableCommands;</span><br><span class="line">   ENetList     incomingUnreliableCommands;</span><br><span class="line">&#125; ENetChannel;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">内部变量</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>outgoingReliableSequenceNumber</strong></td>
<td style="text-align:left">channel中当前发送的可靠包的序号</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingUnreliableSequenceNumber</strong></td>
<td style="text-align:left">channel中当前发送的不可靠包的序号</td>
</tr>
<tr>
<td style="text-align:left"><strong>usedReliableWindows</strong></td>
<td style="text-align:left">用位图的方式记录已经使用的发送窗口的序号</td>
</tr>
<tr>
<td style="text-align:left"><strong>reliableWindows</strong></td>
<td style="text-align:left">每个发送窗口中已经发送但是还没有收到ack的指令的个数</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingReliableSequenceNumber</strong></td>
<td style="text-align:left">已经收到的可靠包的序号</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingUnreliableSequenceNumber</strong></td>
<td style="text-align:left">已经收到的不可靠包的序号</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingReliableCommands</strong></td>
<td style="text-align:left">已经收到的reliable数据包，等待有序排序后转到<code>peer-&gt;dispatchedCommands</code>队列中</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingUnreliableCommands</strong></td>
<td style="text-align:left">已经收到的unreliable的数据包，等待转到<code>peer-&gt;dispatchedCommands</code>队列中</td>
</tr>
</tbody>
</table>
<h3 id="关于reliableWindow"><a href="#关于reliableWindow" class="headerlink" title="关于reliableWindow"></a>关于reliableWindow</h3><p>由于ENet采用的是选择重传的方式，为保证新窗口与老窗口的序号没有重叠，窗口的最大尺寸不应该超过序号空间的一半。ENet在发送新的数据包时会通过<code>usedReliableWindows</code>判断当前窗口占用是否与空闲窗口重叠，如果重叠则暂停数据包的发送。<code>reliableWindows</code>会记录各个窗口中目前在传输中的包的个数。</p>
<h1 id="ENet-协议"><a href="#ENet-协议" class="headerlink" title="ENet 协议"></a>ENet 协议</h1><p>ENet发送数据时以一个udp数据报为单位，在发送时首先会在每个udp数据报的头部包含一个4个字节的<code>protocol header</code>表明当前数据报内的各个command由哪个peer发送和相应的发送时间。 在protocl header后会包含多个command。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                  |&lt;------------ command1 -----------&gt;|&lt;------------ command2 -----------&gt;|  </span><br><span class="line">-------------------------------------------------------------------------------------------------------</span><br><span class="line">| protocol Header | command1 header | command1 data   | command2 header | command2 data   |     ...</span><br><span class="line">-------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h2 id="协议头部-Protocol-Header"><a href="#协议头部-Protocol-Header" class="headerlink" title="协议头部 (Protocol Header)"></a>协议头部 (Protocol Header)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   enet_uint16 peerID;</span><br><span class="line">   enet_uint16 sentTime;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolHeader;</span><br></pre></td></tr></table></figure>
<p>Protocol Header是ENet整个协议的头部，由于ENet底层由UDP封装而成，在发送UDP数据报时该字段会放在整个UDP数据报的头部，用于标记该数据报的peer和发送时间。</p>
<p>与TCP的端对端连接不同，ENet可以是多对多的连接，所以需要<code>peerID</code>字段标记相应的peer。peerID的同步会在三次握手时同步完成。</p>
<blockquote>
<p>protocol header<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|&lt;------------ 4 bytes ------------&gt;|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|      peerID     |     sentTime    | </span><br><span class="line">+--------+--------+--------+--------+ </span><br><span class="line">|&lt;---------protocol header---------&gt;|</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="指令头部-Command-Header"><a href="#指令头部-Command-Header" class="headerlink" title="指令头部(Command Header)"></a>指令头部(Command Header)</h2><p>ENet中共有12种command，其中每个command会有一个相同的4个字节的command heaer，包含command每个command必须的信息：command类型，所在的channelID和该command的序列号。除去command header，每个command剩余的内容根据command类型而不同，所以ENet不同类型的command的大小是不同的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolCommandHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   enet_uint8 command;</span><br><span class="line">   enet_uint8 channelID;</span><br><span class="line">   enet_uint16 reliableSequenceNumber;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolCommandHeader;</span><br></pre></td></tr></table></figure>
<p>在每次发送的UDP的数据报中可能会包含多个指令(Command)，所以由每个指令的头部来标记该指令的信息，包括:</p>
<ul>
<li><strong>command</strong>: 指令类型</li>
<li><strong>channelID</strong>:该command的所在channel的序号</li>
<li><strong>reliableSequenceNumber</strong>:该指令在相应channel的序号</li>
</ul>
<p>每个指令对应固定的格式，所以根据<code>command</code>对应的指令类型，便可以得到该指令对应的长度。</p>
<blockquote>
<p>command header<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|&lt;-------------------- 4 bytes --------------------&gt;|</span><br><span class="line">+------------+------------+------------+------------+</span><br><span class="line">|   command  |  channelID | reliableSequenceNumber  | </span><br><span class="line">+------------+------------+------------+------------+ </span><br><span class="line">|&lt;------------------command header-----------------&gt;|</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="ENet-协议类型"><a href="#ENet-协议类型" class="headerlink" title="ENet 协议类型"></a>ENet 协议类型</h2><p>ENet共有12种协议类型，每种协议类型会对应一个<code>Command Number</code>。</p>
<p>协议类型定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _ENetProtocolCommand</span><br><span class="line">&#123;</span><br><span class="line">   ENET_PROTOCOL_COMMAND_NONE               = <span class="number">0</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_ACKNOWLEDGE        = <span class="number">1</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_CONNECT            = <span class="number">2</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_VERIFY_CONNECT     = <span class="number">3</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_DISCONNECT         = <span class="number">4</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_PING               = <span class="number">5</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_SEND_RELIABLE      = <span class="number">6</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE    = <span class="number">7</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_SEND_FRAGMENT      = <span class="number">8</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_SEND_UNSEQUENCED   = <span class="number">9</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_BANDWIDTH_LIMIT    = <span class="number">10</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_THROTTLE_CONFIGURE = <span class="number">11</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE_FRAGMENT = <span class="number">12</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_COUNT              = <span class="number">13</span>,</span><br><span class="line"></span><br><span class="line">   ENET_PROTOCOL_COMMAND_MASK               = <span class="number">0x0F</span></span><br><span class="line">&#125; ENetProtocolCommand;</span><br></pre></td></tr></table></figure></p>
<p>由于在协议中每个<code>Command Number</code>由一个字节储存，但是总共的协议号不超过16，所以4个bit便足够储存，剩下的4位bit ENet用于标记该Command的一些特性，例如是否需要排序，是否需要发送验证（Ack）等。</p>
<h3 id="Acknowledge指令"><a href="#Acknowledge指令" class="headerlink" title="Acknowledge指令"></a>Acknowledge指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolAcknowledge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint16 receivedReliableSequenceNumber;</span><br><span class="line">   enet_uint16 receivedSentTime;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolAcknowledge;</span><br><span class="line">```                                                                  </span><br><span class="line">Acknowledge是接收确认指令，在收到可靠包后需要向发送端发送Acknowledge指令来表明已经收到了相应的数据包。其中包含了：</span><br><span class="line">- **header**: 相应command的头部</span><br><span class="line">- **receivedReliableSequenceNumber**: 需要返回Ack的相应指令的序号（不是该Acknowledge的序号，而是其对应发送端发送的指令的序号）</span><br><span class="line">- **receivedSentTime**:其对应指令的发送时间，用于计算相应指令的rtt。</span><br><span class="line"></span><br><span class="line">对于每个`CommandHeader`中commnd参数带有`ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE`标记的command，接收端都会向发送端发送Ack指令。如果发送端在相应时间内没有收到Ack，则会重发该command，直到收到Ack。`ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE`的值是`<span class="number">1</span> &lt;&lt; <span class="number">7</span>`,占用commandNumber中空白位来标记该command是否需要重传。</span><br><span class="line"></span><br><span class="line">### Connect指令</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolConnect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint16 outgoingPeerID;</span><br><span class="line">   enet_uint8  incomingSessionID;</span><br><span class="line">   enet_uint8  outgoingSessionID;</span><br><span class="line">   enet_uint32 mtu;</span><br><span class="line">   enet_uint32 windowSize;</span><br><span class="line">   enet_uint32 channelCount;</span><br><span class="line">   enet_uint32 incomingBandwidth;</span><br><span class="line">   enet_uint32 outgoingBandwidth;</span><br><span class="line">   enet_uint32 packetThrottleInterval;</span><br><span class="line">   enet_uint32 packetThrottleAcceleration;</span><br><span class="line">   enet_uint32 packetThrottleDeceleration;</span><br><span class="line">   enet_uint32 connectID;</span><br><span class="line">   enet_uint32 data;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolConnect;</span><br></pre></td></tr></table></figure>
<p>connect指令用于主动发起连接的一端进行主动连接操作，其中包含的参数较多：</p>
<ul>
<li><strong>header</strong>: command的头部</li>
<li><strong>outgoingPeerID</strong>: 对应本地端的<code>ENetPeer.incomingPeerID</code>，后续通信通过该peerID访问<code>host-&gt;peers</code>中的相应的peer。</li>
<li><strong>incomingSessionID</strong>: 对应本地端的<code>ENetPeer.incomingSessionID</code>，本地用于匹配对端发送的Session ID，即每次收到该peer的UDP数据报时会与数据报中的Session ID的值进行匹配。</li>
<li><strong>outgoingSessionID</strong>: 对应本地端的<code>ENetPeer.outgoingSessionID</code>，本地用于发送时封装protocol header的会话号，接收端在收到数据报时会将该sessionid取出与接收端的<code>incomingSessionID</code>进行匹配。</li>
<li><strong>mtu</strong>:即最大传输单元。在发送数据大小大于mtu的packet时，ENet会在本地进行分片，并在接收端进行重组。</li>
<li><strong>windowSize</strong>: ENet发送窗口的大小，控制ENet在传输过程中的可靠包的数据量。每个peer会独立计算windowSize，在发送数据包时如果检测到正在传输的数据</li>
<li><strong>channelCount</strong>:channel的数量</li>
<li><strong>incominBandwidth</strong>: 对应本地的<code>host-&gt;incomingBandwidth</code>，即host的下载带宽。</li>
<li><strong>outgoingBandwidth</strong>: 对应本地的<code>host-&gt;outgoingBandwidth</code>，即host的上传带宽。</li>
<li><strong>packetThrottleInterval</strong>: 通过rtt对<code>packetThrottle</code>调节周期的设置。</li>
<li><strong>packetThrottleAcceleration</strong>：</li>
<li><strong>packetThrottleDeceleration</strong>：</li>
<li><strong>connectID</strong>：防止重复的连接（比如：connect 命令丢掉后重发）</li>
</ul>
<h3 id="Verify-Connet指令"><a href="#Verify-Connet指令" class="headerlink" title="Verify Connet指令"></a>Verify Connet指令</h3><p>verify Connect用于三次握手连接的第二次握手，同时用于主动连接方同步被动连接方的相关信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolVerifyConnect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint16 outgoingPeerID;</span><br><span class="line">   enet_uint8  incomingSessionID;</span><br><span class="line">   enet_uint8  outgoingSessionID;</span><br><span class="line">   enet_uint32 mtu;</span><br><span class="line">   enet_uint32 windowSize;</span><br><span class="line">   enet_uint32 channelCount;</span><br><span class="line">   enet_uint32 incomingBandwidth;</span><br><span class="line">   enet_uint32 outgoingBandwidth;</span><br><span class="line">   enet_uint32 packetThrottleInterval;</span><br><span class="line">   enet_uint32 packetThrottleAcceleration;</span><br><span class="line">   enet_uint32 packetThrottleDeceleration;</span><br><span class="line">   enet_uint32 connectID;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolVerifyConnect;</span><br></pre></td></tr></table></figure>
<p>其中参数基本和connect命令中的参数相同，不一一列举了。</p>
<h3 id="Protocol-Bandwidth-Limit指令"><a href="#Protocol-Bandwidth-Limit指令" class="headerlink" title="Protocol Bandwidth Limit指令"></a>Protocol Bandwidth Limit指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolBandwidthLimit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint32 incomingBandwidth;</span><br><span class="line">   enet_uint32 outgoingBandwidth;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolBandwidthLimit;</span><br></pre></td></tr></table></figure>
<p>Bandwidth Limit指令用于流量控制时调节对端对应本地的peer的带宽的相应的数值。</p>
<ul>
<li><strong>header</strong>: command的头部</li>
<li><strong>incomingBandwidth</strong>: 对应本地端的<code>host-&gt;incomingBandwidth</code>，设置对端的peer对应本地的host的下载带宽的数值。</li>
<li><strong>outgoingBandwidth</strong>: 对应本地端的<code>host-&gt;outgoingBandwidth</code>，设置对端的peer对应本地host的上行带宽的数值。</li>
</ul>
<h3 id="Throttle-Configure-指令"><a href="#Throttle-Configure-指令" class="headerlink" title="Throttle Configure 指令"></a>Throttle Configure 指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolThrottleConfigure</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint32 packetThrottleInterval;</span><br><span class="line">   enet_uint32 packetThrottleAcceleration;</span><br><span class="line">   enet_uint32 packetThrottleDeceleration;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolThrottleConfigure;</span><br></pre></td></tr></table></figure>
<p>Throttle Configure用于调节由rtt控制 packetThrottle的相关设置，关于packetThrottle的作用请看ENet流量控制相关章节。</p>
<ul>
<li><strong>header</strong>: command的头部</li>
<li><strong>packetThrottleInterval</strong>: peer调节rtt相关参数的周期</li>
<li><strong>packetThrottleAcceleration</strong>: 根据rtt调节packetThrottle的增加的速率</li>
<li><strong>packetThrottleDeceleration</strong>： 根据rtt调节packetThrottle的减小的速率</li>
</ul>
<h3 id="Disconnect-指令"><a href="#Disconnect-指令" class="headerlink" title="Disconnect 指令"></a>Disconnect 指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolDisconnect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint32 data;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolDisconnect;</span><br></pre></td></tr></table></figure>
<p>用于断开连接。</p>
<h3 id="Ping指令"><a href="#Ping指令" class="headerlink" title="Ping指令"></a>Ping指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolPing</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolPing;</span><br></pre></td></tr></table></figure>
<p>ENet当检测到超过一定的时间没有收到ack时便会发送ping指令以判断当前相连的peer是否已经断开连接。因为是探测指令，所以只发送指令头即可。</p>
<h3 id="Send-Reliable-指令"><a href="#Send-Reliable-指令" class="headerlink" title="Send Reliable 指令"></a>Send Reliable 指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolSendReliable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint16 dataLength;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolSendReliable;</span><br></pre></td></tr></table></figure>
<p>用于发送不用分片的可靠包的指令，在发送时，相应的data数据会跟在指令的后面。</p>
<ul>
<li><strong>header</strong>: 指令头部</li>
<li><strong>dataLength</strong>: 发送数据的长度</li>
</ul>
<h3 id="Send-Unreliable-指令"><a href="#Send-Unreliable-指令" class="headerlink" title="Send Unreliable 指令"></a>Send Unreliable 指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolSendUnreliable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint16 unreliableSequenceNumber;</span><br><span class="line">   enet_uint16 dataLength;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolSendUnreliable;</span><br></pre></td></tr></table></figure>
<p>发送不需要分片的Unreliable指令，与ENet unrealiable包的实现机制相关，不仅需要携带reliable sequence number，还需要携带unreliable sequence number。</p>
<ul>
<li><strong>unreliableSequeceNumber</strong>: 不可靠包的序号</li>
<li><strong>dataLength</strong>: 发送数据的长度</li>
</ul>
<h3 id="Send-Unsequenced指令"><a href="#Send-Unsequenced指令" class="headerlink" title="Send Unsequenced指令"></a>Send Unsequenced指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolSendUnsequenced</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint16 unsequencedGroup;</span><br><span class="line">   enet_uint16 dataLength;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolSendUnsequenced;</span><br></pre></td></tr></table></figure>
<p>发送不需要分片的Unsequenced指令，与reliable包和unreliable包的实现都不同，unsequenced不会用到header中的reliable sequence number，而是用相应的unsequencedGroup标记相应的序号。</p>
<ul>
<li><strong>unsequencedGroup</strong>: 用于标记unsequenced包的序号</li>
<li><strong>dataLength</strong>: 需要发送的数据的长度</li>
</ul>
<h3 id="Send-Fragment指令"><a href="#Send-Fragment指令" class="headerlink" title="Send Fragment指令"></a>Send Fragment指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolSendFragment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint16 startSequenceNumber;</span><br><span class="line">   enet_uint16 dataLength;</span><br><span class="line">   enet_uint32 fragmentCount;</span><br><span class="line">   enet_uint32 fragmentNumber;</span><br><span class="line">   enet_uint32 totalLength;</span><br><span class="line">   enet_uint32 fragmentOffset;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolSendFragment;</span><br></pre></td></tr></table></figure>
<p>fragment用于发送所有需要分片的数据包，通过flag标记相应包的类型，例如reliable和unreliable等。</p>
<ul>
<li><strong>startSequenceNumber</strong>: 被分片的数据包的开始的序号</li>
<li><strong>dataLength</strong>: 该分片携带的数据的长度</li>
<li><strong>fragmentCount</strong>: 总的分片的数量</li>
<li><strong>fragmentNumber</strong>: 该分片在所有分片中的序号，从0开始</li>
<li><strong>totalLength</strong>: 分片前的总的数据长度</li>
<li><strong>fragmentOffset</strong>: 该分片的起始位置在分片前的数据包中的偏移量</li>
</ul>
<h1 id="ENet数据包类型"><a href="#ENet数据包类型" class="headerlink" title="ENet数据包类型"></a>ENet数据包类型</h1><p>ENet中主要的数据包类型有：<strong>Reliable</strong>，<strong>Unreliable</strong>和<strong>Unsequenced</strong>和系统指令。</p>
<p>数据包的类型是通过commandheader中的command的携带的protocolFlag标记的。</p>
<p>由于command有8个字节，而ENet只有13种指令，只需要用到前4个bit，所以剩下的bit可以用来标记相应的数据包的类型，用于标记数据包的类型主要有两个flag：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE = (<span class="number">1</span> &lt;&lt; <span class="number">7</span>),</span><br><span class="line">ENET_PROTOCOL_COMMAND_FLAG_UNSEQUENCED = (<span class="number">1</span> &lt;&lt; <span class="number">6</span>),</span><br></pre></td></tr></table></figure></p>
<p>acknowledge和unsequenced。</p>
<p>如果标记unsequenced，则该数据包对应为unsequence数据包。<br>如果标记acknowledge，则对应reliable数据包，意味着需要对端返回ack指令。<br>如果都没有标记，则对应unreliable数据包。</p>
<p>系统指令一般是reliable的，如果标记了unsequenced，则会当成unsequenced处理，例如diconnectnow功能中的disconnect指令。</p>
<h2 id="系统指令"><a href="#系统指令" class="headerlink" title="系统指令"></a>系统指令</h2><p>系统指令包括有：<code>connect</code>,<code>verifyConnect</code>, <code>disconnect</code>, <code>ping</code>, <code>bandwidthLimit</code>, <code>throttleConfigure</code>。</p>
<p>系统指令所在的Channel是255，即不会占用peer中的任何一个channel。</p>
<p>系统指令一般都是需要对端发送ack的。</p>
<p>并且系统指令的发送不会受流量控制的限制，流量控制只是针对发送数据包的指令有效。</p>
<h2 id="Reliable数据包"><a href="#Reliable数据包" class="headerlink" title="Reliable数据包"></a>Reliable数据包</h2><p>如果相应命令标记了acknowledge，则会要求接收方收到后返回ack指令，如果没有收到ack，则会对数据包进行重传。如果重传次数超过一定的限制，则对该peer进行断开连接。</p>
<p>如果命令标记acknowledge的命令是<code>ENetProtocolSendReliable</code>和<code>ENetProtocolSendFragment</code>类型，接收方还会对指令进行排序。</p>
<p>对于<code>ENetProtocolSendReliable</code>则会对数据包进行排序，之后收到连续有序的数据包才会dispatch给用户。如果序号较大的数据包已经到达，而之前的数据包没有到达，ENet则会等待之前的数据包都到达以后，才会将相应的数据包发给用户。</p>
<p>对于<code>ENetProtocolSendFragment</code>类型的指令，接收方只有当分片中所有的数据包都收到后才会将数据dispatch给用户，如果有任何一个没有收到，则会等待至所有数据包都收到后。</p>
<p>reliable数据包的流量控制通过packetThrottle计算发送窗口大小实现，如果发现已经在传输中的reliable数据的量超过发送窗口大小，则会暂停对reliable数据包的传输，直到有空闲的发送窗口大小。</p>
<h2 id="Unreliable-数据包"><a href="#Unreliable-数据包" class="headerlink" title="Unreliable 数据包"></a>Unreliable 数据包</h2><p>对于Unreliable数据包，不会要求对端返回ack指令，同样会对数据包进行排序，但是与reliable数据包不同的是，如果后续的数据包已经到达，而之前的数据包则没有收到，则直接会将已经收到的数据包dispatch给用户，如果之前的数据包再次到达的话，则会直接丢弃。</p>
<p>并且Unreliable数据包的编号需要依赖reliable 序号，每次发送reliable数据包时，都会将unreliable数据包的编号重置为0开始传输。每个unreliable数据包会携带当前channel的reliable序号和unreliable序号。如果后续的reliable序号已经到达，则当前unreliable会被丢弃，如果后续的unreliable包到达，则当前unreliable序号同样会丢弃。</p>
<p>同时需要注意的一个细节是，ENet的每个数据包的sequence number的大小只有16位，也就是说最大序号只有65535，如果需要overflow的话，会从0开始重新统计。reliable包在进行接收的时候会判断当前的序号有没有已经overflow，但是对unreliable包确没有进行这种判断。</p>
<p>对于fragment的unreliable数据包，同样会等待所有分片都到达后才会将该数据包dispatch给用户，如果在处理分片的过程中，有该所有分片的后续序号的数据包到达，该分片中所有的数据包也会被丢弃。</p>
<p>unreliable数据包在进行流量控制的时候是通过packetThrottle计算一个数值在发送前进行概率性的随机丢弃的。如果packetThrottle是最大值，则不会丢弃，如果packetThrottle的值越小，则被丢弃的可能性越大。</p>
<h2 id="Unsequenced数据包"><a href="#Unsequenced数据包" class="headerlink" title="Unsequenced数据包"></a>Unsequenced数据包</h2><p>Unsequenced数据包同样是不会要求返回ack命令的，与unreliable不同的是，它不会依赖于reliable序号，也不会排序，对端只要收到，便会直接dispatch给用户。</p>
<p>unsequended数据包占用的队列其实是unreliable数据包的队列，所以流量控制也与unreliable数据包相同，会通过pakcetThrottle计算数值概率随机丢弃。</p>
<p>unsequenced数据包没有分片类型，如果需要分片，则会直接转成unreliable fragment发送。</p>
<h1 id="ENet整体流程框架"><a href="#ENet整体流程框架" class="headerlink" title="ENet整体流程框架"></a>ENet整体流程框架</h1><h2 id="收发数据过程"><a href="#收发数据过程" class="headerlink" title="收发数据过程"></a>收发数据过程</h2><p>ENet会在创建时建立一个<code>ENetHost</code>作为通信的客户端，host中包含与peer进行通信的socket，一个<code>ENetList dispatchQueue</code>：用于存放有事件产生的peer队列，和一个<code>ENetPeer* peers</code>数组用于存放与外部客户端通信的peer数据结构。</p>
<p>每个<code>ENetPeer</code>结构主要用于管理与外部的连接和数据发送，<code>ENetPeer</code>中用于数据发送的队列主要有5个：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ENetList      acknowledgements;</span><br><span class="line">ENetList      sentReliableCommands;</span><br><span class="line">ENetList      sentUnreliableCommands;</span><br><span class="line">ENetList      outgoingReliableCommands;</span><br><span class="line">ENetList      outgoingUnreliableCommands;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>acknowledgements</strong>: 用于发送ack</li>
<li><strong>sentReliableCommands</strong>: 用于储存已经发送的可靠包</li>
<li><strong>sentUnreliableCommands</strong>: 用于储存已经发送的不可靠包</li>
<li><strong>outgoingReliableCommands</strong>: 准备发送的可靠包队列</li>
<li><strong>outgpingUnreliableCommands</strong>: 准备发送的不可靠包队列</li>
</ul>
<p>其中需要ack的指令均由reliable队列管理，unreliable和unsequenced数据包均由unreliable队列管理。</p>
<p>在调用enet_peer_send函数时，会将需要发送的数据压入到outgoing队列中。而ack则是在收到可靠包时，将数据压入到<code>acknowledgements</code>队列中。</p>
<p>peer中还有一个队列：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENetList      dispatchedCommands;</span><br></pre></td></tr></table></figure></p>
<p>用于储存已经接收好准备dispatch给用户的数据。</p>
<p>每个<code>ENetPeer</code>中还有一个<code>ENetChannel</code>数组，<code>ENetChannel</code>主要用于接收对端发送回来的数据。</p>
<p><code>ENetChannel</code>中有两个队列：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENetList     incomingReliableCommands;</span><br><span class="line">ENetList     incomingUnreliableCommands;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>incomingRelibaleCommands</strong>: 用于储存已经收到的可靠数据包。</li>
<li><strong>incomingUnreliableCommands</strong>: 用于储存已经收到的不可靠数据包</li>
</ul>
<p>对数据的排序操作会在将其放进channel中的这两个incoming队列中进行，在channel中已经排序好的数据（reliable 数据包的话还需要保证序号连续）会放到peer的<code>dispatchedCommands</code>队列中，并且将peer放到host的<code>dispatchQueue</code>，当host下次处理时如果发现<code>dispatchQueue</code>中已经有peer存在，则会对其进行处理。如果没有，则会进入正常的收发包流程。</p>
<h2 id="host运行过程"><a href="#host运行过程" class="headerlink" title="host运行过程"></a>host运行过程</h2><p>host的主要运行通过一个<code>enet_host_service</code>函数，当有事件产生时，<code>enet_host_service</code>函数就会返回1，并将相应的event储存在传入的<code>ENetEvent</code>指针中，如果没有超过时间限制没有事件产生，则会返回0，出现错误时，<code>enet_host_service</code>会返回-1。</p>
<p><code>enet_host_service</code>的整体流程如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enet_protocol_dispatch_incoming_commands (host, event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    enet_host_bandwidth_throttle (host);</span><br><span class="line"></span><br><span class="line">    enet_protocol_send_outgoing_commands (host, event, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    enet_protocol_receive_incoming_commands (host, event);</span><br><span class="line"></span><br><span class="line">    enet_protocol_send_outgoing_commands (host, event, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    enet_protocol_dispatch_incoming_commands (host, event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        enet_socket_wait();</span><br><span class="line">    &#125;<span class="keyword">while</span></span><br><span class="line">&#125;<span class="keyword">while</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>enet_host_service</code>函数的每一个步骤中如果产生了Evnet，则直接返回。</p>
<p>首先会调用<code>protocol_dispatch_incoming_commands</code>函数查看当前是否存在待处理的事件，如果存在则直接返回。</p>
<p>否则进入循环，首先如果当前系统时间到达下次设置带宽限制的时间戳，则进行带宽限制。</p>
<p>然后发送相应的命令，<code>enet_protocol_send_outgoing_commands</code>会发送用户传入的数据和系统产生的指令。</p>
<p>随后调用<code>enet_protocol_receive_incoming_commands</code>从udp缓冲区中接收相应数据并处理。</p>
<p>随后再次调用<code>enet_protocol_send_outgoing_commands</code>发送相应数据</p>
<p>随后再次调用<code>enet_protocol_dispatch_incoming_commands</code>检测是否有事件产生，如果仍无事件产生，则进入<code>enet_socket_wait()</code>函数的循环</p>
<p><code>enet_socket_wait()</code>内部由select函数实现，用于监听socket读是否有相应，如果udp缓冲区中有数据到达，则重新进入上述循环，如果无数据，则等待用户传入的等待时间后退出。</p>
<h3 id="循环中两次调用send的原因"><a href="#循环中两次调用send的原因" class="headerlink" title="循环中两次调用send的原因"></a>循环中两次调用send的原因</h3><p>在调用<code>enet_protocol_receive_incoming_commands</code>函数后，如果接收到数据后会产生相应的ack指令，这是再次调用<code>enet_protocol_send_outgoing_commands</code>函数，则会立即将ack发送出去，不会像TCP那样捎带发送，减少了网络库对丢包的判断过程。</p>
<h1 id="ENet连接管理"><a href="#ENet连接管理" class="headerlink" title="ENet连接管理"></a>ENet连接管理</h1><h2 id="连接建立流程"><a href="#连接建立流程" class="headerlink" title="连接建立流程"></a>连接建立流程</h2><p>ENet在连接建立过程中同样需要三次握手，并且在建立连接的过程中改变peer的状态。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/61D4208945A14AACBFAC8C8244D5D633?method=download&amp;shareKey=a153c7cc67542b94fd4ca5db0a7a19f5" alt="ENet Connect"></p>
<p>首先两个host建立连接前需要保证peers数组内有空闲的peer(状态为disconnected)。</p>
<p>建立连接时，主动连接方首先找到一个状态为<code>disconnected</code>的peer，并向对端发送connect指令，并且将其状态变为<code>connecting</code>。</p>
<p>对端接收到connect指令后同样找到一个状态为<code>disconnected</code>的peer，并将其状态变为<code>acknowledgeing connect</code>，并返回一个verify connect指令。</p>
<p>主动连接方收到verify connect指令后，将其状态变为<code>connected</code>，意味着连接建立，并且向用户dispatch一个connect event事件，并返回ack指令。</p>
<p>对端接收到ack命令后，将其状态变为<code>connnected</code>，连接建立完成，并同样向用户dispatch一个connect event事件。</p>
<p>至此，双方连接建立完成。</p>
<h2 id="断开连接流程"><a href="#断开连接流程" class="headerlink" title="断开连接流程"></a>断开连接流程</h2><p>ENet提供了三种断开连接的方式：disconnect, disconneted now和disconnect later</p>
<h3 id="disconnect"><a href="#disconnect" class="headerlink" title="disconnect"></a>disconnect</h3><p><img src="https://note.youdao.com/yws/api/personal/file/628E534F2D974B4EA989C7A85C1AE7FC?method=download&amp;shareKey=b23593745ca476e3fa5e6744bde76abf" alt="ENet Disonnect"></p>
<p>断开连接时，主动断开连接的一方向对端发送disconnect指令，并把状态由<code>connected</code>变为<code>disconnecting</code>。</p>
<p>对端收到disconnect指令之后，将状态由<code>connected</code>变为<code>acknowledging disconnect</code>，并且返回ack指令，在发送完ack指令之后，将状态变为<code>zombie</code>状态，并将断开连接事件dispatch给用户之后，将状态由<code>zombie</code>变为<code>disconnected</code>。</p>
<p>主动连接方收到ack后，将状态由<code>disconnecting</code>变为<code>zombie</code>，将断开连接事件dispatch给用户之后，将状态由<code>zombie</code>变为<code>disconnected</code>。</p>
<h4 id="为什么要有acknowledging-disconnect状态"><a href="#为什么要有acknowledging-disconnect状态" class="headerlink" title="为什么要有acknowledging disconnect状态"></a>为什么要有acknowledging disconnect状态</h4><p>因为需要返回ack时，不能将peer状态设为<code>zombie</code>或者<code>disconnected</code>，因为在发送数据时，这两个状态的peer是被忽略的，所以需要设置一个状态，等待将ack发送出去之后，再将状态设置为<code>zombie</code>。</p>
<h4 id="为什么要有zombie状态"><a href="#为什么要有zombie状态" class="headerlink" title="为什么要有zombie状态"></a>为什么要有zombie状态</h4><p>因为需要将断开连接的事件返回给用户，<code>zombie</code>状态就是已经准备断开连接，但是还没断开连接时的状态，被标记为<code>zombie</code>状态的peer不会分配给新的连接，除非用户已经处理该事件。当用户已经收到断开连接的事件后，才会真正将该peer的状态从<code>zombie</code>变为<code>disconnected</code>。</p>
<h3 id="disconnect-later"><a href="#disconnect-later" class="headerlink" title="disconnect later"></a>disconnect later</h3><p>disconnect later会首先将该peer的状态改为<code>disconnect later</code>。状态为<code>disconnect later</code>的peer不会再添加新的数据，也不会处理已经到来的数据，当检测到将现有queue中的数据发送完后，则会发送disconnect命令，进入之前的断开连接流程。</p>
<h3 id="disconnect-now"><a href="#disconnect-now" class="headerlink" title="disconnect now"></a>disconnect now</h3><p><img src="https://note.youdao.com/yws/api/personal/file/D8987E62E0484750BE92D1423E27EF83?method=download&amp;shareKey=bdea1ac300e791babc51ec62feb5c94e" alt="ENet DisConnectNow"></p>
<p>与disconnect不同的是，发送方在调用disconnect_now函数之后，会将peer现有队列中的数据和一个unsequenced的disconnect发送给对端，并直接将状态变为<code>disconnceted</code>，并且不会dispatch event给用户。</p>
<p>对端在收到unsequenced的disconnect指令之后，会将状态变为<code>zombie</code>，在将断开连接事件<code>dispatch</code>给用户之后，将状态变为<code>disconnected</code>。</p>
<h1 id="ENet-数据的发送"><a href="#ENet-数据的发送" class="headerlink" title="ENet 数据的发送"></a>ENet 数据的发送</h1><p>ENet数据发送主要在<code>enet_protocol_send_outgoing_commands</code>函数中进行，该函数会将在outgoing queue中的command和packet调用socket接口发送出去。</p>
<p><code>enet_protocol_send_outgoing_commands</code>函数的大致流程为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(host-&gt;continueSending) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(peer in host-&gt;peers) &#123;</span><br><span class="line"></span><br><span class="line">        send_acknowldeges();</span><br><span class="line"></span><br><span class="line">        check_timeouts();</span><br><span class="line"></span><br><span class="line">        send_reliable_outgoing_commands();</span><br><span class="line"></span><br><span class="line">        send_unreliable_outgoing_commands();</span><br><span class="line"></span><br><span class="line">        enet_socket_send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ENet在发送时会遍历host中每个已经连接的peer，其中不同指令发送的顺序依次是：</p>
<ol>
<li>将ack放入host-&gt;buffers中</li>
<li>检测当前send reliable queue中的命令是否超时，如果超时则将其加到outgoing command的队列头部</li>
<li>将outgoing reliable queue中的命令放入host-&gt;buffers中</li>
<li>将outgoing unreliable queue中的命令放入host-&gt;buffers中（包括unreliable 和 unsequenced命令）</li>
<li>调用socket接口，将host-&gt;buffers中的数据用一个udp数据报发送出去</li>
</ol>
<p>ENet在发送时会保证发送的udp数据报的大小不会超过peer的mtu的大小，如果一个peer内的数据没有发送完，则会将<code>host-&gt;continueSending</code>置为1，意味着还需要继续发送，在下次遍历peer时将数据发送出去。</p>
<p>为保证公平性，不会因为单个peer的需要发送的数据量过大而影响其余peer数据的发送，所以每次对单个peer发送的数据量至多为mtu，如果仍有数据没有发送，则会在下次循环中继续发送，直到<code>host-&gt;contingueSending</code>不再被置为1。</p>
<h2 id="reliable数据包的发送"><a href="#reliable数据包的发送" class="headerlink" title="reliable数据包的发送"></a>reliable数据包的发送</h2><p>在发送reliable数据时，会检测三个条件：</p>
<ol>
<li>发送的数据的范围是否在滑动窗口的有效范围内（选择重传的方法要求发送中的序号不超过序号空间的一半）。</li>
<li>在传输中的数据总量的大小是否超过了发送窗口大小的限制。</li>
<li>host-&gt;buffers是否已经占满或者当前buffer中数据的大小是否超过mtu。</li>
</ol>
<p>如果上述条件均不满足，意味着可以向buffer中继续添加数据，则从<code>peer -&gt; outgoingReliableCommands</code>中将该command取出，放入buffer中，并将该command转移到<code>peer -&gt; sentReliableCommands</code>队列中。</p>
<p><code>peer -&gt; sentReliableCommands</code>会缓存已经发送的但是还没有收到ack的可靠包的command，在每次超时检测时，会检测<code>peer -&gt; sentReliableCommands</code>队列中的command是否已经超时，如果超时则会将该command重新放入到<code>peer -&gt; outgoingReliableCommands</code>队列的头部，在发送数据时将其重新发送。如果一个command的rto超过最大限制或者重传次数超过最大限制，则判定当前peer已经断开连接，进入断开连接流程。</p>
<p>每当收到ack时，会从<code>peer -&gt; sentReliableCommands</code>队列中将相应的command移除。</p>
<h2 id="unreliable数据报的发送"><a href="#unreliable数据报的发送" class="headerlink" title="unreliable数据报的发送"></a>unreliable数据报的发送</h2><p>在发送unreliable数据时，会首先检测两个条件：</p>
<ol>
<li>发送的数据的范围是否在滑动窗口的有效范围内</li>
<li>随机性丢弃一些数据。</li>
</ol>
<p>与reliable数据不同，unreliable不会缓存已经发送的数据，因为它们不需要ack，但是为了避免发送的数据超过peer的带宽限制，则根据带宽控制阀门计算出的随机数在发送前为了保证在传输的数据量不超过peer的带宽，将不可靠包根据<code>packetThrottle</code>的值进行概率随机丢弃。</p>
<p>在发送时同样会将已经发送的command从<code>peer -&gt; outgoingUnreliableCommands</code>放入<code>peer -&gt; sentUnreliableCommands</code>，在每次调用<code>enet_socket_send</code>函数将数据发送出去后则会立即清空<code>peer -&gt; sentUnreliableCommands</code>队列。</p>
<h3 id="不立即清空peer-gt-sentUnreliableCommands队列的原因"><a href="#不立即清空peer-gt-sentUnreliableCommands队列的原因" class="headerlink" title="不立即清空peer -&gt; sentUnreliableCommands队列的原因"></a>不立即清空<code>peer -&gt; sentUnreliableCommands</code>队列的原因</h3><p>host-&gt;buffers储存的内容不是真正意义的buffer，而是需要发送的数据的packet的指针。需要发送的数据的内容实际上仍在各个队列的command中存储，这样避免了数据拷贝的额外消耗。</p>
<p>如果直接将队列清空的话，在调用<code>enet_socket_send</code>发送时则会出现不可预知的错误，所以将<code>peer -&gt; sentUnreliableCommands</code>队列在调用socket接口发送后清空。</p>
<h1 id="ENet-数据的接收"><a href="#ENet-数据的接收" class="headerlink" title="ENet 数据的接收"></a>ENet 数据的接收</h1><p>ENet在创建host时将socket设置为非阻塞模式。在每次接收数据时至多接收256次UDP数据报，如果udp缓冲区中没有数据或者接收次数达到256次，则跳出接收循环，先将接收到的数据dispatch给用户。</p>
<p>接收数据在<code>enet_protocol_receive_incoming_commands</code>函数中进行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (packets = <span class="number">0</span>; packets &lt; <span class="number">256</span>; ++ packets)</span><br><span class="line">&#123;</span><br><span class="line">    receivedLength = enet_socket_receive ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (receivedLength &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (receivedLength == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   enet_protocol_handle_incoming_commands ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>enet_protocol_handle_incoming_commands</code>函数会对接收到的数据进行解析和处理。</p>
<p>在对数据进行解析和处理时，如果是系统指令，则直接对其进行相应的操作。如果是需要接收的数据类型的指令，例如send_reliable，send_unreliable指令，则需要对其进行排序，分片后的重组等操作。</p>
<h2 id="接收send-reliable指令"><a href="#接收send-reliable指令" class="headerlink" title="接收send reliable指令"></a>接收send reliable指令</h2><p>ENet在接收reliable指令时会首先将其按发送序号存放在<code>channel -&gt; incomingReliableCommands</code>队列中。首先需要在<code>channel -&gt; incomingReliableCommands</code>队列中查找到合适的位置，如果相应序号的指令已经存在，则将指令丢弃，如果不存在，则插入到队列中。</p>
<p>这里需要注意的时，由于ENet的序号只有16位，也就是最大只有65535，很容易发生越界。在进行插入的时候同样需要判断序号是否已经出现越界。</p>
<p>每次有新的数据包到来后，则会将<code>channel -&gt; incomingReliableCommands</code>队列中连续不中断的commands移动到<code>peer -&gt; dispatchedCommands</code>队列中，在下次调用<code>enet_host_service</code>函数时，该peer便会产生一个接收数据的事件，并将接收到的数据包返回给用户。</p>
<h2 id="接收send-unreliable指令"><a href="#接收send-unreliable指令" class="headerlink" title="接收send unreliable指令"></a>接收send unreliable指令</h2><p>unreliable指令的接收与reliable大致相似，同样会对数据包进行排序，不同的是，在将数据包从<code>channel -&gt; incomingUnreliableCommands</code>队列转移到<code>peer -&gt; dispatchedCommands</code>队列中时，不会保证数据包的连续性，如果序号较大的已经到了，而序号较小的没有到达，则直接将已经收到的数据包放入<code>peer -&gt; dispatchedCommands</code>队列中，如果后续较小序号的数据包到达的话，则直接丢弃。</p>
<p>还有一点不同的是，之前已经介绍到unreliable数据包的序号要依赖reliable数据包的序号，如果发送新的reliable数据包，则会将该peer中unreliable数据包的序号刷新。所以ENet默认unreliable序号不会超过65535的序号空间，也就没有对unreliable数据包的序号的越界情况进行考虑。</p>
<p>由于unsequenced指令同样放在unreliable队列中处理，如果有unsequenced的指令的话，则会直接放到<code>peer -&gt; dispatchedCommands</code>队列中。</p>
<h2 id="接收fragment指令"><a href="#接收fragment指令" class="headerlink" title="接收fragment指令"></a>接收fragment指令</h2><p>fragment分为reliable和unreliable两种类型。</p>
<p>在处理fragment指令时，会首先判断该分片组中的第一个分片是否已经在<code>channel -&gt; incomingReliableCommands</code>或者<code>channel -&gt; incomingUnreliableCommands</code>队列中。</p>
<p>如果已经到达，则将新到达的数据包的数据并入该第一个分片的command中，如果没有到达，则新建一个command，将其序号设置为分片组的start sequencenum，即第一个分片的序号，插入到<code>channel -&gt; incomingReliableCommands</code>或者<code>channel -&gt; incomingUnreliableCommands</code>队列中的合适位置，并将到达的command中的数据copy到该新建的command中。</p>
<p>在新建分片组第一个分片序号的command时，会同时建立一个位图，判断相应位置的command是否已经到达，如果相应分片已经全部到达，则调用dispatch函数将<code>channel -&gt; incomingReliableCommands</code>或者<code>channel -&gt; incomingUnreliableCommands</code>队列中的数据dispatch到<code>peer -&gt; dispatchedCommands</code>队列中。</p>
<p>如果fragment是unreliable类型的话，操作与reliable类型的command基本相同，不同的是在调用dispatch函数时，如果后续序号的command已经到达，则会将没有重组完全的分片组全部丢弃，而不会进行等待。</p>
<h1 id="ENet-RTT-和-RTO设置"><a href="#ENet-RTT-和-RTO设置" class="headerlink" title="ENet RTT 和 RTO设置"></a>ENet RTT 和 RTO设置</h1><h2 id="RTT运算过程"><a href="#RTT运算过程" class="headerlink" title="RTT运算过程"></a>RTT运算过程</h2><p>ENet在每次收到reliable包的acknowledge时，会对该peer的<code>roundTripTime</code>和<code>roundTripTimeVariance</code>进行更新。更新时并不是将该peer的<code>roundTripTime</code>设置为当前的rtt，而是根据当前的rtt和peer的<code>roundTripTime</code>的差值对<code>roundTripTime</code>和<code>roundTripTimeVariance</code>进行平滑的更新。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rtt_var_thistime = rtt_thistime - peer-&gt;rtt</span><br><span class="line">peer-&gt;rtt = rtt + rtt_var_thistime / <span class="number">8</span></span><br><span class="line">peer-&gt;rtt_var = peer-&gt;rtt_var * <span class="number">3</span>/<span class="number">4</span> + rtt_var_thistime / <span class="number">4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (peer -&gt; roundTripTime &lt; peer -&gt; lowestRoundTripTime)</span><br><span class="line">    peer -&gt; lowestRoundTripTime = peer -&gt; roundTripTime;</span><br><span class="line"><span class="keyword">if</span> (peer -&gt; roundTripTimeVariance &gt; peer -&gt; highestRoundTripTimeVariance) </span><br><span class="line">    peer -&gt; highestRoundTripTimeVariance = peer -&gt; roundTripTimeVariance;</span><br></pre></td></tr></table></figure>
<p>并根据<code>peer-&gt;rountTripTime</code>和<code>peer-&gt;roundTripTimeVariance</code>来更新<code>peer-&gt;lowestRoundTripTime</code>和<code>peer-&gt;highestRoundTripTimeVariance</code>这两个最值。</p>
<p><code>peer-&gt;lowestRoundTripTime</code>和<code>peer-&gt;highestRoundTripTimeVariance</code>它们在每个<code>packetThrottleInterval</code>时间间隔中会被重置为该peer的<code>peer-&gt;rountTripTime</code>和<code>peer-&gt;roundTripTimeVariance</code>当前的值。</p>
<p>这两个最值用于<code>enet_peer_throttle</code>函数中对<code>peer-&gt;packetThrottle</code>的调控和更新</p>
<h2 id="RTO的设置"><a href="#RTO的设置" class="headerlink" title="RTO的设置"></a>RTO的设置</h2><p>ENet在<code>enet_protocol_send_reliable_outgoing_commands</code>函数中每次发送相应可靠包时会为其设置rto，用于判断该包是否超时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command-&gt;rto = peer-&gt;rtt + <span class="number">4</span> * peer-&gt;rtt_var</span><br></pre></td></tr></table></figure>
<p>在<code>enet_protocol_check_timeouts</code>函数中每当检测到一个command超时后，会将其rto设置为原来的2倍，并重发该command。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command-&gt;rto *= <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>当一个command的<code>roundTripTimeout</code>大于该command的<code>rounTripTimeout</code>,并且host在相应时间内没有收到相应peer发送的command，则视为该peer已经断开连接，并进入断开连接的流程。</p>
<h1 id="ENet-流量控制"><a href="#ENet-流量控制" class="headerlink" title="ENet 流量控制"></a>ENet 流量控制</h1><p>ENet流量控制在创建host时，如果设置incomingBandWidth或者outgoingBandWidth为0，则将相应的流量控制关闭，否则则将其打开。</p>
<p>ENet的流量控制简单的通过一个packetThrottle变量实现，通过各个peer的带宽和相应时间内发送的数据量以及收发包的延迟对packetThrottle进行调控，从而达到控制发送数据量的目的。</p>
<p>对于可靠包的发送，ENet在发送数据前会根据padketThrottle计算一个发送窗口的大小，如果当前在传输过程中的数据量的大小超过了发送窗口的大小，则暂停数据的发送，直到发送窗口有足够的空间。</p>
<p>对于不可靠数据包，ENet在发送时会根据packetThrottle计算一个数值来随机丢弃相应的不可靠包，确保数据的发送不会超过peer的发送能力。</p>
<p>ENet流量控制分为两个部分：</p>
<ol>
<li>调节host端的发送能力，确保peer的download bandwidth足够承载host向其发送的数据。</li>
<li>调节peer端的发送能力，确保peer端发送的数据不会超过host端download bandwitdh的承载能力。</li>
</ol>
<h2 id="调节host端的发送"><a href="#调节host端的发送" class="headerlink" title="调节host端的发送"></a>调节host端的发送</h2><p>调节host的发送能力其实是通过对<code>peer-&gt;packetThrottle</code>的调节完成的，ENet在发送数据时，会通过<code>peer-&gt;packetThrottle</code>计算出一个windowSize(发送窗口大小)，如果检测到在发送中的数据的量大于<code>peer-&gt;packetThrottle</code>的话，则暂停发送，直到发送窗口大小有足够的空间。</p>
<p>对于<code>peer-&gt;packetThrottle</code>的调节又分为两个步骤：</p>
<ul>
<li>在每次收到ack时通过本次rtt对于之前rtt的变化对<code>peer-&gt;packetThrottle</code>进行调节</li>
<li>通过比较host的<code>outgoingBandwidth</code>和host在一定时间内发送的数据总量以及peer的<code>incomingBandwitdh</code>和相同时间内向该peer发送的数据量进行调节，确保host的发送不会超过peer的接收能力。</li>
</ul>
<p>如果未打开流量控制，则步骤2的调节可以忽略。</p>
<h3 id="通过rtt对packetThrottle进行调节"><a href="#通过rtt对packetThrottle进行调节" class="headerlink" title="通过rtt对packetThrottle进行调节"></a>通过rtt对packetThrottle进行调节</h3><p>在ENet收到reliable包的ack时，会根据本次的rtt和lasttime_rtt对该peer的<code>packetThrottle</code>进行调节。</p>
<p>具体过程在<code>enet_peer_throttle</code>函数中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enet_peer_throttle</span> <span class="params">(ENetPeer * peer, enet_uint32 rtt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (peer -&gt; lastRoundTripTime &lt;= peer -&gt; lastRoundTripTimeVariance)</span><br><span class="line">    &#123;</span><br><span class="line">        peer -&gt; packetThrottle = peer -&gt; packetThrottleLimit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rtt &lt; peer -&gt; lastRoundTripTime)</span><br><span class="line">    &#123;</span><br><span class="line">        peer -&gt; packetThrottle += peer -&gt; packetThrottleAcceleration;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (peer -&gt; packetThrottle &gt; peer -&gt; packetThrottleLimit)</span><br><span class="line">            peer -&gt; packetThrottle = peer -&gt; packetThrottleLimit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rtt &gt; peer -&gt; lastRoundTripTime + <span class="number">2</span> * peer -&gt; lastRoundTripTimeVariance)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (peer -&gt; packetThrottle &gt; peer -&gt; packetThrottleDeceleration)</span><br><span class="line">            peer -&gt; packetThrottle -= peer -&gt; packetThrottleDeceleration;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            peer -&gt; packetThrottle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于<code>peer-&gt;lastRoundTripTime</code>和<code>peer-&gt;lastRoundTripTimeVariance</code>的更新过程在函数<code>enet_protocol_handle_acknowledge</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (peer -&gt; packetThrottleEpoch == <span class="number">0</span> ||</span><br><span class="line">    ENET_TIME_DIFFERENCE (host -&gt; serviceTime, peer -&gt; packetThrottleEpoch) &gt;= peer -&gt; packetThrottleInterval)</span><br><span class="line">&#123;</span><br><span class="line">    peer -&gt; lastRoundTripTime = peer -&gt; lowestRoundTripTime;</span><br><span class="line">    peer -&gt; lastRoundTripTimeVariance = peer -&gt; highestRoundTripTimeVariance;</span><br><span class="line">    peer -&gt; lowestRoundTripTime = peer -&gt; roundTripTime;</span><br><span class="line">    peer -&gt; highestRoundTripTimeVariance = peer -&gt; roundTripTimeVariance;</span><br><span class="line">    peer -&gt; packetThrottleEpoch = host -&gt; serviceTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>peer-&gt;lastRoundTripTime</code>取得是上一个时间段内peer统计的rtt的最小值。而<code>peer-&gt;lastRountRripTimeVariance</code>取得是上一个时间段内rtt_var的最大值。并且每次更新后将peer中相应的<code>lowestRoundTripTime</code>和<code>highestRoundTripTimeVariance</code>重置为当前的值。</p>
<p>在enet_peer_throttle函数中，</p>
<ol>
<li>如果上个时间段中rtt的最小值小于rtt的变化的最大幅度，可以理解为rtt至少在上个时间段内变为原来的一半，则直接将<code>peer-&gt;pakcetThrottle</code>设置为其上限<code>peer-&gt;packetThrottleLimit</code>。</li>
<li>如果本次的rtt小于上个时间端内rtt的最小值，说明当前网络状况较好，则对该peer的<code>packetThrottle</code>进行相应的增加。</li>
<li>如果本次的rtt大于上次的rtt的最小值加上2倍的rtt变化的最大值，说明当前网络延时有所增加，当前网络的拥塞状况较差，则对该peer的<code>packetThrottle</code>进行相应的减少。</li>
</ol>
<h3 id="通过带宽和数据发送对packetThrottle进行调节"><a href="#通过带宽和数据发送对packetThrottle进行调节" class="headerlink" title="通过带宽和数据发送对packetThrottle进行调节"></a>通过带宽和数据发送对packetThrottle进行调节</h3><p>首先统计出距离上次流量调节的时间间隔内的host发送的数据总量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (host -&gt; outgoingBandwidth != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    dataTotal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bandwidth = (host -&gt; outgoingBandwidth * elapsedTime) / <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (peer = host -&gt; peers; peer &lt; &amp; host -&gt; peers [host -&gt; peerCount]; ++ peer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (peer -&gt; state != ENET_PEER_STATE_CONNECTED &amp;&amp; peer -&gt; state != ENET_PEER_STATE_DISCONNECT_LATER)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        dataTotal += peer -&gt; outgoingDataTotal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>elapsedTime</code>是距离上次流量控制的间隔时间。<br><code>bandwidth</code>可以理解为在该间隔时间内host发送数据的能力。<br><code>dataTotal</code>是在间隔时间内host向已连接的peer发送的数据的总量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (peersRemaining &gt; <span class="number">0</span> &amp;&amp; needsAdjustment != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    needsAdjustment = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dataTotal &lt;= bandwidth)</span><br><span class="line">        throttle = ENET_PEER_PACKET_THROTTLE_SCALE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        throttle = (bandwidth * ENET_PEER_PACKET_THROTTLE_SCALE) / dataTotal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (peer = host -&gt; peers; peer &lt; &amp; host -&gt; peers [host -&gt; peerCount]; ++ peer)</span><br><span class="line">    &#123;</span><br><span class="line">        enet_uint32 peerBandwidth;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((peer -&gt; state != ENET_PEER_STATE_CONNECTED &amp;&amp; </span><br><span class="line">            peer -&gt; state != ENET_PEER_STATE_DISCONNECT_LATER) ||	</span><br><span class="line">            peer -&gt; incomingBandwidth == <span class="number">0</span> ||						</span><br><span class="line">            peer -&gt; outgoingBandwidthThrottleEpoch == timeCurrent)	</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        peerBandwidth = (peer -&gt; incomingBandwidth * elapsedTime) / <span class="number">1000</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((throttle * peer -&gt; outgoingDataTotal) / ENET_PEER_PACKET_THROTTLE_SCALE &lt;= peerBandwidth)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        peer -&gt; packetThrottleLimit = (peerBandwidth *  ENET_PEER_PACKET_THROTTLE_SCALE) / peer -&gt; outgoingDataTotal;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (peer -&gt; packetThrottleLimit == <span class="number">0</span>)</span><br><span class="line">            peer -&gt; packetThrottleLimit = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (peer -&gt; packetThrottle &gt; peer -&gt; packetThrottleLimit)</span><br><span class="line">            peer -&gt; packetThrottle = peer -&gt; packetThrottleLimit;</span><br><span class="line"></span><br><span class="line">        peer -&gt; outgoingBandwidthThrottleEpoch = timeCurrent;</span><br><span class="line"></span><br><span class="line">        peer -&gt; incomingDataTotal = <span class="number">0</span>;</span><br><span class="line">        peer -&gt; outgoingDataTotal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        needsAdjustment = <span class="number">1</span>;</span><br><span class="line">        -- peersRemaining;</span><br><span class="line">        bandwidth -= peerBandwidth;</span><br><span class="line">        dataTotal -= peerBandwidth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (peersRemaining &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataTotal &lt;= bandwidth)</span><br><span class="line">        throttle = ENET_PEER_PACKET_THROTTLE_SCALE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        throttle = (bandwidth * ENET_PEER_PACKET_THROTTLE_SCALE) / dataTotal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (peer = host -&gt; peers; peer &lt; &amp; host -&gt; peers [host -&gt; peerCount]; ++ peer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((peer -&gt; state != ENET_PEER_STATE_CONNECTED &amp;&amp; </span><br><span class="line">            peer -&gt; state != ENET_PEER_STATE_DISCONNECT_LATER) ||</span><br><span class="line">            peer -&gt; outgoingBandwidthThrottleEpoch == timeCurrent)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        peer -&gt; packetThrottleLimit = throttle;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (peer -&gt; packetThrottle &gt; peer -&gt; packetThrottleLimit)</span><br><span class="line">            peer -&gt; packetThrottle = peer -&gt; packetThrottleLimit;</span><br><span class="line"></span><br><span class="line">        peer -&gt; incomingDataTotal = <span class="number">0</span>;</span><br><span class="line">        peer -&gt; outgoingDataTotal = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>throttle</code>是host的<code>bandwidth</code>和发送数据总量的比值的调节值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((throttle * peer -&gt; outgoingDataTotal) / ENET_PEER_PACKET_THROTTLE_SCALE &lt;= peerBandwidth)</span><br><span class="line">   <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<p>如果<code>peer-&gt;incomingBandWidth</code>/<code>peer-&gt;outgoingDataTotal</code>的比值大于throttle，意味着此时peer的带宽足够承载host对peer发送数据的速度，则暂时不予处理，否则则对<code>peer-&gt;packetThrottleLimit</code>进行调节。设置相应peer的<code>packetThrottleLimit</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer -&gt; packetThrottleLimit = (peerBandwidth * ENET_PEER_PACKET_THROTTLE_SCALE) / peer -&gt; outgoingDataTotal;</span><br></pre></td></tr></table></figure></p>
<p>ENet会保证<code>peer-&gt;packetThrottle</code>不超过<code>peer-&gt;packetThrottleLimit</code>。通过设置<code>packetThrottleLimit</code>保证发送数据时host向peer发送的数据量不会超过peer的<code>incomingBandwidth</code>。</p>
<p>对于之前没有设置的peer则统一将其<code>packetThrottle</code>设置为throttle。</p>
<h4 id="采用双层循环的原因"><a href="#采用双层循环的原因" class="headerlink" title="采用双层循环的原因"></a>采用双层循环的原因</h4><p>每次循环中会将 向peer发送数据量/peer的download bandwidth &lt; throttle的peer的<code>packetThrottleLimit</code>设置为其当前的值，并在bandwidth和dataTotal中减去相应的peerBandwidth，再下一次循环中计算出的throttle会比上一次计算得出的throttle跟更高。如果只是单次循环并将剩下的peer的<code>packetThrottleLimit</code>设置为当前的throttle，会<br>对peer的incomingBandwidth造成浪费。</p>
<h4 id="最后统一设置为thtottle原因"><a href="#最后统一设置为thtottle原因" class="headerlink" title="最后统一设置为thtottle原因"></a>最后统一设置为thtottle原因</h4><p>为保证平均高效的利用host的带宽，虽然剩余的peer的<code>incomingBandwidth</code>足够承载host的发送的数据，但是host在发送数据时也需要考虑到host总的<code>outgoingBandwidth</code>，所以将剩下的peer的<code>pakcetThrottleLimit</code>设置为throttle，防止单个peer发送数据过多占满host的upload bandwidth。</p>
<h2 id="调节peer端的发送"><a href="#调节peer端的发送" class="headerlink" title="调节peer端的发送"></a>调节peer端的发送</h2><p>每当ENet中有peer连接或者断开连接时，会将<code>ENetHost-&gt;recalculateBandwidthLimits</code>结构变量置为1，在下次<code>enet_host_service</code>函数中调用<code>enet_host_bandwidth_throttle</code>时会进行该项的流量控制。</p>
<p>调节peer端发送能力，通过向该peer发送<code>ENetProtocolBandwidthLimit</code>指令实现。其中</p>
<ul>
<li><code>ENetProtocolBandwidthLimit.outgoingBandwidth</code>简单的对应<code>host -&gt; outgoingBandwidth</code></li>
<li><code>ENetProtocolBandwidthLimit.incomingBandwidth</code>则是host端对该peer调节后的bandwidthLimit</li>
</ul>
<p>host通过向peer发送<code>ENetProtocolBandwidthLimit</code>指令设置client端对应host的peer的<code>incomingBandwidth</code>，进而client端通过<code>incomingBandwidth</code>调节对应host的peer中的<code>packetThrottleLimit</code>和<code>packetThrottle</code>来控制对host流量传输。</p>
<p>具体调节流程可以看如下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">host -&gt; recalculateBandwidthLimits = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">peersRemaining = (enet_uint32) host -&gt; connectedPeers;</span><br><span class="line">bandwidth = host -&gt; incomingBandwidth;</span><br><span class="line">needsAdjustment = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bandwidth == <span class="number">0</span>)</span><br><span class="line">    bandwidthLimit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (peersRemaining &gt; <span class="number">0</span> &amp;&amp; needsAdjustment != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    needsAdjustment = <span class="number">0</span>;</span><br><span class="line">    bandwidthLimit = bandwidth / peersRemaining;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (peer = host -&gt; peers; peer &lt; &amp; host -&gt; peers [host -&gt; peerCount]; ++ peer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((peer -&gt; state != ENET_PEER_STATE_CONNECTED &amp;&amp; </span><br><span class="line">            peer -&gt; state != ENET_PEER_STATE_DISCONNECT_LATER) ||	</span><br><span class="line">            peer -&gt; incomingBandwidthThrottleEpoch == timeCurrent)	</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (peer -&gt; outgoingBandwidth &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            peer -&gt; outgoingBandwidth &gt;= bandwidthLimit)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        peer -&gt; incomingBandwidthThrottleEpoch = timeCurrent;</span><br><span class="line"></span><br><span class="line">        needsAdjustment = <span class="number">1</span>;</span><br><span class="line">        -- peersRemaining;</span><br><span class="line">        bandwidth -= peer -&gt; outgoingBandwidth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (peer = host -&gt; peers; peer &lt; &amp; host -&gt; peers [host -&gt; peerCount];  ++ peer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (peer -&gt; state != ENET_PEER_STATE_CONNECTED &amp;&amp; peer -&gt; state != ENET_PEER_STATE_DISCONNECT_LATER)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    command.header.command = ENET_PROTOCOL_COMMAND_BANDWIDTH_LIMIT | ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE;</span><br><span class="line">    command.header.channelID = <span class="number">0xFF</span>;	</span><br><span class="line">    command.bandwidthLimit.outgoingBandwidth = ENET_HOST_TO_NET_32 (host -&gt; outgoingBandwidth);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (peer -&gt; incomingBandwidthThrottleEpoch == timeCurrent)</span><br><span class="line">        command.bandwidthLimit.incomingBandwidth = ENET_HOST_TO_NET_32 (peer -&gt; outgoingBandwidth);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        command.bandwidthLimit.incomingBandwidth = ENET_HOST_TO_NET_32 (bandwidthLimit);</span><br><span class="line"></span><br><span class="line">    enet_peer_queue_outgoing_command (peer, &amp; command, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>peersRemaining</code>指与host已经连接的peer的数量。<br><code>bandwidth</code>指host的download bandwidth的大(incomingBandwidth)。</p>
<p>如果host端未开启流量控制，即<code>host -&gt; incomingBandwidth</code>的值为0，则设置bandwidthLimit为0。</p>
<p>否则通过双层循环对带宽限制进行调节。</p>
<p>每次while循环会重新计算<code>bandwidthLimit</code>，并将不需要带宽限制的peer或者发送能力小于<code>bandwidthLimit</code>的peer标记出来。在接下来发送<code>ENetProtocolBandwidthLimit</code>指令时则将其中的<code>incomingBandwidth</code>设置为<code>peer-&gt;outgoingBandwidth</code>，即不用改变。对于发送能力大于<code>bandwidthLimit</code>的peer，则将相应的<code>ENetProtocolBandwidthLimit</code>指令中的<code>incomingBandwidth</code>设置为bandwidthlimit。</p>
<h3 id="关于用双层循环的原因"><a href="#关于用双层循环的原因" class="headerlink" title="关于用双层循环的原因"></a>关于用双层循环的原因</h3><p>如果第一次循环将所有发送能力大于<code>bandwidthLimit</code>的peer都设置为<code>bandwidthLimit</code>而对于那些发送能力小的则不改变的话，host的<code>incomingBandwidth</code>其实是没有使用完的，会造成浪费。</p>
<p>在每次for循环中将发送发送能力小于<code>bandwidthLimit</code>的peer剔除之后，重新计算的<code>bandwidthLimit</code>会增大，意味着host的<code>incomingBandwidth</code>可以承载更多的带宽，低于该值的peer都是不用调节的，这样可以更加充分的利用host的带宽，而不造成浪费。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/05/12/记一次闹心的网络调试经历/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/12/记一次闹心的网络调试经历/" class="post-title-link" itemprop="url">记一次闹心的网络调试经经历</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-12 20:26:19" itemprop="dateCreated datePublished" datetime="2018-05-12T20:26:19+08:00">2018-05-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-02 11:28:18" itemprop="dateModified" datetime="2019-08-02T11:28:18+08:00">2019-08-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Personal-Journal/" itemprop="url" rel="index"><span itemprop="name">Personal Journal</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前为测试下自己毕业设计实现的网络库，手边没有两台电脑，所以就打算在本机测试实现，方法是通过修改本极路由表，让发向本地ip的网络包不直接通过回环端口，而是先发送到网关，在通过网关返回回来，这样通过丢包模拟软件设置本地网卡的丢包率和延时便可以模拟真实网络环境的波动，进而进行测试。</p>
<p>环境是：<code>Windows 10</code>，丢包模拟软件是：<code>Network Emulator Client</code></p>
<p>修改本地路由表的命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add [本地ip] mask 255.255.255.255 [网关ip]</span><br></pre></td></tr></table></figure></p>
<h2 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h2><p>这种方法首先在公司是可行的，可是回到自己住的地方后，再通过这种方法发现发向本地ip的UDP包无法收到，ping本地ip测试之后，返回的是这个结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reply from 192.168.31.1: Destination port unreachable.</span><br></pre></td></tr></table></figure></p>
<p>目标端口不可达，这就非常奇怪了。</p>
<p>一开始以为是本机防火墙的锅，但是修改了win10防火墙各种参数之后还是没有效果。</p>
<p>并且通过测试可以发现，同一子网下的不同的两台主机之间是可以ping通的，所以不存在路由器找不到mac地址的问题，既然能找到mac地址，很有可能是路由器把这个包丢掉了。</p>
<h2 id="解决尝试"><a href="#解决尝试" class="headerlink" title="解决尝试"></a>解决尝试</h2><p>既然是路由器的问题，一种方法是直接将路由器去掉，把网线直接插到网口上面，这样直接在上层的子网内尝试向本机ip发包，然后这次问题变成了超时，由于房间内网线上层连接的是2层交换机，交换机会进行什么样的操作就无法干预了，退回到路由器的问题。</p>
<h2 id="远程连接路由器"><a href="#远程连接路由器" class="headerlink" title="远程连接路由器"></a>远程连接路由器</h2><p>路由器管理员界面是没有提供发包调试的功能，也没有命令行页面的，仅仅通过管理员界面是无法对路由表和防火墙进行操作的，没办法，先试着远程链接下路由器。</p>
<p>由于我的路由器的型号是小米路由器3，通过查阅资料发现，要远程连接路由器首先需要将路由器刷机到开发版，然后给路由器装上ssh，这样就可以远程连接了。</p>
<p>然后就去重官网上下载了小米路由器3开发版的最新版，尝试了几次之后给路由器成功刷成了开发者版本。</p>
<p>发现安装ssh要通过u盘进行操作，然后先去找室友借到了u盘，下好ssh文件，插到路由器上后，重启，尝试连接，没有反应。</p>
<p>这样反复几次之后，突然意识到u盘需要时fat32格式的，借到的u盘太大，无法格式化为fat32格式，只能是NTFS和EXFAT格式，因为FAT32最好的支持是小于32g的U盘，太大的U盘格式化便没了这个选项。</p>
<p>没办法，费劲心力找到了一个8g的小U盘，格式化为FAT32格式的，插入路由器，安装，OK，重启，尝试连接，成功！</p>
<h2 id="远程路由器"><a href="#远程路由器" class="headerlink" title="远程路由器"></a>远程路由器</h2><p>不得不说小米是骚气，路由器登陆界面竟然是这个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> -----------------------------------------------------</span><br><span class="line">       Welcome to XiaoQiang!</span><br><span class="line"> -----------------------------------------------------</span><br><span class="line">  $$$$$$\  $$$$$$$\  $$$$$$$$\      $$\      $$\        $$$$$$\  $$\   $$\</span><br><span class="line"> $$  __$$\ $$  __$$\ $$  _____|     $$ |     $$ |      $$  __$$\ $$ | $$  |</span><br><span class="line"> $$ /  $$ |$$ |  $$ |$$ |           $$ |     $$ |      $$ /  $$ |$$ |$$  /</span><br><span class="line"> $$$$$$$$ |$$$$$$$  |$$$$$\         $$ |     $$ |      $$ |  $$ |$$$$$  /</span><br><span class="line"> $$  __$$ |$$  __$$&lt; $$  __|        $$ |     $$ |      $$ |  $$ |$$  $$&lt;</span><br><span class="line"> $$ |  $$ |$$ |  $$ |$$ |           $$ |     $$ |      $$ |  $$ |$$ |\$$\</span><br><span class="line"> $$ |  $$ |$$ |  $$ |$$$$$$$$\       $$$$$$$$$  |       $$$$$$  |$$ | \$$\</span><br><span class="line"> \__|  \__|\__|  \__|\________|      \_________/        \______/ \__|  \__|</span><br><span class="line">root@XiaoQiang:~#</span><br></pre></td></tr></table></figure></p>
<p>不知道雷布斯同学看了后是什么反应，= =。</p>
<p>终于登陆到路由器了，然后下一步该干嘛呢 0.0</p>
<p>先看一下路由器的路由表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@XiaoQiang:~# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0.2</span><br><span class="line">192.168.31.0    0.0.0.0         255.255.255.0   U     0      0        0 br-lan</span><br><span class="line">###.###.##.#    0.0.0.0         255.255.255.0   U     0      0        0 wl2</span><br><span class="line">0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 eth0.2</span><br><span class="line">0.0.0.0         192.168.1.1     0.0.0.0         UG    50     0        0 eth0.2</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>个人外网的ip地址处于安全问题就先用#代替了</p>
</blockquote>
<p>小米路由器的内网网关是192.168.31.1，掩码是 255.255.255.0，个人主机的ip地址是192.168.31.233。对应的规则是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.31.0    0.0.0.0         255.255.255.0   U     0      0        0 br-lan</span><br></pre></td></tr></table></figure></p>
<p>好像并没有什么问题，发向192.168.31.0的子网的包会通过自己转发出去。</p>
<p>难道是路由器防火墙的问题？</p>
<h2 id="坑爹的路由器防火墙"><a href="#坑爹的路由器防火墙" class="headerlink" title="坑爹的路由器防火墙"></a>坑爹的路由器防火墙</h2><p>尝试下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/firewall stop</span><br></pre></td></tr></table></figure></p>
<p>关掉了路由器的防火墙，重新向本地ip用Ping命令测试，居然成功了！！！！！</p>
<p>OK，果然是这个坑爹的路由器防火墙把发向源ip和目的ip相同的包给拒了。</p>
<p>但是····QAQ，把防火墙关了之后，坑爹的网居然被断了，只能子网内自己发发包玩下，包发不出去了= =，坑爹的，实在是没精力去学习路由器防火墙规则了，先这样把，测试的时候先把路由器防火墙关了，不用的时候再打开= =，非常郁闷了。</p>
<p>不过花了三个晚上找到了问题还是很开心的。</p>
<p>把这个问题放在这边，希望大家不要再踩这个坑了，测试还是用两台主机去测试吧。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/03/01/UDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/03/01/UDP/" class="post-title-link" itemprop="url">UDP</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-03-01 17:11:24" itemprop="dateCreated datePublished" datetime="2018-03-01T17:11:24+08:00">2018-03-01</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-02 11:28:18" itemprop="dateModified" datetime="2019-08-02T11:28:18+08:00">2019-08-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Unix-Network-Programming/" itemprop="url" rel="index"><span itemprop="name">Unix Network Programming</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>UDP是无连接不可靠的数据报协议，使用UDP编写的一些常见的应用程序有：DNS（域名系统），NFS（网络文件系统）和SNMP（简单网络管理协议）。</p>
<h2 id="UDP客户-服务器程序所有套接字函数"><a href="#UDP客户-服务器程序所有套接字函数" class="headerlink" title="UDP客户/服务器程序所有套接字函数"></a>UDP客户/服务器程序所有套接字函数</h2><p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/UDP%20socket%20function.JPG" alt="image"></p>
<h2 id="recvfrom-和-sendto-函数"><a href="#recvfrom-和-sendto-函数" class="headerlink" title="recvfrom 和 sendto 函数"></a>recvfrom 和 sendto 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, struct sockaddr* from, <span class="keyword">socklen_t</span>* addrlen);</span><br><span class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr *to, <span class="keyword">socklen_t</span> addrlen);</span><br></pre></td></tr></table></figure>
<p>前三个参数sockfd、buff和nbytes等同于read和write函数的三个参数：描述符、指向读入或写出缓冲区的指针和读写字节数。</p>
<p>sendto的to参数指向一个含有数据报接收者的协议地址的套接字地址结构，其大小由addrlen参数指定。recvfrom的from参数指向一个将由该函数在返回时填写数据报发送者的协议地址的套接字结构，而在该套接字地址结构中填写的字节数则放在addrlen参数所指向的整数中返回给调用者。</p>
<p>注意:sendto的最后一个参数是一个整数值，而recvfrom的最后一个参数是一个指向整数的指针。</p>
<p>则两个函数都把所读写数据的长度作为函数返回值。在recvfrom使用数据报协议的典型用途中，返回值就是所接收数据报中的用户数据量。</p>
<p>写一个长度为0的数据报是可行的。在UDP情况下，这会形成一个只包含IP首部和一个8字节UDP首部而没有数据的IP数据报。对于数据报协议，recvfrom返回0是可以接受的：它并不像TCP套接字上read返回0值那样表示对端已关闭连接。既然UDP是无连接的，因此也就没有诸如关闭一个UDP连接之类的事情。</p>
<p>对于一个UDP套接字，如果进程首次调用sendto时它没有绑定一个本地端口，那么内核就在此时为它选择一个临时端口。同TCP一样，客户也可以显示地调用bind，不过很少这样做。</p>
<h2 id="接收缓冲区"><a href="#接收缓冲区" class="headerlink" title="接收缓冲区"></a>接收缓冲区</h2><p>每个UDP套接字都有一个接受缓冲区，到达该套接字的每个数据报都进入这个套接字的接收缓冲区。当进程调用recvfrom时，接收缓冲区中的下一个数据报以FIFO的顺序返回给进程。</p>
<p>在进程能够取该套接字中任何已排好队的数据报之前，如果有多个数据报达到该套接字，那么相继到达的数据报仅仅加到该套接字的接收缓冲区中。然而这个缓冲区的大小是有限的。</p>
<h2 id="UDP-从客户端和服务端角度"><a href="#UDP-从客户端和服务端角度" class="headerlink" title="UDP 从客户端和服务端角度"></a>UDP 从客户端和服务端角度</h2><p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/UDP%20in%20clinet.JPG" alt="image"></p>
<p>客户端必须给sendto调用指定服务器地IP地址和端口号。一般来说，客户端地IP地址和端口号均由内核自动选择。</p>
<p>客户端地临时端口是在第一次调用sendto时一次性选定，不能改变；然而客户地IP地址却可以随客户端发送地每个UDP数据报而变动。</p>
<p>如果客户端捆绑了一个IP地址到其套接字上，但是内核决定外出数据报必须从另一个数据链路发出，这种情形下，IP数据报将包含一个不同于外出链路IP地址地源IP地址。</p>
<p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/UDP%20in%20server.JPG" alt="image"></p>
<p>UDP套接字目的IP地址只能通过为IPv4设置IP_RECVDSTADDR套接字选项（或为IPv6设置IPV6_PKTINFO套接字选项）然后调用recvmsg（而不是recvfrom）取得。</p>
<p>由于UDP是无连接地，因此目的IP地址可随发送到服务器地每个数据报而改变。UDP服务器也可接收目的服务器主机地某个广播地址或多播地址地数据报。</p>
<h2 id="UDP-connect函数"><a href="#UDP-connect函数" class="headerlink" title="UDP connect函数"></a>UDP connect函数</h2><p>对于一个UDP套接字，由它引发地异步错误并不返回给它，除非它已连接。</p>
<p>UDP调用connect，内核只是检查是否存在立即可知的错误，记录对端的IP地址和端口号，然后立即返回到调用进程。</p>
<p>对于已连接UDP套接字与默认的未连接UDP套接字相比，发生了三个变化：</p>
<ol>
<li>不能该输出操作指定目的IP地址和端口号。也就是说，我们不使用sendto，而改用write或send。写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址。（其实sendto也可以用，但是不能指定目的地址，snedto的第五个参数必须为空指针，第六个参数为0）。</li>
<li>不必使用recvfrom获悉数据报的发送者，而改用read、recv或recvmsg。在一个已连接UDP套接字上，由内核为输入操作返回的数据报只有那些来自connect所指定协议地址的数据报。目的地为这个已连接UDP套接字的本地协议地址，发源地却不是该套接字早先connect到的协议地址的数据报，不会投递到该套接字。这样就限制一个已连接UDP套接字能且仅能与一个对端交换数据报。</li>
<li>由已连接UDP套接字引发的异步错误会返回给他们所在的进程，而未连接UDP套接字不会接收任何异步错误。</li>
</ol>
<h3 id="给一个UDP套接字多次调用-connect"><a href="#给一个UDP套接字多次调用-connect" class="headerlink" title="给一个UDP套接字多次调用 connect"></a>给一个UDP套接字多次调用 connect</h3><ol>
<li>指定新的ip地址和端口号</li>
<li>断开套接字</li>
</ol>
<p>给一个已连接的UDP套接字指定新的对端不同于TCP套接字中connect的使用：对于TCP套接字，connect只能调用一次。</p>
<p>为了断开一个已连接UDP套接字，再次调用connect时把套接字地址结构的地址族改成员设置为AF_UNSPEC。这么做可能返回一个EAFNOSUPPORT错误。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>当应用进程在一个未连接的UDP套接字上调用sendto时，源自Berkeley的内核暂时连接该套接字，发送数据报，然后断开连接。通常涉及内核执行下列6个步骤：</p>
<ol>
<li>连接告戒之</li>
<li>输出第一个数据报</li>
<li>断开套接字连接</li>
<li>连接套接字</li>
<li>输出第二个数据报</li>
<li>断开套接字连接</li>
</ol>
<p>如果应用进程知道自己要给同一目的地址发送多个数据报时，显示连接套接字效率更高。调用connect后调用两次write设计内核执行如下步骤：</p>
<ol>
<li>连接套接字</li>
<li>输出第一个数据报</li>
<li>输出第二个数据报</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/02/23/IP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/02/23/IP/" class="post-title-link" itemprop="url">IP</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-02-23 17:17:17" itemprop="dateCreated datePublished" datetime="2018-02-23T17:17:17+08:00">2018-02-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-02 11:28:18" itemprop="dateModified" datetime="2019-08-02T11:28:18+08:00">2019-08-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Unix-Network-Programming/" itemprop="url" rel="index"><span itemprop="name">Unix Network Programming</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="IPv4头部"><a href="#IPv4头部" class="headerlink" title="IPv4头部"></a>IPv4头部</h2><p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/IPv4%20header.jpg" alt="image"></p>
<h2 id="IPv6头部"><a href="#IPv6头部" class="headerlink" title="IPv6头部"></a>IPv6头部</h2><p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/IPv6%20header.jpg" alt="image"></p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/02/23/IO复用：select和poll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/02/23/IO复用：select和poll/" class="post-title-link" itemprop="url">IO复用：select和poll</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-02-23 17:17:07" itemprop="dateCreated datePublished" datetime="2018-02-23T17:17:07+08:00">2018-02-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-02 11:28:18" itemprop="dateModified" datetime="2019-08-02T11:28:18+08:00">2019-08-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Unix-Network-Programming/" itemprop="url" rel="index"><span itemprop="name">Unix Network Programming</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="使用I-O复用的经典场合"><a href="#使用I-O复用的经典场合" class="headerlink" title="使用I/O复用的经典场合"></a>使用I/O复用的经典场合</h2><ul>
<li>当客户处理多个描述符（通常是交互式输入和网络套接字）时，必须使用I/O复用。</li>
<li>当一个客户端同时处理多个套接字时可能的。</li>
<li>如果一个TCP服务器既要处理监听套接字，又要处理已连接套接字。</li>
<li>如果一个服务器既要处理TCP，又要处理UDP，一般就要使用I/O复用。</li>
<li>如果一个服务器要处理多个服务器或者多个协议，一般要使用I/O复用。</li>
</ul>
<h2 id="select-函数"><a href="#select-函数" class="headerlink" title="select 函数"></a>select 函数</h2><p>该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdpl, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>select函数修改由指针readset、writeset和exceptset所指向的描述符集，因而这三个参数都是值-结果参数。调用该函数时，我们所指定所关心的描述符的值，该函数返回时，结果将指示哪些描述符已就绪。该函数返回后，我们使用FD_ISSET宏来测试fd_set数据类型中的描述符。描述符集内任何与未就绪描述符对应的位返回时均清成0。每次重新调用select函数时，我们都得再次把所有描述符集内所关心的位置均置为1。</p>
<h2 id="描述符就绪条件"><a href="#描述符就绪条件" class="headerlink" title="描述符就绪条件"></a>描述符就绪条件</h2><h3 id="套接字准备好读"><a href="#套接字准备好读" class="headerlink" title="套接字准备好读"></a>套接字准备好读</h3><ol>
<li>该套接字接收缓冲区中的数据字节数大于等于套接字接收缓冲区低水位标记的当前大小。对这样的套接字执行读操作不会阻塞并将返回一个大于0的值。可以使用SO_RCVLOWAT套接字选项设置该套接字的低水位标记。对于TCP和UDP套接字，其默认值为1。</li>
<li>该连接的读半部关闭（也就是接收了FIN的TCP连接）。对于这样的套接字的读操作将不阻塞并返回0(也就是返回EOF)。</li>
<li>该套接字是一个监听套接字且已完成的连接数不为0。对这样的套接字的accept通常不会阻塞。</li>
<li>其上有一个套接字错误待处理。对这样的套接字的读操作将不阻塞并返回-1（也就是返回一个错误），同时把errno设置成确切的错误条件。这些待处理错误（pending error）也可以通过指定SO_ERROR套接字选项调用getsockopt获取并清除。</li>
</ol>
<h3 id="套接字准备好写"><a href="#套接字准备好写" class="headerlink" title="套接字准备好写"></a>套接字准备好写</h3><ol>
<li>该套接字发送缓冲区中的可用空间字节数大于等于套接字发送缓冲区低水位标记的当前大小，并且u后者该套接字已连接，或者该套接字不需要连接（如UDP套接字）。这意味着如果我们把这样的套接字设置为非阻塞，写操作将不阻塞并返回一个正值。可以使用SO_SNDLOWAT套接字选项来设置该套接字的低水位标记。对于TCP和UDP套接字而言，其默认值是2048。</li>
<li>该连接的写半部关闭，对这样的套接字的写操作将产生SIGPIPE信号。</li>
<li>使用非阻塞式connect的套接字已建立连接，或者connect已经以失败告终。</li>
<li>其上有一个套接字错误待处理。对这样的套接字的写操作将不阻塞并返回-1(也就是返回一个错误)，同时把errno设置成确切的错误条件。这些待处理的错误也可以通过指定的SO_ERROR套接字选项调用getsockopt获取并清除。</li>
</ol>
<p>当某个套接字发生错误时，它将由select标记为即可读又可写。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/02/23/TCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/02/23/TCP/" class="post-title-link" itemprop="url">TCP</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-02-23 17:16:50" itemprop="dateCreated datePublished" datetime="2018-02-23T17:16:50+08:00">2018-02-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-02 11:28:18" itemprop="dateModified" datetime="2019-08-02T11:28:18+08:00">2019-08-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Unix-Network-Programming/" itemprop="url" rel="index"><span itemprop="name">Unix Network Programming</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="TCP-状态转换图"><a href="#TCP-状态转换图" class="headerlink" title="TCP 状态转换图"></a>TCP 状态转换图</h2><p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/TCP%20state.jpg" alt="image"></p>
<h2 id="TCP连接分组转换"><a href="#TCP连接分组转换" class="headerlink" title="TCP连接分组转换"></a>TCP连接分组转换</h2><p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/tcp%20connection%20example.jpg" alt="image"></p>
<h2 id="捎带（piggybacking）"><a href="#捎带（piggybacking）" class="headerlink" title="捎带（piggybacking）"></a>捎带（piggybacking）</h2><p>服务器对于客户端请求的确认可以伴随其应答发生，这种做法称为捎带（piggybacking），它通常在服务器处理请求并产生应答的时间少于200ms时发生。</p>
<h2 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h2><p>在TCP链接中，执行主动关闭的那端会有TIME_WAIT状态。改端点停留在这个状态的持续时间时<strong>最长分节生命期 maximum segment lifetime，MSL</strong>的两倍，有时称为2MSL。</p>
<p>任何TCP的实现都需要为MSL选择一个值。MSL时任何IP数据报能够在因特网中存活的最长时间。这个时间是有限的，因为每个数据报含有一个称为<strong>跳限 hop limit</strong>的8位字段，它的最大值是255。虽然跳限不是真正的时间限制，但是仍然假设：具有最大跳限的分组在网络中存活的时间不会超过MSL秒。</p>
<p>分组在网路中的迷途通常是路由异常的结果。某个路由器崩溃或某两个路由器之间的某个链路断开时，路由协议需要花费数秒钟到数分钟的时间才能稳定并找出另一条通路。并且在这段时间内有可能发生路由循环(路由器A把分组发送给路由器B，而B再把他们发送回A)。</p>
<p>假设迷途的分组是一个TCP分节，在迷途期间，发送端TCP超时并重传该分组，而重传的分组却通过某条候选路径到达最终目的地。不久之后路由器修复，之前迷途的分组也最终被送到目的地。这个原来的分组称为<strong>迷途的重组分组 lost duplicate</strong>或<strong>漫游的重组分组 wandering duplicate</strong>。</p>
<h3 id="TIME-WAIT状态存在的理由"><a href="#TIME-WAIT状态存在的理由" class="headerlink" title="TIME_WAIT状态存在的理由"></a>TIME_WAIT状态存在的理由</h3><ol>
<li><strong>可靠地实现TCP全双工连接的终止</strong></li>
<li><strong>允许老的重复分节在网络中消逝</strong></li>
</ol>
<p>对于理由1，在TCP关闭连接的4次握手中，如果最终的ACK丢失了，服务器将重新发送它的最后的那个FIN，因此客户端必须维护状态信息，以允许它重新发送最终那个ACK。如果客户端不维护状态信息，它将相应一个rst，该分节将被服务器解释成一个错误。如果TCP打算执行所有必要的工作以彻底终止某个连接上的两个方向的数据流，那么它必须正确处理连接终止序列4个分节中任何一个分节丢失的情况。</p>
<p>执行主动关闭的那一端是处于TIME_WAIT状态的那一端，因为可能不得不重传最终的ACK的就是那一端。</p>
<p>对于理由2：假设服务端和客户端分别在1500端口和21端口之间有一个TCP连接。关闭这个连接之后，在相同的IP地址和端口之间建立另一个连接。后一个连接称为前一个连接的<code>化身 incarnation</code>，因为他们的IP地址和端口号都相同。</p>
<p>TCP必须防止来自某个连接的老的重复分组在该连接已终止后再现，从而被误解为属于同一连接的某个新的化身。为做到这一点，TCP将不给处于<code>TIME_WAIT</code>状态的连接发起新的化身。<code>TIME_WAIT</code>的持续时间是MSL的2倍，足以让某个方向上的分组最多存活MSL秒被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃。通过这个规则可以保证没成功建立一个TCP连接时，来自该连接先前化身的重复分组都已在网络中消逝了。</p>
<h2 id="TCP输出"><a href="#TCP输出" class="headerlink" title="TCP输出"></a>TCP输出</h2><p>每一个TCP套接字都有一个发送缓冲区，可以使用<code>SO_SNDBUF</code>套接字选项来更改缓冲区的大小。当某个应用进程调用write时，内核从该应用进程的缓冲区复制所有数据写到套接字的发送缓冲区。</p>
<p>如果该套接字的发送缓冲区容不下应用进程的所有数据（或是应用进程的缓冲区大于套接字的发送缓冲区，或是套接字的发送缓冲区中已有其他数据），该应用进程将被投入睡眠。这里假设套接字是阻塞的（套接字默认设置是阻塞的）。内核将不从write系统调用返回，知道应用进程缓冲区中的所有数据都复制到套接字的发送缓冲区。</p>
<p>从写一个TCP套接字的write调用成功返回仅仅表示我们可以从重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已经接收到数据。</p>
<h2 id="PF-INET和AF-INET的区别"><a href="#PF-INET和AF-INET的区别" class="headerlink" title="PF_INET和AF_INET的区别"></a>PF_INET和AF_INET的区别</h2><p>AF: Address Family，表示地址族</p>
<p>PF: Protocol Family，表示协议族</p>
<p>在windows中的Winsock2.h中定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INET 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_INET AF_INET</span></span><br></pre></td></tr></table></figure></p>
<p>所以在windows中<code>AF_INET</code>与<code>PF_INET</code>完全一样。</p>
<p>而在Unix/Linux系统中，不同的版本这两者有微小的差别。对于BSD，是AF，对于POSIX，是PF。</p>
<p>理论上在建立socket时指定协议，应该用<code>PF_xxxx</code>，设置地址时应该用<code>AF_xxxx</code>。</p>
<p>当然<code>AF_INET</code>和<code>PF_INET</code>的值是相同的，混用也不会有太大问题。</p>
<h2 id="RST"><a href="#RST" class="headerlink" title="RST"></a>RST</h2><p>RST是TCP在发生错误时发送的一种TCP分节，产生RST的三个条件是：</p>
<ol>
<li>目的地为某端口的SYN到达，然而该端口上并没有正在监听的服务器</li>
<li>TCP想取消一个已有连接</li>
<li>TCP接收到一个根本不存在的连接上的分节</li>
</ol>
<h2 id="基于TCP客户-服务器程序的套接字函数"><a href="#基于TCP客户-服务器程序的套接字函数" class="headerlink" title="基于TCP客户/服务器程序的套接字函数"></a>基于TCP客户/服务器程序的套接字函数</h2><p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/TCP%20client_server%20socket%20function.JPG" alt="image"></p>
<h2 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect 函数"></a>connect 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>客户端在调用函数connect前不必非得调用connect函数，因为如果需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。</p>
<p>如果是TCP套接字，调用connect时会激发TCP的三次握手过程，而且仅在连接建立成功或出错时才返回。</p>
<p>出错有以下几种情况:</p>
<ol>
<li>若TCP客户端没有收到SYN分节的响应，则返回<code>ETIMEDOUT</code>错误。</li>
<li>若对客户的SYN的响应时RST，则表明该服务器主机在我们指定的端口上没有进程在等待与之连接。这是一种硬错误（hard error），客户一接收到RST就马上返回<code>ECONNECTREFUSED</code></li>
<li>若客户端发出的SYN在中间的某个路由器上引发了一个“destination unreachable”ICMP错误，则认为是一种软错误（soft error）。</li>
</ol>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果一个TCP客户端或者服务器未曾调用bind捆绑一个端口，当调用connect或者listen时，内核就要为相应的套接字选择一个临时端口。</li>
</ul>
<p>这个过程有一个例外：远程过程调用服务器（Remote Procedure Call，RPC）。他们通常由内核为他们的监听套接字选择一个临时端口，而该端口随后通过RPC端口映射器进行注册。客户在connect这个服务器之前，必须与端口映射器联系以获取他们的临时端口。</p>
<ul>
<li>进程可以把一个特地的IP地址捆绑到它的套接字上，不过这个IP地址必须属于其所在主机的网络接口之一。对于TCP客户，这就为在该套接字上发送的IP数据报指派了源IP地址。对于TCP服务器，这就限定该套接字只接收那些目的地为这个IP地址的客户连接。</li>
</ul>
<p>TCP客户通常不把IP地址捆绑到它的套接字上，当连接套接字时，内核将根据所用外出网络接口来选择源IP地址，而所用外出接口则取决于到达服务器所需的路径。如果TCP服务器没有把IP地址捆绑到它的套接字上，内核就把客户端发送的SYN的目的IP地址作为服务器的源IP地址。</p>
<p>如果指定端口号为0，那么内核就找bind被调用时选择一个临时端口。然而如果指定IP地址为通配地址，那么内核将等到套接字已连接（TCP）或已在套接字上发出数据报（UDP）时才选择一个本地IP地址。</p>
<p>如果想要得到内核所选择的临时端口值，必须调用函数getsockname来返回协议地址。</p>
<p>bind函数返回一个常见错误EADDRINUSE(“Adress already in use”，地址已使用)</p>
<h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span></span><br></pre></td></tr></table></figure>
<p>listen函数仅由TCP服务器调用，它完成两件事情：</p>
<ol>
<li>当socket函数创建一个套接字时，它被假定为一个主动套接字，也就是说，它是一个将调用connect发起连接的客户端套接字。listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。调用listen导致套接字从closed状态转换到LISTEN状态。</li>
<li>第二个参数规定了内核应该为相应套接字排队的最大连接个数。</li>
</ol>
<p>内核为任何一个给定的监听套接字维护两个队列：</p>
<ol>
<li>未完成连接队列（incomplete connection queue），每个这样的SYN分节对应其中一项：已由某个客户端发出并到达服务器，而服务器正在等待并完成相应的TCP三路握手过程。这些套接字处于SYN_RCVD状态。</li>
<li>已完成连接队列（complete connection queue），每个已完成三路握手的客户端对应其中一项，这些套接字处于ESTABLISHED状态。</li>
</ol>
<p>如果三路握手正常完成，该项就从未完成连接队列移到已完成队列的队尾。当进程调用accept时，已完成连接队列中的队头将返回给进程，如果该队列为空，那么进程将被投入睡眠，知道TCP在该队列中放入一项才唤醒它。</p>
<p>关于两个队列：</p>
<ol>
<li>listen函数的backlog参数曾被规定为这两个队列的总和的最大值。</li>
<li>源自Berkeley的实现给backlog增设了一个模糊因子（fudge factor）：把它乘以1.5得到未处理队列最大长度。</li>
<li>不要把backlog定义为0，如果不想让客户端连接到套接字上，可以关掉该监听套接字。</li>
<li>在三路握手正常完成的前提下（也就是说没有丢失分节，从而没有重传），未完成连接队列中的任何一项在其中的存留时间就是一个RTT，而RTT的值取决于特定的客户与服务器。</li>
<li>当一个客户SYN到达时，若这些队列是满的，TCP就忽略该分节，也就是不发送RST，这么做是因为：这种情况是暂时的，客户TCP将重发SYN。</li>
<li>在三路握手完成之后，但在服务器调用accept之前到达的数据应由服务器TCP排队，最大数据量为已连接套接字接收缓冲区大小。</li>
</ol>
<h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *cliaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span></span><br></pre></td></tr></table></figure>
<p>accept函数由TCP服务器调用，用于从已完成连接队列头返回下一个已完成连接。如果已完成连接队列为空，那么进程被投入睡眠（假设套接字为默认的阻塞方式）。</p>
<p>如果accept成功，那么其返回值是由内核自动生成的一个全新描述符，代表与说返回客户的TCP连接。 accept函数的第一个参数为监听套接字（listening socket）描述符（由socket创建，随后用作bind和listen的第一个参数的描述符），称它的返回值为已连接套接字（connected socket）。</p>
<p>一个服务器通常只创建一个监听套接字，它在该服务器的生命期内一直存在。内核为每个由服务器进程接收的客户连接创建一个已连接套接字（也就是说对于它的TCP三路握手过程已经完成）。当服务器完成对某个给定客户的服务时，相应的已连接套接字就被关闭。</p>
<h2 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>close将一个TCP套接字的默认行为是把该套接字标记成已关闭，然后立即返回到调用进程，该套接字不能再由调用进程使用。然而TCP尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接终止序列。</p>
<p>并发服务器中父进程关闭已连接套接字只是导致相应描述符的引用计数值减1。如果引用计数值仍大于0，这个close调用并不引发TCP的四分组连接终止序列。</p>
<p>如果确实想在某个TCP连接上发送FIN，那么可以改用shutdown函数以代替close。</p>
<p>如果父进程对每个accept返回的已连接套接字都不调用close，首先父进程最终将耗尽可用描述符，因为任何进程在任何时刻可拥有的打开着的描述符通常都是有限制的。更重要的是，没有一个客户端连接会被终止。当子进程关闭已连接套接字时，它的引用计数值将由2递减为1且保持为1，因为父进程永不关闭任何已连接的套接字。这将妨碍TCP连接终止序列的发生，导致连接一直打开。</p>
<h2 id="getsockname-和-getpeername函数"><a href="#getsockname-和-getpeername函数" class="headerlink" title="getsockname 和 getpeername函数"></a>getsockname 和 getpeername函数</h2><p>这两个函数或者返回与某个套接字关联的本地协议地址（getsockname），或者返回与某个套接字关联的外地协议地址（getpeername）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *localaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *peeraddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="wait-和-waitpid-函数"><a href="#wait-和-waitpid-函数" class="headerlink" title="wait 和 waitpid 函数"></a>wait 和 waitpid 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc);</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure>
<p>函数wait和waitpid均返回两个值：已终止子进程的进程ID号，以及通过statloc指针返回的子进程终止状态（一个整数）。</p>
<p>如果调用wait的进程没有已终止的子进程，不够有一个或多个子进程仍在执行，那么wait将阻塞到现有子进程第一个终止为止。</p>
<p>waitpid函数就等待哪个进程以及是否阻塞给了更多的控制。首先，pid参数允许我们指定想等待的进程ID，值-1表示等待第一个终止的子进程。其次，option允许指定附加选项，最常用的选项是WNOHANG，它告知内核在没有已终止的子进程时不要阻塞。</p>
<h2 id="shutdown函数"><a href="#shutdown函数" class="headerlink" title="shutdown函数"></a>shutdown函数</h2><p>终止网络连接的常用方法是调用close函数。不过close有两个限制，却可以使用shutdown函数来避免。</p>
<ol>
<li>close把描述符的引用计数减1，仅在该计数变成0时才关闭套接字。使用shutdown可以不管引用计数就激发TCP的正常连接终止序列。</li>
<li>close终止读和写两个方向的数据传送。既然TCP连接是全双工的，有时候需要告知对端我们已经完成了数据发送，即使对端仍有数据要发送给我们。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure>
<p>shutdown的行为依赖于howto参数的值：</p>
<ol>
<li>SHUT_RD 关闭连接的读这一半————套接字中不再有数据可接收，而且套接字接收缓冲区中的现有数据都被丢弃。进程不能再对这样的套接字调用任何读函数。对一个TCP套接字调用这样的shutdown函数后，由该套接字接收的来自对端的任何数据都被确认，然后丢弃。</li>
<li>SHUT_WR 关闭连接的写这一半————对于TCP套接字，则成为半关闭（half close）。当前留在套接字发送缓冲区中的数据将被发送掉，后跟TCP的正常的连接终止序列。不管套接字描述符的引用计数是否等于0，这样的写半部分关闭照样执行。进程不能在对这样的套接字调用任何写函数。</li>
<li>SHUT_RDWR 连接的读半部和写半部都关闭————这与调用shutdown两次等效：第一次调用指定SHUT_RD，第二次调用指定SHUT_WR。</li>
</ol>
<h2 id="网络编程时遇到的情况"><a href="#网络编程时遇到的情况" class="headerlink" title="网络编程时遇到的情况"></a>网络编程时遇到的情况</h2><ol>
<li>当fork子进程时，必须捕获SIGHLD信号。</li>
<li>当捕获信号时，必须处理被中断的系统调用。</li>
<li>SIGCHLD的信号处理函数必须正确编写，应使用waitpid函数以面留下僵死进程。</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/02/23/网络知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/02/23/网络知识/" class="post-title-link" itemprop="url">网络知识</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-02-23 17:16:20" itemprop="dateCreated datePublished" datetime="2018-02-23T17:16:20+08:00">2018-02-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-02 11:28:18" itemprop="dateModified" datetime="2019-08-02T11:28:18+08:00">2019-08-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Unix-Network-Programming/" itemprop="url" rel="index"><span itemprop="name">Unix Network Programming</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="客户端端口号"><a href="#客户端端口号" class="headerlink" title="客户端端口号"></a>客户端端口号</h2><p>客户端通常使用短期存活的<strong>临时端口（ephemeral port）</strong>。这些端口号通常由传输层协议自动赋予客户端。客户通常不关心其临时端口的具体值，只需要确定该端口号在所在主机中是唯一的就行。传输协议代码要确保这种唯一性。</p>
<h2 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h2><p>maximum transmission unit, 最大传输单元。</p>
<p>许多网络有一个硬件规定的MTU。例如，以太网的MTU是1500字节。</p>
<p>在两个主机之间的路径最下的MTU称为<strong>路径MTU(path MTU)</strong>。两个主机相反方向上路径MTU可以不一致，因为在因特网中路由选择往往是不对称的，也就是说从A到B的路径和从B到A的路径可以不相同。</p>
<p>当一个IP数据报从某个接口送出时，如果它的大小超过相应链路的MTU，IPv4和IPv6都将执行<strong>分片(fragmentation)</strong>。这些片段在到达目的地之前通常不会被<strong>重组（reassembling）</strong>。IPv4主机对其产生的数据报执行分片，IPv4路由器对其转发的数据包执行分片。然而IPv6只有主机对其产生的数据报执行分片，IPv6路由器不对其转发的数据报执行分片。</p>
<p>IPv4和IPv6都定义了<strong>最小重组缓冲区大小（minimum reassembly buffer size）</strong>，它是IPv4或IPv6的任何实现都必须保证支持的最小数据报大小。其值对于IPv4是576字节，对于IPv6是1500字节。</p>
<p>TCP中有一个<strong>MSS（maximum segment size，最大分片大小）</strong>，用于向对端TCP通告对端在每个分节中能发送的最大TCP数据量。MSS的目的是告诉对端其重组缓冲区大小的实际值，从而避免试图分片。MSS经常设置成MTU减去IP和TCP首部固定长度。</p>
<p>在以太网中使用IPv4的MSS值为1460，使用IPv6的MSS值为</p>
<h2 id="PDU-协议数据单元-protocol-data-unit"><a href="#PDU-协议数据单元-protocol-data-unit" class="headerlink" title="PDU(协议数据单元 protocol data unit)"></a>PDU(协议数据单元 protocol data unit)</h2><p>计算机网络各层对等实体间交换的单位信息称为<strong>协议数据单元(PDU)</strong>，按照协议与服务之间的关系，除了最底层（物理层）外，每层的PDU通过紧邻下层提供给本层的服务接口，作为下层的<strong>服务数据单元</strong>(<strong>service data unit, SDU</strong>)传递给下层，并由下层完成本层的PDU交换。如果本层的PDU大小超过紧临下层的最大SDU限制，那么本层需要实现把SDU划分为若干个合适的片段让下层分开载送，再在相反的方向把这些碎片重组成PDU。</p>
<p>应用层实体(如客户或者服务器进程)间交换的PDU称为<strong>应用数据(application data)</strong>，其中在应用进程之间交换的时没有长度限制的单个双向字节流，在UDP应用进程之间交换的是其长度不超过UDP发送缓冲区大小的<strong>单个记录(record)</strong>，在SCTP应用进程之间交换的是没有总长度限制的单个或多个双向记录流。</p>
<p>传输层实体间交换的PDU称为<strong>消息(message)</strong>，其中TCP的PDU称为<strong>分节(segment)</strong>。消息或分节的长度是有限的。</p>
<p>在TCP传输中，发送端TCP把来自应用进程的字节流数据按顺序经分割后封装在各个分节中传送给接收端TCP，其中每个分节所封装的数据即可能是发送端应用进程单次输出操作的结果，也可能是连续数次输出操作的结果，而且每个分节所封装的单次输出操作的结果或者首尾两次输出操作的结果既可能是完整的，也可能是不完整的，具体取决于连接建立阶段由对端通告的<strong>最大分节大小(MSS, maximum segment size)</strong>，以及外出接口的<strong>最大传输单元(maximum transmission unit, MTU)</strong>。</p>
<p>UDP传输层相当简单，发送端UDP就把来自应用进程的单个记录整个封装在UDP消息中传送给接收端UDP。</p>
<p>SCTP引入了称为<strong>块</strong>(<strong>chunk</strong>)的数据单元，SCTP消息就由一个公共首部加上一个或多个块构成：公共首部类似UDP消息的首部，仅仅给出源目的端口号和整个SCTP消息的校验和；块既可以承载数据，也可以承载控制信息。发送端SCTP把来自应用进程的（一个或多个）记录流数据按照数据流内顺序和记录边界封装在各个DATA块中，并在DATA块首部记上各自的流ID。</p>
<p>一个记录通常对应一个DATA块，对于过长的记录，发送端SCTP既可以像UDP那样拒绝发送，也可以把他们拆分到多个DATA块中以便发送，接收端SCTP收取后把他们组合成单个记录上传。</p>
<p>网络成实体间交换的PDU称为<strong>IP数据报(IP datagram)</strong>，其长度有限：IPV4数据报最大65535字节，IPv6数据报最大65575字节。发送端IP把来自传输层的消息（或TCP分节）整个封装在IP数据报中传送。</p>
<p>链路层实体间交换的PDU称为<strong>帧（frame）</strong>，其长度取决于具体的接口。</p>
<p>IP数据报由IP首部和所承载的传输层数据构成。过长的IP数据报无法封装在单个帧中，需要首先对其SDU进行<strong>分片（fragementation）</strong>，再把分成对得各个<strong>片段（fragement）</strong>冠以新的IP首部封装到多个帧中。在一个IP数据包从源端传送到目的端的传送过程中，分片操作既可能发生在源端，也可能发生在途中。</p>
<p>T<strong>CP/IP协议族为提高效率会尽可能避免IP分片/重组操作</strong>：TCP根据MSS和MTU限定每个分节的大小以及SCTP根据MTU分片/重组过长记录都是这个目的（STCP的块捆绑这是为了避免IP分片/重组操作的前提下提高块传输效率）；另外，IPv6禁止在途中的分片操作（基于其路径MTU发现功能），IPv4也尽量避免这种操作。</p>
<p>不论是否分片，都由IP作为链路层的SDU传入链路层，并由链路层封装再帧中的数据称为<strong>分组（packet，俗称包）</strong>。一个分组既可能是一个完整的IP数据报，也可能是某个IP数据报的SDU的一个片段冠以新的IP首部的结果。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/02/23/socket-编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/02/23/socket-编程/" class="post-title-link" itemprop="url">socket 编程</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-02-23 17:16:07" itemprop="dateCreated datePublished" datetime="2018-02-23T17:16:07+08:00">2018-02-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-02 11:28:18" itemprop="dateModified" datetime="2019-08-02T11:28:18+08:00">2019-08-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Unix-Network-Programming/" itemprop="url" rel="index"><span itemprop="name">Unix Network Programming</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><p>标识每个端点的两个值（IP地址和端口号）通常称为一个套接字。</p>
<p>TCP无法仅仅通过查看端口号来分离外来的分节到不同的端点。它必须查看套接字对的所有4个元素才能确定由哪个端点接收某个到达的分节。</p>
<h2 id="不同套接字地址结构比较"><a href="#不同套接字地址结构比较" class="headerlink" title="不同套接字地址结构比较"></a>不同套接字地址结构比较</h2><p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/different%20address%20struct.JPG" alt="image"></p>
<h2 id="getsockopt-和-setsockopt-函数"><a href="#getsockopt-和-setsockopt-函数" class="headerlink" title="getsockopt 和 setsockopt 函数"></a>getsockopt 和 setsockopt 函数</h2><p>这两个函数仅用于套接字<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span>* optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>optval是一个指向某个变量的指针，setsockopt从<code>*optval</code>中取得选项待设置的新值，getsockopt则把已获取的选项当前值存放到<code>*optval</code>中。</p>
<p>套接字选项粗分为两大基本类型：一是启用或者禁止某个特性的二元选项（称为标志选项），二是取得并返回我们可以设置或检查的特定值选项（称为值选项）。</p>
<p>当给这些标志选项调用getsockopt函数时，<code>*optval</code>是一个整数。<code>*optval</code>中返回的值为0表示相应选项被禁止，不为0表示相应选项被启用。</p>
<p>setsockopt函数需要一个不为0的<code>*optva</code>值来启用选项，一个为0的<code>*optval</code>值来禁止选项。</p>
<h2 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h2><h3 id="SO-KEEPALIVE-套接字选项"><a href="#SO-KEEPALIVE-套接字选项" class="headerlink" title="SO_KEEPALIVE 套接字选项"></a>SO_KEEPALIVE 套接字选项</h3><p>给一个TCP套接字设置保持存活（keep-alive）选项后，如果在2小时内在该套接字的任一方向上都没有数据交换，TCP就自动给对端发送一个保持存活探测分节(keep-alive probe)。这是一个对端必须响应的TCP分节。</p>
<p>发送该分节后：</p>
<ol>
<li>对端以期望的ACK响应。应用进程得不到通知（因为一切正常）。在又经过仍无动静的2小时后，TCP将发出另一个探测分节。</li>
<li>对端以rst响应，它告知本端TCP：对端已崩溃且已重新启动。该套接字的待处理错误被置为ECONNRESET，套接字本身则被关闭。</li>
<li>对端对保持存活探测分节没有任何响应。源自Berkeley的TCP将另外发送8个探测分节，两两相隔75秒，试图得到一个响应。TCP在发出第一个探测分节后11分15秒内若没有得到任何响应则放弃。</li>
</ol>
<p>如果根本没有对TCP的探测分节的响应，该套接字的待处理错误就被置为ETIMEOUT，套接字本身则被关闭，然而如果该套接字收到一个ICMP错误作为某个探测分节的响应，那就返回相应的错误，套接字本身也被关闭。</p>
<p>本选项的功能是检测对端主机是否崩溃或变得不可达。如果对端进程崩溃，它的TCP将跨连接发送一个FIN，这可以通过调用select很容易的检测到。同时也要认识到，即使对任何保持存活探测分节均无响应（第三种情况），我们也不能肯定对端主机已经崩溃，因而TCP可能会终止一个有效连接。</p>
<p>本选项一本由服务器调用，不过客户端也可以使用。服务器使用本选项是因为它们花大部分时间阻塞在等待穿越TCP的连接输入上，也就是说在等待客户端的请求。然而如果客户主机连接掉线、电源掉线或系统崩溃，服务器进程将永远不会知道，并将继续等待永远不会到达的输入。这种情况称为半开连接（half-open connection）。保持存活选项将检测出这些半开连接并终止他们。</p>
<h3 id="SO-RCVBUF-和-SO-SNDBUF-套接字选项"><a href="#SO-RCVBUF-和-SO-SNDBUF-套接字选项" class="headerlink" title="SO_RCVBUF 和 SO_SNDBUF 套接字选项"></a>SO_RCVBUF 和 SO_SNDBUF 套接字选项</h3><p>每个套接字都有一个发送缓冲区和一个接收缓冲区。</p>
<p>接收缓冲区被TCP、UDP和SCTP用来保存接收到的数据，知道由应用进程来读取。对于TCP来说，套接字接收缓冲区中可用空间的大小限定了TCP通告对端的窗口大小。TCP套接字接收缓冲区不可能溢出，因为不允许对端发出超过本端所通告窗口大小的数据。这就是TCP的流量控制，如果对端无视窗口大大小而发出了超过该窗口大小的数据，本端TCP将丢弃他们。UDP是没有流量控制的：较快的发送端可以很容易地淹没较慢的接收端，导致接收端的UDP丢弃数据报。事实上较快的发送端甚至可以淹没本机的网络接口，导致数据报被本机丢弃。</p>
<p>当设置TCP套接字接收缓冲区的大小时，函数调用的顺序很重要。这是因为TCP的窗口规模选项是在建立连接时用SYN分节与对端互换得到的。对于客户，这意味着SO_RCVBUF选项必须在调用connect之前设置；对于服务器，这意味着该选项必须在调用listen之前给监听套接字设置。给已连接套接字设置该选项对于可能存在的窗口规模选项没有任何影响，因为accept直到TCP的三路握手完成才会创建并返回已连接套接字。这就是必须给监听套接字设置本选项的原因。（套接字缓冲区的大小总是由新创建的已连接套接字从监听套接字继承而来）。</p>
<p>TCP套接字缓冲区的大小至少应该是相应连接的MSS值的四倍。这一点的依据是TCP快速恢复算法的工作机制。TCP发送端使用三个重复的确认来检测某个分节是否丢失。发现某个分节丢失后，接收端将给新收到的每个分节发送一个重复的确认，如果窗口大小不足以存放4个这样的分节，那就不可能连发三个重复的确认，从而无法激活快速恢复算法。</p>
<h3 id="TCP-NODELAY套接字选项"><a href="#TCP-NODELAY套接字选项" class="headerlink" title="TCP_NODELAY套接字选项"></a>TCP_NODELAY套接字选项</h3><p>开启TCP_NODELAY选项将禁止TCP的Nagle算法。</p>
<p>Nagle算法的目的在于减少广域网（WAN）上小分组的数目。该算法指出：如果某个给定连接上有待确认数据（outstanding dataa），那么原本应该作为用户写操作相应的在该连接上立即发送相应小分组的行为就不会发生，直到现有数据被确认为止。这里“小”的定义就是小于MSS的任何分组。TCP总是尽可能地发送最大大小的分组，Nagle算法的目的在于防止一个连接在任何时刻有多个小分组待确认。</p>
<p>Nalge算法常常与另一个TCP算法联合使用：ACK延滞算法（delayed ACK algorithm）。该算法使得TCP在收到数据后不立即发送ACK，而是等待一小段时间(典型值为50~200ms)，然后才发送ACK。TCP期待在这一小段时间内自身有数据发送回对端，被延滞的ACK就可以由这些数据捎带，从而省掉一个TCP分节。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/02/02/python2-7-深入理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/02/02/python2-7-深入理解/" class="post-title-link" itemprop="url">python2.7 深入理解</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-02-02 11:04:13" itemprop="dateCreated datePublished" datetime="2018-02-02T11:04:13+08:00">2018-02-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-02 11:28:18" itemprop="dateModified" datetime="2019-08-02T11:28:18+08:00">2019-08-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/learning-python/" itemprop="url" rel="index"><span itemprop="name">learning python</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="tuple-和-list的异同"><a href="#tuple-和-list的异同" class="headerlink" title="tuple 和 list的异同"></a>tuple 和 list的异同</h2><ol>
<li>tuple是不可变的，list是可变的。</li>
<li>tuple表示的是结构，list表示的是顺序。</li>
<li>list不能当作dict的key，tuple可以。</li>
<li>由于元组支持的操作比列表小，所以元组的操作相对于list会快上一点点。(除非有巨量的数据需要去处理，否则这一点不需要特别强调)</li>
</ol>
<p>tuple所谓的不可变指的是指向的位置不可变。如果tuple中含有一个list，这个list的内容是可以变化的，因为list本身在内存中的分配不是连续的。</p>
<h2 id="while-else-和-for-else"><a href="#while-else-和-for-else" class="headerlink" title="while/else 和 for/else"></a>while/else 和 for/else</h2><p>循环可以有一个<code>else</code>子句<br>在循环迭代完整个列表(对于<code>for</code>)后或执行条件为<code>false</code>(对于<code>while</code>)时执行，但循环被<code>break</code>中止的情况下不会执行。</p>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>value if condition else other_value</p>
<p>e.g.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is_fat = <span class="literal">True</span></span><br><span class="line">state = <span class="string">"fat"</span> <span class="keyword">if</span> is_fat <span class="keyword">else</span> <span class="string">"not fat"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="嵌套函数和闭包-Closure"><a href="#嵌套函数和闭包-Closure" class="headerlink" title="嵌套函数和闭包(Closure)"></a>嵌套函数和闭包(Closure)</h2><p>函数不仅可以定义在模块的最外层，还可以定义在另一个函数的内部，像这种定义在函数里面的函数称之为<code>嵌套函数</code>。</p>
<p>嵌套函数可以访问到其外层作用域中声明的非局部变量。</p>
<p>闭包却可以即使脱离函数本身的作用范围，局部变量还是可以被访问得到。</p>
<p>闭包的定义：<br>在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量， 则可能产生闭包。运行时，一旦外部的 函数被执行，一个闭包就形成了， 闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用。</p>
<p>闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。 在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。</p>
<blockquote>
<p>注意：python闭包必须通过嵌套函数定义实现，但是嵌套函数不一定是闭包。</p>
</blockquote>
<p>当一个函数在执行完以后，访问了嵌套作用域的局部变量，闭包就产生了。假如嵌套函数没有访问嵌套作用域的局部变量，它就不是闭包。</p>
<p>产生闭包必须具备三个条件：</p>
<ol>
<li>需要定义嵌套函数</li>
<li>嵌套函数需要引用enclosing function中的变量</li>
<li>enclosing function需要返回嵌套函数</li>
</ol>
<p>闭包的作用：<br>闭包可以避免全局变量的使用，并且可以隐藏一些数据的格式。同时也可以提供面向对象的方法。</p>
<p><a href="https://www.programiz.com/python-programming/closure" target="_blank" rel="noopener">Python Closures</a></p>
<h2 id="迭代器-Iterators"><a href="#迭代器-Iterators" class="headerlink" title="迭代器(Iterators)"></a>迭代器(Iterators)</h2><p>python中的迭代器是一个可以被迭代的对象，每次迭代返回一个数据元素。</p>
<p>python的迭代器对象必须要实现两个特殊的方法：<code>__iter()__</code>和<code>__next()__</code>，被称为<strong>iterator protocol</strong></p>
<p>如果我们可以从一个对象获取<code>iterator</code>，则把这个对象成为<code>iterable</code>。很多python内置的容器都是可迭代的，像list, tuple, string。</p>
<p>可以通过<code>next()</code>函数人工的迭代遍历迭代器中所有的元素，当没有数据返回时，函数会抛出<code>StopIteration</code>异常。</p>
<p>一个更优雅的使用迭代器的方式是使用<code>for</code>循环，<code>for</code>可以迭代任何能够返回迭代器的对象。</p>
<h3 id="for-的内部实现"><a href="#for-的内部实现" class="headerlink" title="for 的内部实现"></a>for 的内部实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line">    <span class="comment"># do something with element</span></span><br></pre></td></tr></table></figure>
<p>实际实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create an iterator object from that iterable</span></span><br><span class="line">iter_obj = iter(iterable)</span><br><span class="line"></span><br><span class="line"><span class="comment"># infinite loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># get the next item</span></span><br><span class="line">        element = next(iter_obj)</span><br><span class="line">        <span class="comment"># do something with element</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># if StopIteration is raised, break from loop</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p><code>for</code>语句首先通过调用<code>iter()</code>创建了一个迭代器对象：<code>iter_obj</code>。</p>
<p>在循环内部通过调用<code>next()</code>函数去获取下一个元素。在所有元素都处理完之后，<code>StopIteration</code>被抛出，并在循环内部被捕获，并保证其他类型的异常不被捕获。</p>
<h3 id="实现迭代器对象"><a href="#实现迭代器对象" class="headerlink" title="实现迭代器对象"></a>实现迭代器对象</h3><p>实现迭代器对象只需要实现两个方法：<code>__iter()__</code>和<code>__next()__</code></p>
<p><code>__iter()__</code>方法返回迭代器对象本身。如果需要的话，可以进行初始化的操作。</p>
<p><code>__next()__</code>方法返回序列中的下一个元素。当达到最后一个元素的下一个调用时必须抛出<code>StopIteration</code>异常。</p>
<p>for example：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PowTwo</span>:</span></span><br><span class="line">    <span class="string">"""Class to implement an iterator</span></span><br><span class="line"><span class="string">    of powers of two"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max = <span class="number">0</span>)</span>:</span></span><br><span class="line">        self.max = max</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.n &lt;= self.max:</span><br><span class="line">            result = <span class="number">2</span> ** self.n</span><br><span class="line">            self.n += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br></pre></td></tr></table></figure></p>
<p><a href="https://www.programiz.com/python-programming/iterator" target="_blank" rel="noopener">Python Interators</a></p>
<h2 id="生成器-Generators"><a href="#生成器-Generators" class="headerlink" title="生成器(Generators)"></a>生成器(Generators)</h2><p>生成器是创建迭代器的一种简单的方式。简单的说，生成器就是可以返回一个可迭代对象的函数（每次返回一个元素）</p>
<p>生成器的创建非常简单，只需要把函数定义中的<code>return</code>替换为<code>yeild</code>即可。</p>
<p>如果一个函数中包含了至少一个<code>yeild</code>语句，这个函数就是生成器。<code>yeild</code>和<code>return</code>都会从函数中返回值。</p>
<p>不同的是，<code>return</code>语句会终止整个函数的执行，<code>yeild</code>语句会暂停函数的执行并且储存函数的状态，在下一次成功调用后继续执行。</p>
<p>生成器函数和普通函数的异同：</p>
<ol>
<li>生成器函数包含了一个或者多个<code>yelid</code>语句</li>
<li>当被调用时，生成器函数返回一个迭代器对象，但是函数不会立即开始执行。</li>
<li><code>__iter()__</code>方法和<code>__next()__</code>方法会被自动的实现，所以可以调用<code>next()</code>函数获取下一个元素。</li>
<li>当函数执行<code>yelid</code>语句时，函数会被暂停执行，控制权会返还给调用者</li>
<li>局部变量和他们的状态在成功的调用之间会被保存</li>
<li>当函数结束时，<code>StopIteration</code>会在下一次的调用时被自动抛出。</li>
</ol>
<p>每个生成器只能被调用一次，要重新开始生成器的调用可以创建一个新的生成器对象，像:<code>a = my_gen()</code></p>
<blockquote>
<p>可以直接在for循环中使用生成器</p>
</blockquote>
<h3 id="生成器表达式-Generator-Expression"><a href="#生成器表达式-Generator-Expression" class="headerlink" title="生成器表达式(Generator Expression)"></a>生成器表达式(Generator Expression)</h3><p>生成器表达式(generateor expression)的语法和列表推导式(list comprehension)的结构很像，只需要把方括号替换为圆括号。</p>
<p>generator expression和list comprehension最主要的区别就是list comprehension每次生成整个列表，但是generator expression每次生成一个元素。</p>
<p>genreator expression只有每次被调用的时候才会输出元素，所以generator expression比list comprehension在内存的使用上跟高效。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Initialize the list</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># square each term using list comprehension</span></span><br><span class="line"><span class="comment"># Output: [1, 9, 36, 100]</span></span><br><span class="line">[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> my_list]</span><br><span class="line"></span><br><span class="line"><span class="comment"># same thing can be done using generator expression</span></span><br><span class="line"><span class="comment"># Output: &lt;generator object &lt;genexpr&gt; at 0x0000000002EBDAF8&gt;</span></span><br><span class="line">(x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> my_list)</span><br></pre></td></tr></table></figure>
<p>generator expression可以被函数调用，这种情况下圆括号可以省去。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> my_list)</span><br><span class="line"><span class="number">146</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://www.programiz.com/python-programming/generator" target="_blank" rel="noopener">Python Generators</a></p>
<h2 id="装饰器-decorator"><a href="#装饰器-decorator" class="headerlink" title="装饰器(decorator)"></a>装饰器(decorator)</h2><p>装饰器可以向已经写好的代码中添加功能，程序的一部分可以在编译时修改程序的另一部分。</p>
<blockquote>
<p>everything in python are objects.</p>
</blockquote>
<p>python函数的一些特性：</p>
<ol>
<li>同一个函数对象可以绑定不同的函数名称</li>
<li>函数可以作为参数传递给另一个函数(这些函数也被称为higher order functions)</li>
<li>函数可以把函数当作返回值</li>
</ol>
<p>函数和方法被称为可调用的(called)。在python中任何实现<code>__call__()</code>方法的对象都称为可调用的(called)。</p>
<p>装饰器就是<code>callable</code>并返回<code>callable</code>的对象。</p>
<p>装饰器一般读取一个函数，为其添加功能然后返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pretty</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"I got decorated"</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ordinary</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am ordinary"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ordinary()</span><br><span class="line">I am ordinary</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># let's decorate this ordinary function</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pretty = make_pretty(ordinary)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pretty()</span><br><span class="line">I got decorated</span><br><span class="line">I am ordinary</span><br></pre></td></tr></table></figure>
<p>可以使用@符号和装饰器名称一起使用，放在函数定义前，表示该函数使用该装饰器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@make_pretty</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ordinary</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am ordinary"</span>)</span><br></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ordinary</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am ordinary"</span>)</span><br><span class="line">ordinary = make_pretty(ordinary)</span><br></pre></td></tr></table></figure></p>
<p>带参数的装饰器需要保证inner function的参数和被修饰的函数参数保持一致。可以用一种通用的装饰器的实现方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">works_for_all</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"I can decorate any function"</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure></p>
<p><code>args</code>是位置参数的元组，<code>kwargs</code>是默认参数的字典。</p>
<p>同一个函数可以被多个装饰器装饰多次（可以是同一个装饰器）。</p>
<p><a href="https://www.programiz.com/python-programming/decorator" target="_blank" rel="noopener">Python Decorator</a></p>
<h2 id="属性（Property）"><a href="#属性（Property）" class="headerlink" title="属性（Property）"></a>属性（Property）</h2><p>property example:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Celsius</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, temperature = <span class="number">0</span>)</span>:</span></span><br><span class="line">        self.temperature = temperature</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_fahrenheit</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (self.temperature * <span class="number">1.8</span>) + <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_temperature</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Getting value"</span>)</span><br><span class="line">        <span class="keyword">return</span> self._temperature</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_temperature</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">-273</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"Temperature below -273 is not possible"</span>)</span><br><span class="line">        print(<span class="string">"Setting value"</span>)</span><br><span class="line">        self._temperature = value</span><br><span class="line"></span><br><span class="line">    temperature = property(get_temperature,set_temperature)</span><br></pre></td></tr></table></figure></p>
<p>我们在最后一行创造了一个property对象：<code>temperature</code>。任何获取<code>temperature</code>值的代码会自动调用<code>get_temperature()</code>方法，而不是向<code>__dict__</code>中查找，任何给<code>temperature</code>赋值的代码会自动调用<code>set_temperature()</code>。</p>
<p>在python中，<code>property()</code>是一个内置的函数，创建和返回一个property对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">property(fget=<span class="literal">None</span>, fset=<span class="literal">None</span>, fdel=<span class="literal">None</span>, doc=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p>
<p><code>fget</code>是获取属性的值的函数，<code>fset</code>是设置属性值的函数，<code>fdel</code>是删除属性的函数，<code>doc</code>是一个字符串（类似于注释）。</p>
<p>property对象有三个方法：<code>gettter()</code>,<code>setter()</code>和<code>delete()</code>用于设置<code>fget</code>,<code>fset</code>和<code>del</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temperature = property(get_temperature,set_temperature)</span><br></pre></td></tr></table></figure></p>
<p>可以等价于<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># make empty property</span></span><br><span class="line">temperature = property()</span><br><span class="line"><span class="comment"># assign fget</span></span><br><span class="line">temperature = temperature.getter(get_temperature)</span><br><span class="line"><span class="comment"># assign fset</span></span><br><span class="line">temperature = temperature.setter(set_temperature)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：python2中实现property时，需要继承object，否则setter无效。python3默认继承，所以没有问题。</p>
</blockquote>
<h3 id="使用装饰器实现property"><a href="#使用装饰器实现property" class="headerlink" title="使用装饰器实现property"></a>使用装饰器实现property</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Celsius</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, temperature = <span class="number">0</span>)</span>:</span></span><br><span class="line">        self._temperature = temperature</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_fahrenheit</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (self.temperature * <span class="number">1.8</span>) + <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">temperature</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Getting value"</span>)</span><br><span class="line">        <span class="keyword">return</span> self._temperature</span><br><span class="line"></span><br><span class="line"><span class="meta">    @temperature.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">temperature</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">-273</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"Temperature below -273 is not possible"</span>)</span><br><span class="line">        print(<span class="string">"Setting value"</span>)</span><br><span class="line">        self._temperature = value</span><br></pre></td></tr></table></figure>
<p><a href="https://www.programiz.com/python-programming/property" target="_blank" rel="noopener">Python Property</a></p>
<h2 id="方法和函数的区别"><a href="#方法和函数的区别" class="headerlink" title="方法和函数的区别"></a>方法和函数的区别</h2><blockquote>
<p><strong>function(函数)</strong> —— A series of statements which returns some value toa caller. It can also be passed zero or more arguments which may beused in the execution of the body.</p>
</blockquote>
<blockquote>
<p><strong>method(方法)</strong> —— A function which is defined inside a class body. If called as an attribute of an instance of that class, the method will get the instance object as its first argument (which isusually called self).</p>
</blockquote>
<p>本质上，函数和方法的区别是：函数属于<code>FunctionObject</code>，而方法属于<code>PyMethodObject</code>。</p>
<p>e.g.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aa</span><span class="params">(d, na=None, *kasd, **kassd)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">a = A()</span><br><span class="line"><span class="keyword">print</span> aa</span><br><span class="line"><span class="keyword">print</span> A.f</span><br><span class="line"><span class="keyword">print</span> a.f</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;function aa at <span class="number">0x0000000004D995F8</span>&gt;</span><br><span class="line">&lt;unbound method A.f&gt;</span><br><span class="line">&lt;bound method A.f of &lt;__main__.A object at <span class="number">0x0000000004DB97F0</span>&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Bound-Method-和-Unbound-Method"><a href="#Bound-Method-和-Unbound-Method" class="headerlink" title="Bound Method 和 Unbound Method"></a>Bound Method 和 Unbound Method</h3><p>method还可以分为bound method和unbound method，bound method多了一个实例绑定的过程。</p>
<p>A.f是unbound method，a.f是bound method</p>
<p>bound和unbound的判断依据就是，当方法真正执行时，有没有传入实例。</p>
<p>A.f(a)和a.f()用法的区别只在于，第一种需要认为传入实例才能调用，第二种虚拟机帮我们做好了传入实例的动作，两种方法本质上是等价的。</p>
<h2 id="类方法-classmethod-和静态方法-statimethod"><a href="#类方法-classmethod-和静态方法-statimethod" class="headerlink" title="类方法(classmethod)和静态方法(statimethod)"></a>类方法(classmethod)和静态方法(statimethod)</h2><blockquote>
<p><strong>@classmethod</strong> means: when this method is called, we pass the class as the first argument instead of the instance of that class (as we normally do with methods). This means you can use the class and its properties inside that method rather than a particular instance.</p>
</blockquote>
<blockquote>
<p><strong>@staticmethod</strong> means: when this method is called, we don’t pass an instance of the class to it (as we normally do with methods). This means you can put a function inside a class but you can’t access the instance of that class (this is useful when your method does not use the instance).</p>
</blockquote>
<p><code>classmethod</code> must have a reference to a class object as the first parameter, whereas <code>staticmethod</code> can have no parameters at all.</p>
<p>example:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, day=<span class="number">0</span>, month=<span class="number">0</span>, year=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.day = day</span><br><span class="line">        self.month = month</span><br><span class="line">        self.year = year</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_string</span><span class="params">(cls, date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">'-'</span>))</span><br><span class="line">        date1 = cls(day, month, year)</span><br><span class="line">        <span class="keyword">return</span> date1</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_date_valid</span><span class="params">(date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">'-'</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> day &lt;= <span class="number">31</span> <span class="keyword">and</span> month &lt;= <span class="number">12</span> <span class="keyword">and</span> year &lt;= <span class="number">3999</span></span><br><span class="line"></span><br><span class="line">date2 = Date.from_string(<span class="string">'11-09-2012'</span>)</span><br><span class="line">is_date = Date.is_date_valid(<span class="string">'11-09-2012'</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="class-method"><a href="#class-method" class="headerlink" title="class method"></a>class method</h3><p>现在如果有一种需求通过接收一个外部的格式化的字符串(形如dd-mm-yy)需要创造大量的<code>Date</code>的实例。</p>
<p>在C++中可以通过重载的方式实现这种操作(重载Date的构造函数)，但是python没有这种特性。</p>
<p>上述的<code>classmethod</code>方法中，<code>cls</code>这个对象承载的是这个类本身，而不是这个类的实例。并且在<code>cls</code>的子类中也可以获取到这个方法。</p>
<h3 id="static-method"><a href="#static-method" class="headerlink" title="static method"></a>static method</h3><p>静态方法和类方法很像，但是静态方法没有强制性参数的要求。</p>
<p>但是静态方法无法访问这个实例本身，也无法调用类的内部方法和变量。</p>
<p><a href="https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner" target="_blank" rel="noopener">classmethod and staticmethod in stackoverflow</a></p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/01/30/python2.7 基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/01/30/python2.7 基础知识/" class="post-title-link" itemprop="url">python2.7 基础知识</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-01-30 21:13:58" itemprop="dateCreated datePublished" datetime="2018-01-30T21:13:58+08:00">2018-01-30</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-02 11:28:18" itemprop="dateModified" datetime="2019-08-02T11:28:18+08:00">2019-08-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/learning-python/" itemprop="url" rel="index"><span itemprop="name">learning python</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p><a href="http://www.pythondoc.com/pythontutorial27/index.html" target="_blank" rel="noopener">python 入门指南</a></p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><ol>
<li><code>//</code>运算符用于 floor division 而无论操作数是什么类型。</li>
<li>可以使用 <code>**</code> 运算符计算幂乘方</li>
</ol>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol>
<li>使用 原始字符串，方法是在第一个引号前面加上一个 <code>r</code>，例如 <code>r&#39;C:\some\name&#39;</code></li>
<li>字符串文本能够分成多行。一种方法是使用三引号：<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code> 或者 <code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>。行尾换行符会被自动包含到字符串中，但是可以在行尾加上 <code>\</code> 来避免这个行为。</li>
<li>字符串可以由 <code>+</code> 操作符连接(粘到一起)，可以由 <code>*</code> 表示重复</li>
<li>相邻的两个字符串文本自动连接在一起，只用于两个字符串文本，不能用于字符串表达式，如果想连接多个变量或者连接一个变量和一个字符串文本，使用 <code>+</code></li>
<li><p>支持索引和切片。索引用于获得单个字符，切片 让你获得一个子字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">'Python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>:<span class="number">2</span>]  <span class="comment"># characters from position 0 (included) to 2 (excluded)</span></span><br><span class="line"><span class="string">'Py'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">2</span>:<span class="number">5</span>]  <span class="comment"># characters from position 2 (included) to 5 (excluded)</span></span><br><span class="line"><span class="string">'tho'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Python字符串不可以被更改—它们是<strong>不可变</strong>的。因此，赋值给字符串索引的位置会导致错误。</p>
</li>
<li>内置函数 len() 返回字符串长度。</li>
</ol>
<h3 id="See-also"><a href="#See-also" class="headerlink" title="See also"></a>See also</h3><blockquote>
<p><a href="https://docs.python.org/2.7/library/stdtypes.html#typesseq" target="_blank" rel="noopener">Sequence Types — str, unicode, list, tuple, bytearray, buffer, xrange</a><br><br><br>字符串和下节描述的Unicode字符串是 序列类型 的例子，它们支持这种类型共同的操作。</p>
</blockquote>
<blockquote>
<p><a href="https://docs.python.org/2.7/library/stdtypes.html#string-methods" target="_blank" rel="noopener">String Methods</a><br><br><br>字符串和Unicode字符串都支持大量的方法用于基本的转换和查找。<br><br></p>
</blockquote>
<blockquote>
<p><a href="https://docs.python.org/2.7/library/string.html#new-string-formatting" target="_blank" rel="noopener">String Formatting</a><br><br><br>这里描述了使用 str.format() 进行字符串格式化的信息。</p>
</blockquote>
<blockquote>
<p><a href="https://docs.python.org/2.7/library/stdtypes.html#string-formatting" target="_blank" rel="noopener">String Formatting Operations</a><br><br><br>这里描述了旧式的字符串格式化操作，它们在字符串和Unicode字符串是 % 操作符的左操作数时调用。</p>
</blockquote>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ol>
<li>在迭代过程中修改迭代序列不安全(只有在使用链表这样的可变序列时才会有这样的情况)。如果你想要修改你迭代的序列(例如：复制选择项)，你可以迭代它的复本。</li>
<li><p>需要迭代链表索引的话，可以结合使用 range() 和 len()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [&apos;Mary&apos;, &apos;had&apos;, &apos;a&apos;, &apos;little&apos;, &apos;lamb&apos;]</span><br><span class="line">for i in range(len(a)):</span><br><span class="line">    print i, a[i]</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环可以有一个<code>else</code>子句；它在循环迭代完整个列表(对于<code>for</code>)后或执行条件为false(对于<code>while</code>) 时执行，但循环被 <code>break</code>中止的情况下不会执行。</p>
</li>
<li><code>try</code>语句的<code>else</code>子句在未出现异常时运行，循环的<code>else</code>子句在未出现<code>break</code>时运行。</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol>
<li>函数调用 会为函数局部变量生成一个新的符号表。确切地说，所有函数中的变量赋值都是将值存储在<strong>局部符号表</strong>。变量引用首先在局部符号表中查找，然后是包含函数的局部符号表，然后是全局符号表，最后是内置名字表。因此，全局变量不能在函数中直接赋值 (除非用<code>global</code>语句命名)，尽管他们可以被引用。</li>
<li>函数引用的实际参数在函数调用时引入局部符号表，因此，实参总是传值调用(这里的值总是一个对象引用，而不是该对象的值)。</li>
<li>没有 return 语句的函数确实会返回一个值： <code>None</code>。</li>
<li><strong>函数默认值只被赋值一次</strong>。这使得当默认值是可变对象时会有所不同，比如列表、字典或者大多数类的实例。</li>
<li><code>def</code>是一个可执行指令，只有<code>def</code>执行的时候才会计算默认默认参数的值</li>
<li>在函数调用中，关键字的参数必须跟随在位置参数的后面。</li>
<li>引入一个形如<code>**name</code>的参数时，它接收一个字典。形如<code>*name</code>的形式参数，它接收一个元组。</li>
<li>可以在调用函数时加一个<code>*</code>操作符来自动把参数列表拆开。使用 <code>**</code> 操作符分拆关键字参数为字典。</li>
</ol>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">list.append(x)</span><br><span class="line">把一个元素添加到链表的结尾，相当于 a[len(a):] = [x]。</span><br><span class="line"></span><br><span class="line">list.extend(L)</span><br><span class="line">将一个给定列表中的所有元素都添加到另一个列表中，相当于 a[len(a):] = L。</span><br><span class="line"></span><br><span class="line">list.insert(i, x)</span><br><span class="line">在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引。</span><br><span class="line">例如 a.insert(<span class="number">0</span>, x) 会插入到整个链表之前，而 a.insert(len(a), x) 相当于 a.append(x)。</span><br><span class="line"></span><br><span class="line">list.remove(x)</span><br><span class="line">删除链表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。</span><br><span class="line"></span><br><span class="line">list.pop([i])</span><br><span class="line">从链表的指定位置删除元素，并将其返回。</span><br><span class="line">如果没有指定索引，a.pop()返回最后一个元素。元素随即从链表中被删除。</span><br><span class="line"><span class="string">"方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号。"</span></span><br><span class="line"></span><br><span class="line">list.index(x)</span><br><span class="line">返回链表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。</span><br><span class="line"></span><br><span class="line">list.count(x)</span><br><span class="line">返回 x 在链表中出现的次数。</span><br><span class="line"></span><br><span class="line">list.sort(cmp=<span class="literal">None</span>, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br><span class="line">对链表中的元素就地进行排序（参数可以用来自定义排序方法）。</span><br><span class="line"></span><br><span class="line">list.reverse()</span><br><span class="line">就地倒排链表中的元素。</span><br></pre></td></tr></table></figure>
<h3 id="函数式编程工具"><a href="#函数式编程工具" class="headerlink" title="函数式编程工具"></a>函数式编程工具</h3><h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p><code>filter(function, sequence)</code>返回一个 sequence(序列)，包括了给定序列中所有调用 function(item) 后返回值为 true 的元素(如果可能的话，会返回相同的类型)。<br>如果该序列 (sequence)是一个 str, unicode 或者 tuple，返回值必定是同一类型，否则，它总是 list。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p><code>map(function, sequence)</code>为每一个元素依次调用 function(item) 并将返回值组成一个链表返回。</p>
<p>可以传入多个序列，函数也必须要有对应数量的参数，执行时会依次用各序列上对应的元素来调用函数(如果某些序列比其它的短，就用 None 来代替)。如果把 None 做为一个函数传入，则直接返回参数做为替代。</p>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><p><code>reduce(function, sequence)</code>返回一个单值，它是这样构造的：首先以序列的前两个元素调用函数 function，再以返回值和第三个参数调用，依次执行下去。</p>
<p>如果序列中只有一个元素，就返回它，如果序列是空的，就抛出一个异常。</p>
<p>可以传入第三个参数作为初始值。如果序列是空的，就返回初始值，否则函数会先接收初始值和序列的第一个元素，然后是返回值和下一个元素，依此类推。</p>
<h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><p>列表推导式由包含一个表达式的括号组成，表达式后面跟随一个 for 子句，之后可以有零或多个 for 或 if 子句。结果是一个列表，由表达式依据其后面的 for 和 if 子句上下文计算而来的结果构成。</p>
<p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>] <span class="keyword">if</span> x != y]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[str(round(pi, i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>)]</span><br><span class="line">[<span class="string">'3.1'</span>, <span class="string">'3.14'</span>, <span class="string">'3.142'</span>, <span class="string">'3.1416'</span>, <span class="string">'3.14159'</span>]</span><br></pre></td></tr></table></figure></p>
<p>列表推导式可以嵌套。</p>
<p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>matrix = [</span><br><span class="line"><span class="meta">... </span>    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line"><span class="meta">... </span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure></p>
<h3 id="del语句"><a href="#del语句" class="headerlink" title="del语句"></a>del语句</h3><p><code>del</code>语句可以从列表中按给定的索引而不是值来删除一个子项。<br>它不同于有返回值的 pop() 方法。语句 del 还可以从列表中删除切片或清空整个列表(我们以前介绍过一个方法是将空列表赋值给列表的切片)。</p>
<p>del 也可以删除整个变量。</p>
<h2 id="元组和序列"><a href="#元组和序列" class="headerlink" title="元组和序列"></a>元组和序列</h2><p>一个元组由数个逗号分隔的值组成。</p>
<p>元组在输出时总是有括号的，以便于正确表达嵌套结构。在输入时可以有或没有括号，不过经常括号都是必须的(如果元组是一个更大的表达式的一部分)。</p>
<p>不能给元组的一个独立的元素赋值(尽管你可以通过联接和切割来模拟)。还可以创建包含可变对象的元组，例如链表。</p>
<p>元组是<strong>不可变的</strong>，通常包含不同种类的元素并通过分拆或索引访问（如果是 namedtuples，甚至可以通过属性）。列表是<strong>可变的</strong>，它们的元素通常是相同的类型并通过迭代访问。</p>
<p>构造包含零个或一个元素的元组：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>empty = ()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>singleton = <span class="string">'hello'</span>,    <span class="comment"># &lt;-- note trailing comma</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>可变参数(multiple assignment)其实只是元组封装和序列拆封的一个结合。</p>
</blockquote>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合是一个无序不重复元素的集。集合对象还支持union(联合)，intersection(交)，difference(差)和 sysmmetric difference(对称差集)等数学运算。</p>
<p>大括号或set()函数可以用来创建集合。注意：想要创建空集合，你必须使用 set() 而不是 {}。后者用于创建空字典。</p>
<p>类似列表推导式，集合也有推导式语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'abracadabra'</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'abc'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典以 关键字 为索引，关键字可以是任意<strong>不可变类型</strong>，通常用字符串或数值。如果元组中只包含字符串和数字，它可以作为关键字，如果它直接或间接地包含了可变对象，就不能当做关键字。</p>
<p>字典的主要操作是依据键来存储和析取值。也可以用<code>del</code>来删除键：值对(key:value)。</p>
<p>对一个字典执行<code>keys()</code>将返回一个字典中所有关键字组成的无序列表(如果你想要排序，只需使用 sorted())。</p>
<p>dict() 构造函数可以直接从 key-value 对中创建字典:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict([(<span class="string">'sape'</span>, <span class="number">4139</span>), (<span class="string">'guido'</span>, <span class="number">4127</span>), (<span class="string">'jack'</span>, <span class="number">4098</span>)])</span><br></pre></td></tr></table></figure></p>
<p>字典推导式可以从任意的键值表达式中创建字典:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果关键字都是简单的字符串，有时通过关键字参数指定 key-value 对更为方便:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict(sape=<span class="number">4139</span>, guido=<span class="number">4127</span>, jack=<span class="number">4098</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块可以包含执行语句，一般用来初始化模块，仅在第一次被导入的地方执行一次。</p>
<p>每个模块都有自己私有的符号表，被模块内所有的函数定义作为全局符号表使用。因此，模块的作者可以在模块内部使用全局变量，而无需担心它与某个用户的全局变量意外冲突。也可以引用模块函数的表示法访问模块的全局变量，<code>modname.itemname</code>。</p>
<blockquote>
<p>出于性能考虑，每个模块在每个解释器会话中只导入一遍。因此，如果修改了模块，需要重启解释器或者如果想交互式的测试这么一个模块，可以用<code>reload()</code>重新加载，例如 reload(modulename)。</p>
</blockquote>
<p>如果调用python module.py执行某个模块，此时改模块的<code>__name__</code>被设置为<code>__main__</code>。如果在模块后加入代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<p>就可以让此文件像作为模块导入时一样作为脚本执行。此代码只有在模块作为 “main” 文件执行时才被调用。如果模块被导入，则不会执行这段代码。</p>
<p>当导入一个叫<code>module</code>的模块时，解释器现在当前的目录中搜索名为<code>module.py</code>的文件，如果没有找到的话，接着会到sys.path变量中给出的目录列表中查找。</p>
<p>sys.path变量的初始值：</p>
<ol>
<li>输入脚本的目录(当前目录)。</li>
<li>环境变量<code>PYTHONPATH</code>表示的目录列表中搜索</li>
<li>Python 默认安装路径中搜索。</li>
</ol>
<p>如果在<code>name.py</code>所在的目录下存在一个名为<code>name.pyc</code>的文件，它会被视为<code>name</code>模块的预编译(<code>byte-compiled</code>,二进制编译版本)，对于引用了大量标准模块的短程序，可以提高启动速度。用于创建<code>name.pyc</code>的这一版<code>spam.py</code>的修改时间记录在<code>spam.pyc</code>文件中，如果两者不匹配，<code>.pyc</code>文件就被忽略。</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>为了让 Python 将目录当做内容包，目录中必须包含<code>__init__.py</code>文件。这是为了避免一个含有烂俗名字的目录无意中隐藏了稍后在模块搜索路径中出现的有效模块，比如<code>string</code>。最简单的情况下，只需要一个空的<code>__init__.py</code>文件即可。当然它也可以执行包的初始化代码，或者定义<code>__all__</code>变量。</p>
<p>执行<code>from package import *</code>时，如果包中的<code>__init__.py</code>代码定义了一个名为<code>__all__</code>的列表，就会按照列表中给出的模块名进行导入。</p>
<p>显式或隐式相对位置导入都基于当前模块的命名。因为主模块的名字总是 <code>__main__</code>，Python 应用程序的主模块应该总是用绝对导入。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>try 语句按如下方式工作：</p>
<ul>
<li>首先，执行 try 子句(在 try 和 except 关键字之间的部分)。</li>
<li>如果没有异常发生，except 子句在 try 语句执行完毕后就被忽略了。</li>
<li><p>如果在 try 子句执行过程中发生了异常，那么该子句其余的部分就会被忽略。<br>如果异常匹配于 except 关键字后面指定的异常类型，<br>就执行对应的 except 子句。<br>然后继续执行 try 语句之后的代码。</p>
</li>
<li><p>如果发生了一个异常，在 except 子句中没有与之匹配的分支，<br>它就会传递到上一级 try 语句中。<br>如果最终仍找不到对应的处理语句，它就成为一个 未处理异常，终止程序运行，显示提示信息。</p>
</li>
</ul>
<p>一个 try 语句可能包含多个 except 子句，分别指定处理不同的异常。至多只会有一个分支被执行。异常处理程序只会处理对应的 try 子句中发生的异常，在同一个 try 语句中，其他子句中发生的异常则不作处理。一个 except 子句可以在括号中列出多个异常的名字，例如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> (RuntimeError, TypeError, NameError):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<p>最后一个 except 子句可以省略异常名称，以作为通配符使用。你需要慎用此法，因为它会轻易隐藏一个实际的程序错误！可以使用这种方法打印一条错误信息，然后重新抛出异常(允许调用者处理这个异常):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">raise</span></span><br></pre></td></tr></table></figure></p>
<p>try … except 语句可以带有一个 else子句 ，该子句只能出现在所有 except 子句之后。当 try 语句没有抛出异常时，需要执行一些代码，可以使用这个子句。</p>
<p><code>raise</code>语句允许程序员强制抛出一个指定的异常。要抛出的异常由<code>raise</code>的唯一参数标识。它必需是一个异常实例或异常类(继承自 Exception 的类)。<br>如果你需要明确一个异常是否抛出，但不想处理它，<code>raise</code>语句可以让你很简单的重新抛出该异常。</p>
<p>不管有没有发生异常，finally子句 在程序离开 try 后都一定会被执行。当 try 语句中发生了未被 except 捕获的异常(或者它发生在 except 或 else 子句中)，在 finally 子句执行完后它会被重新抛出。try 语句经由 break，continue 或 return 语句退出也一样会执行 finally 子句。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> KeyboardInterrupt</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Goodbye, world!'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h3><p>命名空间 是从命名到对象的映射。当前命名空间主要是通过 Python 字典实现的。</p>
<p>不同命名空间中的命名没有任何联系。</p>
<p>不同的命名空间在不同的时刻创建，有不同的生存期。包含内置命名的命名空间在 Python 解释器启动时创建，会一直保留，不被删除。模块的全局命名空间在模块定义被读入时创建，通常，模块命名空间也会一直保存到解释器退出。由解释器在最高层调用执行的语句，不管它是从脚本文件中读入还是来自交互式输入，都是<code>__main__</code>模块的一部分，所以它们也拥有自己的命名空间(内置命名也同样被包含在一个模块中，它被称作<code>__builtin__</code>)。</p>
<p>当调用函数时，就会为它创建一个局部命名空间，并且在函数返回或抛出一个并没有在函数内部处理的异常时被删除。每个递归调用都有自己的局部命名空间。</p>
<h4 id="作用于访问顺序："><a href="#作用于访问顺序：" class="headerlink" title="作用于访问顺序："></a>作用于访问顺序：</h4><p>包含局部命名的使用域在最里面，首先被搜索；其次搜索的是中层的作用域，这里包含了同级的函数；最后搜索最外面的作用域，它包含内置命名。</p>
<ul>
<li>首先搜索最内层的作用域，它包含局部命名任意函数包含的作用域，是内层嵌套作用域搜索起点，包含非局部，但是也非全局的命名</li>
<li>接下来的作用域包含当前模块的全局命名</li>
<li>最外层的作用域(最后搜索)是包含内置命名的命名空间。</li>
</ul>
<p>一个定义于某模块中的函数的全局作用域是该模块的命名空间，而不是该函数的别名被定义或调用的位置。</p>
<h3 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h3><p>类对象支持两种操作：属性引用和实例化。</p>
<p>类定义了<code>__init__()</code>方法的话，类的实例化操作会自动为新创建的类实例调用<code>__init__()</code>方法。</p>
<p>和局部变量一样，数据属性不需要声明，第一次使用时它们就会生成。</p>
<p>类中所有(用户定义)的函数对象对应它的实例中的方法。实例中的函数是方法对象，不是函数对象。</p>
<p>例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="string">"""A simple example class"""</span></span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line">x = MyClass()</span><br></pre></td></tr></table></figure></p>
<p>方法的特别之处在于实例对象作为函数的第一个参数传给了函数。</p>
<p>调用<code>x.f()</code>相当于<code>MyClass.f(x)</code></p>
<blockquote>
<p>引用非数据属性的实例属性时，会搜索它的类。如果这个命名确认为一个有效的函数对象类属性，就会将实例对象和函数对象封装进一个抽象对象：这就是方法对象。以一个参数列表调用方法对象时，它被重新拆 封，用实例对象和原始的参数列表构造一个新的参数列表，然后函数对象调用这个新的参数列表。</p>
</blockquote>
<p>一般来说，<code>实例变量</code>用于对每一个实例都是唯一的数据，<code>类变量</code>用于类的所有实例共享的属性和方法。</p>
<p>数据属性会覆盖同名的方法属性。</p>
<p>方法可以像引用普通的函数那样引用全局命名。与方法关联的全局作用域是包含类定义的模块(类本身永远不会做为全局作用域使用)。</p>
<blockquote>
<p>对于 C++ 程序员来说，Python 中的所有方法本质上都是虚方法</p>
</blockquote>
<p>派生类中的覆盖方法可能是想要扩充而不是简单的替代基类中的重名方法。有一个简单的方法可以直接调用基类方法，只要调用：<code>BaseClassName.methodname(self, arguments)</code>。</p>
<h2 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h2><ul>
<li><p>在Python源文件中可以使用非 ASCII 编码。最好的方法是在 #! 行的后面再增加一行特殊的注释来定义源文件的编码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: encoding -*-</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://www.pythondoc.com/pythontutorial27/classes.html#tut-iterators" target="_blank" rel="noopener">迭代器</a></p>
</li>
<li><p><a href="http://www.pythondoc.com/pythontutorial27/classes.html#tut-generators" target="_blank" rel="noopener">生成器</a></p>
</li>
<li><p><a href="http://www.pythondoc.com/pythontutorial27/inputoutput.html" target="_blank" rel="noopener">格式化输入和输出</a></p>
</li>
<li><p><a href="http://www.pythondoc.com/pythontutorial27/inputoutput.html#tut-files" target="_blank" rel="noopener">文件读写</a></p>
</li>
<li><p>序列中循环时，索引位置和对应值可以使用<code>enumerate()</code>函数同时得到:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate([<span class="string">'tic'</span>, <span class="string">'tac'</span>, <span class="string">'toe'</span>]):</span><br><span class="line"><span class="meta">... </span>    print(i, v)</span><br></pre></td></tr></table></figure>
</li>
<li><p>同时循环两个或更多的序列，可以使用 zip() 整体打包:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>questions = [<span class="string">'name'</span>, <span class="string">'quest'</span>, <span class="string">'favorite color'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>answers = [<span class="string">'lancelot'</span>, <span class="string">'the holy grail'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> q, a <span class="keyword">in</span> zip(questions, answers):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">'What is your &#123;0&#125;?  It is &#123;1&#125;.'</span>.format(q, a)</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要逆向循环序列的话，先正向定位序列，然后调用 reversed() 函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> reversed(xrange(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)):</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br></pre></td></tr></table></figure>
</li>
<li><p>sorted() 函数不改动原序列，而是生成一个新的已排序的序列。</p>
</li>
<li><p>遍历字典时，使用 iteritems() 方法可以同时得到键和对应的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>knights = &#123;<span class="string">'gallahad'</span>: <span class="string">'the pure'</span>, <span class="string">'robin'</span>: <span class="string">'the brave'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> knights.iteritems():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> k, v</span><br></pre></td></tr></table></figure>
</li>
<li><p>在循环内部修改正在遍历的序列，应首先制作副本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">'cat'</span>, <span class="string">'window'</span>, <span class="string">'defenestrate'</span>]</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words[:]:  <span class="comment"># Loop over a slice copy of the entire list.</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>print 用一个逗号结尾就可以禁止输出换行</p>
</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li><code>is</code> 用来判断两个对象是否是同一个对象，<code>==</code> 用来判断两个对象是否相等</li>
</ol>
<h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><ul>
<li>使用 4 空格缩进，而非 TAB。</li>
<li>在小缩进(可以嵌套更深)和大缩进(更易读)之间，4 空格是一个很好的折中。TAB 引发了一些混乱，最好弃用。</li>
<li>折行以确保其不会超过 79 个字符。</li>
<li>这有助于小显示器用户阅读，也可以让大显示器能并排显示几个代码文件。</li>
<li>使用空行分隔函数和类，以及函数中的大块代码。</li>
<li>可能的话，注释独占一行</li>
<li>使用文档字符串</li>
<li>把空格放到操作符两边，以及逗号后面，但是括号里侧不加空格：a = f(1, 2) + g(3, 4)。</li>
<li>统一函数和类命名。</li>
<li>推荐类名用 驼峰命名，函数和方法名用小写_和_下划线。总是用self作为方法的第一个参数(关于类和方法的知识详见 初识类)。</li>
<li>不要使用花的编码，如果你的代码的目的是要在国际化环境。Python的默认情况下，UTF-8，甚至普通的 ASCII 总是工作的最好。</li>
<li>同样，也不要使用非 ASCII 字符的标识符，除非是不同语种的会阅读或者维护代码。</li>
</ul>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/logo1.jpg"
      alt="Uyouii">
  <p class="site-author-name" itemprop="name">Uyouii</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/Uyouii" title="GitHub &rarr; https://github.com/Uyouii" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:taiyoudong@gmail.com" title="E-Mail &rarr; mailto:taiyoudong@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Uyouii</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
    
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  <script src="/js/utils.js?v=7.3.0"></script>

  
  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>



  

  <script src="/js/next-boot.js?v=7.3.0"></script>

  

  

  


  

































    


</body>
</html>
