<!DOCTYPE html>





<html class="theme-next gemini" lang="en">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Uyouii&#39;s Blogs">
<meta property="og:url" content="https://uyouii.github.io/page/3/index.html">
<meta property="og:site_name" content="Uyouii&#39;s Blogs">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Uyouii&#39;s Blogs">
  <link rel="canonical" href="https://uyouii.github.io/page/3/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Uyouii's Blogs</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Uyouii's Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">There are many things need to learn.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
    </ul>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/08-内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/08-内存管理/" class="post-title-link" itemprop="url">08 内存管理</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:03:34 / Modified: 18:12:41" itemprop="dateCreated datePublished" datetime="2019-08-03T18:03:34+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/深入理解Linux内核/" itemprop="url" rel="index"><span itemprop="name">深入理解Linux内核</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>RAM的某些部分永久地分配给内核，并用来存放内核代码以及静态内核数据结构。</p>
<p>RAM的其余部分称为动态内存(dynamic memory)</p>
<h2 id="页框管理"><a href="#页框管理" class="headerlink" title="页框管理"></a>页框管理</h2><h3 id="页描述符"><a href="#页描述符" class="headerlink" title="页描述符"></a>页描述符</h3><p>内核需要记录每个页框当前的状态。</p>
<p>例如：内核需要区分哪些页框包含的是属于进程的页，哪些页框包含的是内核代码或内核数据。内核还必须能够却东动态内存中的页是否空闲。在以下情况下页框是不空闲的：包含用户态进程的数据、某个软件高速缓存的数据、动态内存分配的内核数据结构、设备驱动程序缓冲的数据、内核模块的代码等等。</p>
<p>页框的状态信息保存在一个类型为page的也描述符中。所有的页描述符存放在<code>mem_map</code>数组中。因为每个描述符长度为32字节，所以<code>mem_map</code>所需要的空间略小于整个RAM的1%。</p>
<blockquote>
<p>页描述符字段</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>unsigned long</td>
<td>flags</td>
<td>一组标志。也对页框所在的管理区进行编号</td>
</tr>
<tr>
<td>atomic_t</td>
<td>_count</td>
<td>页框的引用计数器</td>
</tr>
<tr>
<td>atomic_t</td>
<td>_mapcount</td>
<td>页框中页表项数目（如果没有则为-1）</td>
</tr>
<tr>
<td>unsigned long</td>
<td>private</td>
<td>可用于正在使用页的内核成分（例如，在缓冲页的情况下它是一个缓冲头指针）。如果页是空闲的，则该字段由伙伴系统使用。</td>
</tr>
<tr>
<td>struct address_space *</td>
<td>mapping</td>
<td>当页被插入页高速缓存中时使用，或者当页属于匿名区时使用</td>
</tr>
<tr>
<td>unsigned long</td>
<td>index</td>
<td>作为不同含义被几种内核成分使用。例如，它在页磁盘映像或者匿名区中标识存放在页框中的数据的位置，或者它存放一个换出页标识符</td>
</tr>
<tr>
<td>struct list_head</td>
<td>lru</td>
<td>包含页的最近最少使用(LRU)双向链表的指针</td>
</tr>
</tbody>
</table>
<ul>
<li><code>_count</code>：页的引用计数器。如果该字段为-1，则相应页框空闲，并可分配给任一进程或内核本身；如果该字段的值大于0或等于0，则说明页框被分配给了一个或多个进程，或用于存放一些内核数据结构。<code>page_count()</code>函数返回<code>_count</code>加1后的值，也就是该页的使用者的数目。</li>
<li><code>flags</code>：包含多达32个用来描述页框状态的标志。</li>
</ul>
<blockquote>
<p>描述页框状态的标志</p>
</blockquote>
<table>
<thead>
<tr>
<th>标志名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>PG_locked</td>
<td>页被锁定。例如，在磁盘I/O操作中涉及的页</td>
</tr>
<tr>
<td>PG_error</td>
<td>在传输页时发生I/O错误</td>
</tr>
<tr>
<td>PG_referenced</td>
<td>刚刚访问过的页</td>
</tr>
<tr>
<td>PG_uptodate</td>
<td>在完成读操作后置位，除非发生磁盘I/O错误</td>
</tr>
<tr>
<td>PG_dirty</td>
<td>页已经被修改</td>
</tr>
<tr>
<td>PG_lru</td>
<td>页在活动或非活动页链表中</td>
</tr>
<tr>
<td>PG_active</td>
<td>页在活动页链表中</td>
</tr>
<tr>
<td>PG_slab</td>
<td>包含在slab中的页框</td>
</tr>
<tr>
<td>PG_highmem</td>
<td>页框属于<code>ZONE_HIGHMEM</code>管理区</td>
</tr>
<tr>
<td>PG_checked</td>
<td>由一些文件系统（如Ext2和Ext3）使用的标志</td>
</tr>
<tr>
<td>PG_arch_1</td>
<td>在80x86体系结构上没有使用</td>
</tr>
<tr>
<td>PG_reserved</td>
<td>页框留给内核代码或没有使用</td>
</tr>
<tr>
<td>PG_private</td>
<td>页描述符的private字段存放了有意义的数据</td>
</tr>
<tr>
<td>PG_writeback</td>
<td>正在使用<code>writepage</code>方法将页写到磁盘上</td>
</tr>
<tr>
<td>PG_nosave</td>
<td>系统挂起/唤醒时使用</td>
</tr>
<tr>
<td>PG_compound</td>
<td>通过扩展分页机制处理页框</td>
</tr>
<tr>
<td>PG_swapcache</td>
<td>页属于交换高速缓存</td>
</tr>
<tr>
<td>PG_mappedtodisk</td>
<td>页框中的所有数据对应于磁盘上分配的块</td>
</tr>
<tr>
<td>PG_reclaim</td>
<td>为回收内存对页已经做了写入磁盘的标记</td>
</tr>
<tr>
<td>PG_nosave_free</td>
<td>系统挂起/恢复时使用</td>
</tr>
</tbody>
</table>
<h3 id="非一致内存访问-NUMA"><a href="#非一致内存访问-NUMA" class="headerlink" title="非一致内存访问(NUMA)"></a>非一致内存访问(NUMA)</h3><p>Linux 2.6支持<strong>非一致内存访问(Non-Uniform Memory Access, NUMA)</strong>模型，在这种模型中，给定CPU对不同的内存单元的访问时间可能不一样。</p>
<p>系统的物理内存被划分为几个节点(node)。在一个单独的节点内，任一给定CPU访问页面所需的时间都是相同的。然而，对不同CPU，这个时间就可能不同。</p>
<h3 id="内存管理区"><a href="#内存管理区" class="headerlink" title="内存管理区"></a>内存管理区</h3><p>linux把内存节点的物理内存划分为3个管理区(zone)：</p>
<ul>
<li>ZONE_DMA：包含低于16MB的内存页框</li>
<li>ZONE_NORMAL：包含高于16MB且低于896MB的内存页框</li>
<li>ZONE_HIGHMEM：包含从896MB开始高于896MB的内存页框</li>
</ul>
<p>ZONE_DMA和ZONE_NORMAL区包含内存的”常规”页框，通常把它们线性映射到线性地址空间的第4个GB，内核就可以直接进行访问。相反，ZONE_HIGHMEM区包含的内存页就不能由内核直接访问，尽管它们也线性地映射到了线性地址空间的第4个GB。在64位体系结构上ZONE_HIGHMEM区总是空的。</p>
<h3 id="保留的页框池"><a href="#保留的页框池" class="headerlink" title="保留的页框池"></a>保留的页框池</h3><p>可以用两种不同的方法来满足内存分配请求，如果有足够的空闲内存可使用，请求就会被立刻满足。否则，必须回收一些内存，并且将发出请求的内核控制路径阻塞，直到有内存被释放。</p>
<p>但是，当请求内存时，一些内核控制路径不能被阻塞——例如，这种情况发生在处理中断或在执行临界区的代码时。在这种情况下，一条内核控制路径应当产生<strong>原子内核分配请求</strong> 。原子请求从不被阻塞，如果没有足够的空闲页，则仅仅是分配失败而已。</p>
<p>内核为原子内存分配器请求保留了一个页框池，只有在内存不足时才使用。</p>
<p>保留内存的数量(以KB为单位)存放在<code>min_free_kbytes</code>变量中。初始值在内核初始化时被设置，并取决于直接映射到内核线性地址空间的第4个GB的物理内存的数量——也就是说，取决于包含在ZONE_DMA和ZONE_NORMAL内存管理区内的页框数目:<br>$$<br>保留池的大小 = <a href="KB"> \sqrt{16 \times 直接映射内存} </a><br>$$<br>但是，<code>min_free_kbytes</code>的初始值不能小于128也不能大于65536。</p>
<h3 id="分区页框分配器"><a href="#分区页框分配器" class="headerlink" title="分区页框分配器"></a>分区页框分配器</h3><p>分区页框分配器(zoned page frame allocator)的内核子系统，处理对连续页框组的内存分配请求。</p>
<blockquote>
<p>分区页框分配器的组成</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/19185DB023764A068086F3C04D8048E0?method=download&amp;shareKey=7a9904e2e6d0bebb57a9f7a0dd9bae42" alt></p>
<p>其中，管理区分配器部分接受动态内存的分配与释放的请求。在请求分配的情况下，该部分搜索一个能满足所请求的一组连续页框内存的管理区。在每个管理区内，页框被名为”伙伴系统”的部分来处理。为达到更好的系统性能，小部分页框保留在高速缓存中用于快速地满足单个页框地分配请求。</p>
<h3 id="高端内存页框地内核映射"><a href="#高端内存页框地内核映射" class="headerlink" title="高端内存页框地内核映射"></a>高端内存页框地内核映射</h3><p>与直接映射地物理内存地末端、高端内存地始端所应对地线性地址存放在<code>high_memory</code>变量中，它被设置为896MB。896MB边界以上地页框并不映射在内核线性地址空间的第4个GB，因此，内核不能直接访问它们。也就意味着，返回所分配页框线性地址的页分配器函数不适用于高端内存，即不适用于<code>ZONE_HIGHMEM</code>内存管理区内的页框。</p>
<p>64位硬件平台上不存在这个问题，因为可使用的线性地址空间远大于能安装的RAM大小，简言之，这些体系结构的<code>ZONE_HIGHMEM</code>管理区总是空的。</p>
<h3 id="伙伴系统算法"><a href="#伙伴系统算法" class="headerlink" title="伙伴系统算法"></a>伙伴系统算法</h3><p>内存分配算法必须解决外部碎片问题(external fragmentation)。</p>
<p>从本质上说，避免外部随眠的方法有两种：</p>
<ul>
<li>利用分页单元把一组分连续的空闲页框映射到连续的线性地址空间</li>
<li>开发一种适当的技术来记录现存的空闲连续页框块的情况，以尽量避免位满足对小块的请求而分割大的空闲块。</li>
</ul>
<p>基于下面的原因，内核采取第二种方法：</p>
<ul>
<li>在某些情况下，连续的页框确实是必要的，因为连续的线性地址不足以满足请求。</li>
<li>即使连续页框的分配并不是很重要，但它在保持内核页表不变的方面所起的作用也是不容忽视的。（频繁地修改页表势必导致平均访问内存次数增加，因为这会使CPU频繁地刷新转换后援缓冲器(TLB)的内容。</li>
<li>内核通过4MB的页可以访问大块连续物理内存。这样减少了TLB的失效率，因此提高了内存的平均速度。</li>
</ul>
<p>Linux采用著名的伙伴系统(buddy system)算法来解决外部碎片的问题。把所有空闲页框分组位11块链表，每个块链表分别包含大小为1,2,4,8,16,32,64,128,256,512,1024个连续的页框。对1024个页框的最大请求对应着4MB大小的连续RAM块。</p>
<p>内核试图把大小为b的一对空闲伙伴合并为要给大小为2b的单都块。满足以下条件的两个块称为伙伴：</p>
<ul>
<li>两个块具有相同的大小，记作b。</li>
<li>它们的物理地址是连续的。</li>
<li>第一块的第一个页框的物理地址是$2 \times b \times 2^{12}$的倍数</li>
</ul>
<p>该算法是迭代的，如果它成功合并所释放的块，它会试图合并2b的块，以再次试图形成更大的块。</p>
<h3 id="每CPU页框高速缓存"><a href="#每CPU页框高速缓存" class="headerlink" title="每CPU页框高速缓存"></a>每CPU页框高速缓存</h3><p>内核经常请求和释放单个页框。为了提升系统性能，每个内存管理区定义了一个”每CPU”页框高速缓存。所有”每CPU”高速缓存包含一些预先分配的页框，它们被用于满足本地CPU发出的单一内存请求。</p>
<p>实际上，这里为每个内存管理区和每个CPU提供了两个高速缓存：一个热高速缓存，它存放的页框中所包含的内容很可能就在CPU硬件高速缓存中；还有一个冷高速缓存。</p>
<p>如果内核或用户态进程在刚分配到页框后就立即向页框写，那么从热高速缓存中获取页框就对系统性能有利。实际上，每次对页框储存单元的访问都会导致从另一个页框中给硬件高速缓存“窃取”一行——当然，除非硬件高速缓存包含有一行：它映射刚被访问的“热”页框单元。</p>
<p>反过来，如果页框将要被DMA操作填充，那么从冷高速缓存中获取页框是方便的。在这种情况下，不会涉及CPU，并且硬件高速缓存的行不会被修改。冷高速缓存获得页框为其他类型的内存分配保存了热页框储备。</p>
<p>实现每CPU页框高速缓存的主要数据结构存放在内存管理区描述符的pageset字段中的一个<code>per_cpu_pageset</code>数据数据结构。该数组包含为每个CPU提供的一个元素；这个元素依次由两个<code>per_cpu_pageset</code>描述符组成，一个留给热高速缓存而另一个留给冷高速缓存。</p>
<blockquote>
<p>per_cpu_pages描述符的字段</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>count</td>
<td>高速缓存中的页框个数</td>
</tr>
<tr>
<td>int</td>
<td>low</td>
<td>下界，表示高速缓存需要补充</td>
</tr>
<tr>
<td>int</td>
<td>high</td>
<td>上界，表示高速缓存用尽</td>
</tr>
<tr>
<td>int</td>
<td>batch</td>
<td>在高速缓存中将要添加或删去的页框个数</td>
</tr>
<tr>
<td>struct list_head</td>
<td>list</td>
<td>高速缓存中包含的页框描述符链表</td>
</tr>
</tbody>
</table>
<p>内核使用两个位标志来监视热高速缓存和冷高速缓存大小：</p>
<ul>
<li>如果页框个数低于下界low，内核通过从伙伴系统中分配batch个单一页框来补充对应的高速缓存</li>
<li>如果页框个数高于上界high，内核从高速缓存释放batch个页框到伙伴系统中。</li>
</ul>
<p>值batch、low和high本质上取决于内存管理区中包含的页框个数。</p>
<h2 id="内存区管理"><a href="#内存区管理" class="headerlink" title="内存区管理"></a>内存区管理</h2><p>伙伴算法系统采用页框作为基本内存区，这适合对于大块内存的请求。</p>
<p>为了存放很少的字节而分配一整个页框这显然是一种浪费，取而代之的正确方法就是引入一种新的数据结构来描述在同一页框中如何分配小内存区。但是也引出了一个新的问题，即所谓的内部碎片(internal fragmentation)。内部碎片的产生主要是由于请求内存大小与分配给它的大小不匹配造成的。</p>
<h3 id="slab分配器"><a href="#slab分配器" class="headerlink" title="slab分配器"></a>slab分配器</h3><p>算法基于以下前提：</p>
<ul>
<li>所存放的数据结构的类型可以影响内存区的分配方式。slab分配器概念扩充了这种思想，并把内存区看作对象(object)。为了避免重复初始化对象，slab分配器并不丢弃已经分配的对象，而是释放它们但把它们保存在内存中。当以后又要请求新的对象时，就可以从内存获取而不用重新初始化。</li>
<li>内核函数倾向于反复请求同一类型的内存区。例如，只要内核创建一个新进程，它就要为一些固定大小的表[如进程描述符、打开文件对象等]分配内存区。当进程结束时，包含这些表的内存区还可以被重新使用。因为进程的创建和撤销非常频繁，在没有slab分配器时，内核把时间浪费在反复分配和回收哪些包含在同一内存区的页框上；slab分配器把那些页框保存在高速缓存中并很快地重新使用它们。</li>
<li>对内存区地请求可以根据它们发生地频率来分类。对于预期频繁请求一个特定大小地内存区而言，可以通过创建一组具有适当大小地专用对象来高效地处理，由此以避免内部碎片的产生。另一种情况，对于很少遇到的内存区的大小，可以通过基于一系列几何分布大小（如早期linux版本使用的2的幂次方大小）的对象的分配模式来处理，即使这种方法会导致内部碎片的产生。</li>
<li>在引入对象的大小不是几何分布的情况下，也就是说，数据结构的起始物理地址不是2的幂次，这可以借助处理器硬件高速缓存而导致较好的性能。</li>
<li>硬件高速缓存的高性能又是尽可能地限制对伙伴系统分配器调用的另一个理由，因为对伙伴系统函数的每次调用都”弄脏”硬件高速缓存，所以增加了对内存的平均访问时间。内核函数对硬件高速缓存的影响就是所谓的函数“足迹(footprint)”，其定义为函数结束时重写高速缓存的百分比。显而易见，大的“足迹”导致内核函数刚执行之后较慢的代码执行，因为硬件高速缓存此时填满了无用的信息。</li>
</ul>
<p>slab分配器把对象分组放进高速缓存。每个高速缓存都是同种类型对象的一种“储备”。</p>
<p>包含高速缓存的主内存区被划分为多个slab，每个slab由一个或多个连续的页框组成，这些页框中既包含已分配的对象，也包含空闲的对象。</p>
<blockquote>
<p>slab分配器组成</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/B97BC13B41B548DCA7A209C42D6560A1?method=download&amp;shareKey=b788201cea31b0592f8bb945f2f55b34" alt></p>
<h3 id="高速缓存描述符"><a href="#高速缓存描述符" class="headerlink" title="高速缓存描述符"></a>高速缓存描述符</h3><p>每个高速缓存描述符由kmem_cache_t(等价于struct kmem_cache_s类型)类型的数据结构来描述的。</p>
<p>……</p>
<h3 id="slab-描述符"><a href="#slab-描述符" class="headerlink" title="slab 描述符"></a>slab 描述符</h3><p>高速缓存中的每个slab都有自己的类型为slab的描述符。</p>
<blockquote>
<p>slab 描述符字段</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>struct list_head</td>
<td>list</td>
<td>slab描述符的三个双向循环链表中的一个(在高速缓存描述符的kmem_list3结构中的slabs_full、slabs_partial或slabs_free链表)使用的指针</td>
</tr>
<tr>
<td>unsigned long</td>
<td>colouroff</td>
<td>slab中第一个对象的偏移</td>
</tr>
<tr>
<td>void *</td>
<td>s_mem</td>
<td>slab中的第一个对象(或者已被分配，或者空闲)的地址</td>
</tr>
<tr>
<td>unsigned int</td>
<td>inuse</td>
<td>当前正在使用的（分空闲）slab中的对象个数</td>
</tr>
<tr>
<td>kmem_bufctl_t</td>
<td>free</td>
<td>slab中下一个空闲对象的下标，如果没有剩下空闲对象则为BUFCTL_END</td>
</tr>
</tbody>
</table>
<p>slab描述符可能存放在两个地方：</p>
<ul>
<li>外部slab描述符 ：存放在slab外部，位于cache_sizes指向的一个不适合ISA DMA的普通高速缓存中。</li>
<li>内部slab描述符：存放在slab内部，位于分配给slab的第一个页框的起始位置。</li>
</ul>
<p>当对象小于512MB时，或者当内部碎片为slab描述符和对象描述符在slab中留下足够的空间时，slab分配器选择第二种方案。如果slab描述符存放在slab外部，那么高速缓存描述符的flags字段中的CFLGS_OFF_SLAB标志置为1；否则它被置为0。</p>
<blockquote>
<p>高速缓存描述符与slab描述符之间的关系</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/A2E1AA35EC40482EB3333DAA984B4726?method=download&amp;shareKey=20335df2a5c4d6d42efce4eebb63b0fb" alt></p>
<h3 id="给高速缓存分配slab"><a href="#给高速缓存分配slab" class="headerlink" title="给高速缓存分配slab"></a>给高速缓存分配slab</h3><p>一个新创建的高速缓存没有包含任何slab。只有当以下两个条件都为真时，才给高速缓存分配slab：</p>
<ul>
<li>已发出一个分配新对象的请求</li>
<li>高速缓存不包含任何空闲对象</li>
</ul>
<h3 id="从高速缓存撤销slab"><a href="#从高速缓存撤销slab" class="headerlink" title="从高速缓存撤销slab"></a>从高速缓存撤销slab</h3><p>在两种条件下才能撤销slab：</p>
<ul>
<li>slab高速缓存中有太多空闲的对象</li>
<li>被周期性调用的定时器函数确定是否有完全未使用的slab能被释放</li>
</ul>
<h3 id="对齐内存中的对象"><a href="#对齐内存中的对象" class="headerlink" title="对齐内存中的对象"></a>对齐内存中的对象</h3><p>slab分配器所管理的对象可以在内存中进行对齐，也就是说，存放它们的内存单元的起始物理地址是一个给定常量的倍数，通常是2的倍数。这个常量就是对齐因子（alignment factor)。</p>
<p>slab分配器所允许的最大对其因子是4096，即页框大小。</p>
<p>通常情况下，如果内存单元的物理地址是字大小（即计算机的内部内存总线的宽度）对齐的，那么，微机对内存单元的存取会非常快。</p>
<h3 id="slab着色"><a href="#slab着色" class="headerlink" title="slab着色"></a>slab着色</h3><p>同一硬件高速缓存行可以映射RAM中很多不同的块。相同大小的对象倾向于存放在高速缓存内相同的偏移量处。</p>
<p>在不同slab内具有相同偏移量的对象最终很可能映射在同一高速缓存行中。</p>
<p>高速缓存的硬件可能因此而花费内存周期在同一高速缓存行与RAM内存单元之间来来往往传送两个对象，而其他的高速缓存行并未充分使用。</p>
<p>slab通过一种叫做slab着色（slab coloring）的策略，尽量降低高速缓存这种不愉快的行为。</p>
<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>内存池（memery pool）是linux 2.6的一个新特性。基本上将，一个内存池允许一个内核成分，如块设备子系统，仅在内存不足的紧急情况下分配一些动态内存来使用。</p>
<p>与保留的页框池不同，保留的页框池只用于满足中断处理程序或内部临界区发出的原子内存分配请求。</p>
<p>内存池则是动态内存的储备，只能被特定的内核成分（内存池的拥有者）使用。拥有着通常不使用储备，但是，如果动态内存变得极其稀有以至于普通内存分配请求都将失败的话，那么作为最后的解决手段，内核成分就能调用特定的内存池函数提取得到储备所需的内存。</p>
<p>一个内存池通常叠加在slab分配器之上——也就是说，它被用来保存slab对象的储备。</p>
<p>内存池通常可以被用来分配任何一种类型的动态内存，从整个页框到使用<code>kmalloc()</code>分配的小内存区。</p>
<h2 id="非连续内存区管理"><a href="#非连续内存区管理" class="headerlink" title="非连续内存区管理"></a>非连续内存区管理</h2><p>把内存区映射到一组连续的页框是最好的选择，这样会充分利用高速缓存并获得较低的平均访问时间。如果对内存区的请求不是很频繁，通过连续的线性地址访问非连续的页框这样一种分配模式就会很有意义。这种模式的主要优点是避免了外部碎片，而缺点是必须打乱内核页表。</p>
<p>。。。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/07-进程调度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/07-进程调度/" class="post-title-link" itemprop="url">07 进程调度</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:03:25 / Modified: 18:12:35" itemprop="dateCreated datePublished" datetime="2019-08-03T18:03:25+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/深入理解Linux内核/" itemprop="url" rel="index"><span itemprop="name">深入理解Linux内核</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h2><p><strong>进程分类方法</strong></p>
<p>传统上把进程分类为<strong>“I/O受限(I/O-bound)</strong>“或”<strong>CPU受限(CPU-bound)</strong>“。前者频繁的使用I/O设备，并花费很多时间等待I/O操作完成；后者则需要大量的CPU时间的数值计算应用程序。</p>
<p>另一种分类方法把进程区分为三类：</p>
<ul>
<li><strong>交互式进程(interactive process)</strong>: 这些进程经常与用户进行交互，因此，需要花费很多时间等待键盘和鼠标操作。当接受了输入后，进程必须很快被唤醒，否则用户将发现系统反应迟钝。典型的交互式程序是命令shell、文本编辑器及图形应用程序。</li>
<li><strong>批处理程序(batch process)</strong>: 这些进程不必与用户交互，因此经常在后台运行。这样的进程不必很快地响应，因此常受到调度程序地影响。典型地批处理进程是程序设计语言地编译程序、数据库搜索引擎及科学计算。</li>
<li><strong>实时进程(real-time process)</strong>: 这些进程有很强地调度需要。这样的进程决不会被低优先级的进程阻塞，它们应该有一个短的响应时间，更重要的是，响应时间的变化应该很小。典型的实时程序有视频和音频应用程序、机器人控制程序及从物理传感器上收集数据的程序。</li>
</ul>
<h3 id="进程的抢占"><a href="#进程的抢占" class="headerlink" title="进程的抢占"></a>进程的抢占</h3><p>Linux的进程是抢占式的。如果进程进入TASK_RUNNING状态，内核检查它的动态优先级是否大于当前正在运行的进程的优先级。如果是，current的执行被中断，并调用调度程序选择另一个进程运行（通常是刚变为可运行的进程）。</p>
<p>当然，进程在它的时间片到期时也可以被抢占。此时，当前进程thread_info结构中的TIF_NEED_RESCHED标志被设置，以便时钟中断处理程序终止时调度程序被调用。</p>
<p>注：被强占的进程没有被挂起，因为它还处于TASK_RUNNING状态，只不过不再使用CPU。</p>
<h3 id="一个时间片必须持续多长？"><a href="#一个时间片必须持续多长？" class="headerlink" title="一个时间片必须持续多长？"></a>一个时间片必须持续多长？</h3><p>如果平均时间片太短，有进程切换引起的系统额外开销就会变得非常高。</p>
<p>如果平均时间片太长，进程看起来就不再是并发执行。</p>
<p>对时间片大小的选择始终是一种折衷。Linux采取单凭经验的方法，即选择尽可能长、同时能保持良好响应时间的时间片。</p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>调度程序总能成功地找到要执行地进程。总是至少有一个可运行进程，即swapper进程，它地PID等于0，而且它只有再CPU不能执行其他进程时才执行。</p>
<p>每个Linux进程总是按照下面地调度类型被调度：</p>
<ul>
<li><strong>SCHED_FIFO</strong><ul>
<li>先进先出地实时进程。当调度程序把CPU分配给进程地时候，它把改进程描述符保留在运行队列链表地当前位置。如果没有其他可运行的更高优先级实时进程，进程就继续使用CPU，想用多久就用多久，计师还有其他具有相同优先级的实时进程处于可运行状态。</li>
</ul>
</li>
<li><strong>SCHED_RR</strong><ul>
<li>时间片轮转的实时进程。当调度程序把CPU分配给进程的时候，它把该进程的描述符放在运行队列链表的末尾。这种策略保证对所有具有相同优先级的SCHED_RR实时进程公平的分配CPU时间。</li>
</ul>
</li>
<li><strong>SCHED_NORMAL</strong><ul>
<li>普通的分时进程</li>
</ul>
</li>
</ul>
<p>调度算法根据进程是普通进程还是实时进程有很大不同。</p>
<h3 id="普通进程的调度"><a href="#普通进程的调度" class="headerlink" title="普通进程的调度"></a>普通进程的调度</h3><h3 id="实时进程的调度"><a href="#实时进程的调度" class="headerlink" title="实时进程的调度"></a>实时进程的调度</h3>
          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/03-进程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/03-进程/" class="post-title-link" itemprop="url">03 进程</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:03:13 / Modified: 18:12:31" itemprop="dateCreated datePublished" datetime="2019-08-03T18:03:13+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/深入理解Linux内核/" itemprop="url" rel="index"><span itemprop="name">深入理解Linux内核</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程、轻量级进程和线程"><a href="#进程、轻量级进程和线程" class="headerlink" title="进程、轻量级进程和线程"></a>进程、轻量级进程和线程</h3><p>从内核观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的实体。</p>
<p>Linux使用轻量级进程(lightweight process)对多线程应用程序提供更好的支持。两个轻量级进程基本上可以共享一些资源，诸如地址空间、打开的文件等等。</p>
<h3 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h3><p>进程描述符(process descriptor)——进程描述符都是task_struct类型结构，它的字段包含了与一个进程相关的所有信息。</p>
<blockquote>
<p>linux 进程描述符</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/5383C027E84442578519B055EB01E101?method=download&amp;shareKey=26e9eaa6aea258d172b4b84db68a2520" alt></p>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>进程描述符中的state字段描述了进程当前所处的状态。它由一组标志组成，其中每个标志描述一种可能的进程状态。在当前的Linux版本中，这些状态是互斥的，因此，严格意义上说，只能设置一种状态；其余的标志将被清除。</p>
<ul>
<li><strong>可运行状态(TASK_RUNNING)</strong><ul>
<li>进程要么在CPU上执行，要么装备执行</li>
</ul>
</li>
<li><strong>可中断的等待状态(TASK_INTERRUPTIBLE)</strong><ul>
<li>进程被挂起（睡眠），直到某个条件变为真。产生一个硬件中断，释放进程正等待的系统资源，或传递一个信号都是可以唤醒进程的条件（把进程的状态放回到TASK_RUNNING）。</li>
</ul>
</li>
<li><strong>不可中断的等待状态(TASK_UNINTERRUPTIBLE)</strong><ul>
<li>与可中断的等待状态类似，但有一个例外，把信号传递到睡眠进程不能改变它的状态。这种状态很少用到，但在一些特殊的情况下（进程必须等待，直到一个不能被中断的事件发生），这种状态是很有用的。</li>
<li>例如，当进程打开一个设备文件，其相应的设备驱动程序开始探测相应的硬件设备时会用到这种状态。探测完成以前，设备驱动程序不能被中断，否则，硬件设备会处于不可预知的状态。</li>
</ul>
</li>
<li><strong>暂停状态(TASK_STOPPED)</strong><ul>
<li>进程的执行被暂停。当进程接收到SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU信号后，进入暂停状态。</li>
</ul>
</li>
<li><strong>跟踪状态(TASK_TRACED)</strong><ul>
<li>进程的执行已由debugger程序暂停。当一个进程被另一个进程监控时，任何信号都可以把这个进程置于TASK_TRACED状态。</li>
</ul>
</li>
</ul>
<p>还有两个进程状态既可以存放在进程描述符的state字段中，也可以存放在exit_state字段中。从这两个字段名称可以看出，只有当进程的执行被终止时，进程的状态才会改变为这两种状态中的一种。</p>
<ul>
<li><strong>僵死状态(EXIT_ZOMBIE)</strong><ul>
<li>进程的执行被终止，但是，父进程还没有发布wait4()或waitpid()系统调用来返回有关死亡进程的信息。发布wait()类系统调用前，内核不能丢弃包含在死进程描述符中的数据，因为父进程可能还需要它。</li>
</ul>
</li>
<li><strong>僵死撤销状态(EXIT_DEAD)</strong><ul>
<li>最终状态：由于父进程刚发出wait4()或waitpid()系统调用，因而进程由系统删除。为了防止其他执行线程在同一个进程上也执行wait()类系统调用(这是一种竞争状态)，而把进程的状态由僵死(EXIT_ZOMBIE)状态改为僵死撤销状态(EXIT_DEAD)。</li>
</ul>
</li>
</ul>
<h4 id="标识一个进程"><a href="#标识一个进程" class="headerlink" title="标识一个进程"></a>标识一个进程</h4><p>能够独立调度的每个执行上下文都必须拥有它自己的进程描述符。</p>
<p>进程和进程描述符有非常严格的一一对应关系，使得32位的进程描述符地址可以很容易的标识进程。进程描述符指针指向这些地址，内核对进程的大部分引用是通过进程描述符指针进行的。</p>
<p>类Unix操作系统允许用户使用一个叫进程描述符processID(或PID)的数来标识进程，PID存放在进程描述符的pid字段中。</p>
<p>PID的值有一个上限，默认情况下，最大的PID号时32767(<code>PID_MAX_DEFAULT</code> - 1)；系统管理员可以通过往<code>/proc/sys/kernel/pid_max</code>这个文件中写入一个更小的值来减小PID的上限值。在64位的体系结构中，系统管理员可以把PID的上限扩大到4194303。</p>
<p>由于循环使用PID编号，内核必须通过管理一个<code>pidmap_array</code>位图来表示当前已分配的PID号和闲置的PID号。因为一个页框包含32768个位，所以在32位体系结构中<code>pidmap_array</code>位图存放在一个单独的页中。然而在64位体系结构中，需要为PID位图增加更多的页。系统会一直保存这些页不被释放。</p>
<p>Unix希望同一组的线程有共同的PID。例如，可以把信号发送给指定PID的一组线程，这个信号会作用于该组中的所有线程。</p>
<p>Linux遵照这个标准引入了线程组的表示。一个线程组的所有线程使用和该线程组的领头线程(thread group leader)相同的PID，也就是该组中的第一个轻量级进程的PID，它被存入进程描述符的<code>tgid</code>字段中。<code>getpid()</code>系统调用返回当前进程的<code>tgid</code>值而不是<code>pid</code>值，因此，一个多线程应用的所有线程共享相同的PID。</p>
<h5 id="进程描述符处理"><a href="#进程描述符处理" class="headerlink" title="进程描述符处理"></a>进程描述符处理</h5><p>进程是动态实体，内核必须能够同时处理很多进程，并把进程描述符存放在动态内存中。</p>
<p>对每个进程来说，Linux都把两个不同的数据结构紧凑地存放在一个单独为进程分配的储存区域：一个是与进程描述符相关的小数据结构<code>thread_info</code>，叫做线程描述符。另一个是内核态的进程堆栈。这块储存区域的大小通常为8192个字节(两个页框)。考虑到效率的因素，内核让这8K空间占据连续的两个页框并让第一个页框的起始地址是2^13的倍数。</p>
<p>内核态的进程访问处于内核数据段的栈，这个栈不同于用户态的进程所用的栈。因为内核控制器路径使用很少的栈，因此只需要几千字节的内核态堆栈。所以，对于内核栈和<code>thread_info</code>结构来说，8KB足够了。</p>
<blockquote>
<p>thread_info 结构和进程内核存放在两个连续的页框中</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/D0B0C46090864F248B3F60DB36567363?method=download&amp;shareKey=952119ee0f466af5385c6c8bb7efe9da" alt></p>
<p>esp寄存器是CPU栈指针，用来存放栈顶单元的地址。从用户态切换到内核态以后，进程的内核栈总是空的，因此，esp寄存器指向这个栈的顶端。</p>
<p>c语言使用下列的联合结构方便的表示一个进程的线程描述符和内核栈:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union thread_union &#123;</span><br><span class="line">	struct thread_info thread_info;</span><br><span class="line">    unsigned long stack[2048]; /* 对4K的栈数组下标是1024 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="标识当前进程"><a href="#标识当前进程" class="headerlink" title="标识当前进程"></a>标识当前进程</h5><p><code>thread_info</code>结构与内核态堆栈之间紧密结合提供的主要好处是：内核可以很容易从esp寄存器的值获取当前在CPU运行进程的<code>thread_info</code>结构的地址。如果<code>thread_union</code>结构长度是8K，内核则屏蔽掉esp的低13位有效位就可以获得<code>thread_info</code>结构的基地址；而如果<code>thread_union</code>结构长度是4K，内核则需要屏蔽掉esp的低12位有效地址。</p>
<p>进程最常用的是进程描述符地址而不是<code>thread_info</code>结构的地址，通过<code>thread_info</code>的task指针可以很容易的获取到进程描述符。</p>
<h5 id="进程链表"><a href="#进程链表" class="headerlink" title="进程链表"></a>进程链表</h5><p>每个<code>task_struct</code>结构都包含一个<code>list_head</code>类型的<code>tasks</code>字段，这个类型的<code>prev</code>和<code>next</code>字段分别指向前面和后面的<code>task_struct</code>元素。</p>
<h5 id="TASK-RUNNING状态的进程链表"><a href="#TASK-RUNNING状态的进程链表" class="headerlink" title="TASK_RUNNING状态的进程链表"></a>TASK_RUNNING状态的进程链表</h5><p>当内核寻找一个新进程在CPU运行时，必须只考虑可运行进程(即处在TASK_RUNNING状态的进程)</p>
<p>提高调度程序运行速度的诀窍是建立多个可运行进程链表，每种进程优先权对应一个不同的链表。每个<code>task_struct</code>描述符包含一个<code>list_head</code>类型的字段<code>run_list</code>。如果进程的优先权等于k，run_list字段把该进程链入优先权为k的可运行进程的链表中。</p>
<h4 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h4><blockquote>
<p>进程描述符中表示进程亲属关系的字段描述</p>
</blockquote>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>real_parent</td>
<td>指向创建了P的进程的描述符，如果P的父进程不再存在，就指向进程1(init)的描述符（因此，如果用户运行一个后台进程而且推出了shell，后台进程就会成为init的子进程）</td>
</tr>
<tr>
<td>parent</td>
<td>指向P的当前父进程（这种进程的子进程终止时，必须向父进程发信号）。它的值通常与<code>real_parent</code>一致，但偶尔也可以不同，例如，当另一个进程发出监控P的ptrace()系统调用请求时</td>
</tr>
<tr>
<td>children</td>
<td>链表的头部，链表中的所有元素都是P创建的子进程</td>
</tr>
<tr>
<td>sibling</td>
<td>指向兄弟进程链表的下一个元素或前一个元素的指针，这些兄弟进程的父进程都是P</td>
</tr>
</tbody>
</table>
<h5 id="pidhash表及链表"><a href="#pidhash表及链表" class="headerlink" title="pidhash表及链表"></a>pidhash表及链表</h5><p>由于需要跟踪进程间的关系，PID散列表中使用的数据结构非常复杂。</p>
<p>PID散列表的数据结构是四个pid结构的数组，它在进程描述符的pids字段中。</p>
<blockquote>
<p>pid结构的字段</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> nr;							<span class="comment">// pid的数值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">pid_chain</span>;</span>	<span class="comment">// 链接散列表的下一个和前一个元素</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pid_list</span>;</span>		<span class="comment">// 每个pid的进程链表头</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PID散列表</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/25275D69697641F3AFD4888FF798D311?method=download&amp;shareKey=571ba311ddbb61859cf21834698725fe" alt></p>
<h4 id="如何组织进程"><a href="#如何组织进程" class="headerlink" title="如何组织进程"></a>如何组织进程</h4>
          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/02-内存寻址/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/02-内存寻址/" class="post-title-link" itemprop="url">02 内存寻址</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:03:05 / Modified: 18:12:28" itemprop="dateCreated datePublished" datetime="2019-08-03T18:03:05+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/深入理解Linux内核/" itemprop="url" rel="index"><span itemprop="name">深入理解Linux内核</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h1><h2 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h2><h2 id="硬件中的分段"><a href="#硬件中的分段" class="headerlink" title="硬件中的分段"></a>硬件中的分段</h2><h2 id="Linux中的分段"><a href="#Linux中的分段" class="headerlink" title="Linux中的分段"></a>Linux中的分段</h2><h2 id="硬件中的分页"><a href="#硬件中的分页" class="headerlink" title="硬件中的分页"></a>硬件中的分页</h2><h3 id="硬件高速缓存"><a href="#硬件高速缓存" class="headerlink" title="硬件高速缓存"></a>硬件高速缓存</h3><p>为了缩小CPU和RAM之间的速度不匹配，引入了<strong>硬件高速缓存内存(hardware cache memory)</strong></p>
<p>硬件高速缓存基于著名的<strong>局部性原理(locality principle)</strong>，该原理既适用程序结构也适用于数据结构。这表明由于程序的循环结构及相关数组可以组织成线性数组，最近最常用的相邻地址在最近的将来又被用到的可能性极大。</p>
<p>高速缓存单元插在分页单元和主内存之间。它包含一个<strong>硬件高速缓存内存(hardware cache memory)</strong>和一个<strong>高速缓存控制器(cache controller)</strong>。高速缓存内存中存放内存真正的行。高速缓存控制器存放一个表项数组，每个表项对应高速缓存内存中的一个行。每个表项有一个标签(tag)和描述高速缓存行状态的几个标志(flag)。</p>
<p>这种物理内存地址通常分为3组：最高几位对应标签，中间几位对应高速缓存控制器的字集索引，最低几位对应行内的偏移量。</p>
<blockquote>
<p>处理器硬件高速缓存</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/CEF362F1ECF54FF093D2A854A9EB8940?method=download&amp;shareKey=65e9dfee767bbb515abe16c432a89fab" alt></p>
<p>当访问一个RAM储存单元时，CPU从物理地址中提取出子集的索引号并把子集中所有行的标签与物理地址的高几位比较。如果发现某一行的标签与这个物理地址的高位相同，则CPU命中一个高速缓存(cache hit)；否则，高速缓存没有命中(cache miss)。</p>
<p>当命中一个高速缓存时，高速缓存控制器执行不同的操作。</p>
<p>对于读操作，控制器从高速缓存行中选择数据并送到CPU寄存器；不需要访问RAM因而节约了CPU时间，因此，高速缓存系统起到了应有的作用。</p>
<p>对于写操作，控制器可能采用以下两个基本策略之一：</p>
<ul>
<li><strong>通写(write-through)</strong>：控制器总是既写RAM也写高速缓存行</li>
<li><strong>回写(write-back)</strong>：回写的方式只更新高速缓存行，不改变RAM内容，提供了更快的功效。只有当CPU执行一条要求刷新高速缓存表项的指令时，或者当一个FLUSH硬件信号产生时（通常在高速缓存不命中之后），高速缓存控制器才把高速缓存行写回到RAM中。</li>
</ul>
<p>当高速缓存没有命中时，高速缓存行被写回到内存中，如果有必要的话，把正确的行从RAM中取出放到高速缓存行的表项中。</p>
<h2 id="Linux中的分页"><a href="#Linux中的分页" class="headerlink" title="Linux中的分页"></a>Linux中的分页</h2>
          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/01-操作系统基本概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/01-操作系统基本概念/" class="post-title-link" itemprop="url">01 操作系统基本概念</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:00:09 / Modified: 18:12:25" itemprop="dateCreated datePublished" datetime="2019-08-03T18:00:09+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/深入理解Linux内核/" itemprop="url" rel="index"><span itemprop="name">深入理解Linux内核</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="操作系统基本概念"><a href="#操作系统基本概念" class="headerlink" title="操作系统基本概念"></a>操作系统基本概念</h2><p>操作系统完成的两个主要目标：</p>
<ul>
<li>与硬件部分交互，为包含在硬件平台上的所有底层可编程部分提供服务</li>
<li>为运行在计算机系统上的应用程序（即所谓应用程序）提供执行环境</li>
</ul>
<p>现代操作系统依靠特殊的硬件特性禁止用户程序直接与底层硬件部分进行交互，或者禁止直接访问任意的物理地址。硬件为CPU引入了至少两种不同的执行模式：用户程序的非特权模式和内核的特权模式。Univ把它们分别称为<strong>用户态(User Mode)</strong>和<strong>内核态(Kernel Mode)</strong>。</p>
<h3 id="多用户系统"><a href="#多用户系统" class="headerlink" title="多用户系统"></a>多用户系统</h3><p>多用户系统(multiuser system)就是一台能并发和独立地执行分别属于两个或多个用户的若干应用程序的计算机。</p>
<ul>
<li>”并发“(concurrently)以为着几个应用程序能同时处于活动状态并竞争各种资源，如CPU、内存、硬盘等等。</li>
<li>“独立”(independently)意味着每个应用程序能执行自己的任务，而无需考虑其他用户的应用程序在干些什么。</li>
</ul>
<p>多用户操作系统必须包含以下几个特点：</p>
<ul>
<li>核实用户身份认证的机制</li>
<li>防止有错误的用户程序妨碍其他应用程序在系统中运行的保护机制</li>
<li>防止有恶意的用户程序干涉或窥视其他用户的活动的保护机制</li>
<li>限制分配给每个用户的资源数的记账机制</li>
</ul>
<h3 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h3><p>在多用户系统中，每个用户在机器上都有私有空间。</p>
<p>所有的用户由一个唯一的数字来标识，这个数字叫用户标识符（UserID，UID）</p>
<p>为了和其他用户有选择的共享资料，每个用户是一个或多个用户组的一名成员，组由唯一的用户组标识符（user group ID）标识。每个文件也恰好与一个组相对应。</p>
<h2 id="Unix-文件系统概述"><a href="#Unix-文件系统概述" class="headerlink" title="Unix 文件系统概述"></a>Unix 文件系统概述</h2><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>Unix文件可以是下列类型之一：</p>
<ul>
<li>普通文件（regular file）</li>
<li>目录</li>
<li>符号链接</li>
<li>面向块的设备文件（block-oriented device file）</li>
<li>面向字符的设备文件（character-oriented device file）</li>
<li>管道（pipe）和命名管道（named piped）（也叫FIFO）</li>
<li>套接字（socket）</li>
</ul>
<h3 id="文件描述符与索引节点"><a href="#文件描述符与索引节点" class="headerlink" title="文件描述符与索引节点"></a>文件描述符与索引节点</h3><p>Unix对文件的内容和描述文件的信息给出了清除的区分。除了设备文件和特殊文件系统文件外，每个文件都由字符序列组成。文件内容不包含任何控制信息。</p>
<p>文件系统处理文件所需要的信息包含在一个名为索引节点（inode）的数据结构中。每个文件都有自己的索引节点，文件系统用索引节点来标识文件。</p>
<p>文件系统至少提供在POSIX标准中指定的如下属性：</p>
<ul>
<li>文件类型</li>
<li>与文件相关的硬链接的个数</li>
<li>以字节为单位的文件长度</li>
<li>设备标识符（即包含文件的设备标识符）</li>
<li>在文件系统中标识文件的索引节点号</li>
<li>文件拥有者的UID</li>
<li>文件的用户组ID</li>
<li>几个时间戳，表示索引节点状态改变的时间、最后访问时间及最后修改时间</li>
<li>访问权限和文件模式</li>
</ul>
<h2 id="Unix内核概述"><a href="#Unix内核概述" class="headerlink" title="Unix内核概述"></a>Unix内核概述</h2><h3 id="进程-内核模式"><a href="#进程-内核模式" class="headerlink" title="进程/内核模式"></a>进程/内核模式</h3><p>当一个程序在用户态下执行时，它不能直接访问内核数据结构或者内核的程序。然而，当应用程序在内核态下运行时，这些限制不再有效。</p>
<p>内核本身不是一个进程，而是进程的管理者。</p>
<p>进程/内核模式假定：请求内核服务的进程使用所谓系统调用(system call)的特殊编程机制。每个系统调用都设置了一组识别进程请求的参数，然后执行与硬件相关的CPU指令完成从用户到内核态的转换。</p>
<p>激活内核例程的几种方式：</p>
<ul>
<li>进程调用系统调用</li>
<li>正在执行进程的CPU发出一个异常(exception)信号，内核代表产生异常的进程处理异常。</li>
<li>外围设备向CPU发出一个中断(interrupt)信号以通知一个事件的发声，例如一个要求注意的请求、一个状态的变化或一个I/O操作已经完成等。每个中断信号都是由内核中的<strong>中断处理程序(interrupt handler)</strong>来处理的。因为外围设备与CPU是异步操作，因此，中断在不可预知的时间发生。</li>
<li>内核线程被执行。</li>
</ul>
<h3 id="进程实现"><a href="#进程实现" class="headerlink" title="进程实现"></a>进程实现</h3><p>每个进程由一个<strong>进程描述符(process descriptor)</strong>表示，这个描述符包含有关进程当前状态的信息。</p>
<p>当内核暂停一个进程的执行时，就把几个相关处理器寄存器的内容保存在进程描述符中。这些寄存器包括：</p>
<ul>
<li>程序计数器(PC)和栈指针(SP)寄存器</li>
<li>通用寄存器</li>
<li>浮点寄存器</li>
<li>包含CPU状态信息的处理器控制寄存器(处理器状态字，Processor Status Word)</li>
<li>用来跟踪进程对RAM访问的内存管理寄存器</li>
</ul>
<p>当内核恢复执行一个进程时，它用进程描述符中适合的字段来装载CPU寄存器。因为程序计数器中所存的值指向下一条将要执行的指令，所以进程从它停止的地方恢复执行。</p>
<p>Unix内核可以区分很多等待状态，这些等待状态通常由进程描述符队列实现。</p>
<h3 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h3><p>每个进程运行在它的私有地址空间。在用户态下运行的进程涉及到私有栈、数据区和代码区。当在内核态运行时，进程访问内核的数据区和代码区，但使用另外的私有栈。</p>
<p>尽管看起来每个进程访问一个私有地址空间，但有时进程之间也共享这部分地址空间。在一些情况下，这种共享由进程显式提出；在另一些情况下，由内核自动完成共享以节约内存。进程间能共享部分地址空间，以实现一种进程间通信，这就是由System V引入并已经被Linux支持地”共享内存”技术。</p>
<p>Linux支持mmap()系统调用，该系统调用允许存放在块设备上的文件或者信息的一部分映射到进程的部分地址空间。内存映射为正常的读写传送数据提供了另一种选择。如果同一个文件由几个进程共享，那么共享它的每个进程地址空间都包含它的内存映射。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/11/12/Chapter3-The-Graphics-Processing-Unit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/11/12/Chapter3-The-Graphics-Processing-Unit/" class="post-title-link" itemprop="url">Chapter3 The Graphics Processing Unit</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-12 21:49:28" itemprop="dateCreated datePublished" datetime="2018-11-12T21:49:28+08:00">2018-11-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-02 11:28:18" itemprop="dateModified" datetime="2019-08-02T11:28:18+08:00">2019-08-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Real-Time-Rendering/" itemprop="url" rel="index"><span itemprop="name">Real Time Rendering</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <blockquote>
<p>The display is the computer</p>
<p>​        —— Jen-Hsun Huang</p>
</blockquote>
<h2 id="Data-Parallel-Architectures"><a href="#Data-Parallel-Architectures" class="headerlink" title="Data-Parallel Architectures"></a>Data-Parallel Architectures</h2><p>Much of a GPU’s chip area is dedicated to a large set of processors, called <strong>shader cores</strong>, often numbering in the thousands.</p>
<p>The GPU is a stream processor, in which ordered sets of similar data are processed in turn. Because<br>of this similarity the GPU can process these data in a massively <strong>parallel fashion</strong>. </p>
<p>The GPU is optimized for <strong>throughput</strong>, deﬁned as the maximum rate at which data can be processed. However, this rapid processing has a cost. With less chip area dedicated to cache memory and control logic, <strong>latency</strong> for each shader core is generally considerably higher than what a CPU processor encounters.</p>
<p>GPUs separate the instruction execution logic from the data. Called <strong>single instruction, multiple data (SIMD)</strong>. The advantage of SIMD is that considerably less silicon (and power) needs to be dedicated to processing data and switching, compared to using an individual logic and dispatch unit to run each program. </p>
<h4 id="Warp"><a href="#Warp" class="headerlink" title="Warp"></a>Warp</h4><p>in modern GPU terms, each pixel shader invocation for a fragment is called a <strong>thread</strong>. This type of thread is unlike a CPU thread. It consists of a bit of memory for the input values to the shader, along with any register space needed for the shader’s execution. </p>
<p>Threads that use the same shader program are bundled into groups, called <strong>warps</strong> by NVIDIA and <strong>wavefronts</strong> by AMD. A warp/wavefront is scheduled for execution by some number GPU shader cores, anywhere from 8 to 64, using SIMD-processing. </p>
<h4 id="Occupancy"><a href="#Occupancy" class="headerlink" title="Occupancy"></a>Occupancy</h4><p>The shader program’s structure is an important characteristic that inﬂuences eﬃciency. A major factor is the amount of register use for each thread. The more registers needed by the shader program associated with each thread, the fewer threads, and thus the fewer warps, can be resident in the GPU. A shortage of warps can mean that a stall cannot be mitigated by swapping. </p>
<p>Warps that are resident are said to be “in ﬂight,” and this number is called the <strong>occupancy</strong>. </p>
<ul>
<li>High occupancy means that there are many warps available for processing, so that idle processors are less likely. </li>
<li>Low occupancy will often lead to poor performance.</li>
</ul>
<p>The frequency of memory fetches also aﬀects how much latency hiding is needed.</p>
<p>Another factor aﬀecting overall eﬃciency is <strong>dynamic branching</strong>, caused by “if” statements and loops. </p>
<p>if some threads, or even one thread, take the alternate path, then the warp must execute both branches, throwing away the results not needed by each particular thread. This problem is called <strong>thread divergence</strong>, where a few threads may need to execute a loop iteration or perform an “if” path that the other threads in the warp do not, leaving them idle during this time.</p>
<p><img src="https://github.com/Uyouii/LearnOpenGL/raw/master/Real%20Time%20Rending%20Image/Simpli%EF%AC%81ed%20shader%20execution%20example.PNG" alt></p>
<blockquote>
<p>Simpliﬁed shader execution example. A triangle’s fragments, called threads, are gathered into warps. Each warp is shown as four threads but have 32 threads in reality. The shader program to be executed is ﬁve instructions long. The set of four GPU shader processors executes these instructions for the ﬁrst warp until a stall condition is detected on the “txr” command, which needs time to fetch its data. The second warp is swapped in and the shader program’s ﬁrst three instructions are applied to it, until a stall is again detected. After the third warp is swapped in and stalls, execution continues by swapping in the ﬁrst warp and continuing execution. If its “txr” command’s data are not yet returned at this point, execution truly stalls until these data are available. Each warp ﬁnishes in turn.</p>
</blockquote>
<h2 id="GPU-Pipeline-Overview"><a href="#GPU-Pipeline-Overview" class="headerlink" title="GPU Pipeline Overview"></a>GPU Pipeline Overview</h2><p><img src="https://github.com/Uyouii/LearnOpenGL/raw/master/Real%20Time%20Rending%20Image/GPU%20implementation%20of%20the%20rendering%20pipeline.PNG" alt></p>
<blockquote>
<p>GPU implementation of the rendering pipeline. The stages are color coded according to the degree of user control over their operation. Green stages are fully programmable. Dashed lines show optional stages. Yellow stages are conﬁgurable but not programmable, e.g., various blend modes can be set for the merge stage. Blue stages are completely ﬁxed in their function.</p>
</blockquote>
<p>The <strong>vertex shader</strong> is a fully programmable stage that is used to implement the geometry processing stage. </p>
<p>The <strong>geometry shader</strong> is a fully programmable stage that operates on the vertices of a primitive (point, line, or triangle). It can be used to perform per-primitive shading operations, to destroy primitives, or to create new ones.</p>
<p>The <strong>tessellation stage</strong> and <strong>geometry shader</strong> are both optional, and not all GPUs support them, especially on mobile devices.</p>
<p>The <strong>clipping</strong>, <strong>triangle setup</strong>, and <strong>triangle traversal</strong> stages are implemented by ﬁxed-function hardware. </p>
<p><strong>Screen mapping</strong> is aﬀected by window and viewport settings, internally forming a simple scale and repositioning. </p>
<p>The <strong>pixel shader</strong> stage is fully programmable. </p>
<p>Although the <strong>merger</strong> stage is not programmable, it is highly conﬁgurable and can be set to perform a wide variety of operations. It implements the “merging” functional stage, in charge of modifying the color, z-buﬀer, blend, stencil, and any other output-related buﬀers. </p>
<p>pixel shader execution together with the merger stage form the conceptual pixel processing stage.</p>
<h2 id="The-Programmable-Shader-Stage"><a href="#The-Programmable-Shader-Stage" class="headerlink" title="The Programmable Shader Stage"></a>The Programmable Shader Stage</h2><p>shader languages:</p>
<ul>
<li><p>HLSL:  <em>DirectX’s High-Level Shading Language</em></p>
</li>
<li><p>GLSL: <em>OpenGL Shading Language</em></p>
</li>
</ul>
<p>DirectX’s HLSL can be compiled to virtual machine bytecode, also called the <strong>intermediate language</strong> (<strong>IL</strong> or <strong>DXIL</strong>), to provide hardware independence.</p>
<p>A <strong>draw call</strong> invokes the graphics API to draw a group of primitives, so causing the graphics pipeline to execute and run its shaders.</p>
<p>Each programmable shader stage has two types of inputs:</p>
<ul>
<li>uniform inputs, with values that remain constant throughout a draw call (but can be changed between draw calls)</li>
<li>varying inputs, data that come from the triangle’s vertices or from rasterization. </li>
</ul>
<h4 id="Shader-Virtual-Machine-Register"><a href="#Shader-Virtual-Machine-Register" class="headerlink" title="Shader Virtual Machine Register"></a>Shader Virtual Machine Register</h4><p>The underlying virtual machine provides special <strong>registers</strong> for the diﬀerent types of inputs and outputs. The number of available <strong>constant registers</strong> for uniforms is much larger than those registers available for varying inputs or outputs. </p>
<p>This happens because:</p>
<ul>
<li>the varying inputs and outputs need to be stored separately for each vertex or pixel, so there is a natural limit as to how many are needed.  </li>
<li>The uniform inputs are stored once and reused across all the vertices or pixels in the draw call.</li>
</ul>
<p>The virtual machine also has general-purpose <strong>temporary registers</strong>, which are used for scratch space.</p>
<p>All types of registers can be array-indexed using integer values in temporary registers.</p>
<p><img src="https://github.com/Uyouii/LearnOpenGL/raw/master/Real%20Time%20Rending%20Image/Uni%EF%AC%81ed%20virtual%20machine%20architecture%20and%20register%20layout.PNG" alt></p>
<blockquote>
<p>Uniﬁed virtual machine architecture and register layout, under Shader Model 4.0. The maximum available number is indicated next to each resource. Three numbers separated by slashes refer to the limits for vertex, geometry, and pixel shaders (from left to right).</p>
</blockquote>
<h4 id="flow-control"><a href="#flow-control" class="headerlink" title="flow control"></a>flow control</h4><p>Instructions related to <strong>ﬂow control</strong> are used to implement high-level language constructs such as “if” and “case” statements, as well as various types of loops.</p>
<p>Shaders support two types of ﬂow control: </p>
<ul>
<li><strong>Static ﬂow control</strong> branches are based on the values of uniform inputs.  This means that the ﬂow of the code is constant over the draw call. </li>
<li><strong>Dynamic ﬂow control</strong> is based on the values of varying inputs, meaning that each fragment can execute the code diﬀerently.</li>
</ul>
<p>The primary beneﬁt of <strong>static ﬂow control</strong> is to allow the same shader to be used in a variety of diﬀerent situations (e.g., a varying numbers of lights). There is no thread divergence, since all invocations take the same code path.</p>
<p>Dynamic flow control is much more powerful than static ﬂow control but can cost performance, especially if the code ﬂow changes erratically between shader invocations.</p>
<h2 id="The-Vertex-Shader"><a href="#The-Vertex-Shader" class="headerlink" title="The Vertex Shader"></a>The Vertex Shader</h2><p>A triangle mesh is represented by a set of vertices, each associated with a speciﬁc <strong>position</strong> on the model surface. Besides position, there are other optional properties associated with each vertex, such as a <strong>color or texture coordinates</strong>. Surface <strong>normals</strong> are deﬁned at mesh vertices as well.</p>
<p>The vertex shader provides a way to modify, create, or ignore values associated with each triangle’s vertex, such as its color, normal, texture coordinates, and position.</p>
<p>Normally the vertex shader program transforms vertices from <strong>model space</strong> to <strong>homogeneous clip space</strong> . At a minimum, a vertex shader must always output this <strong>location</strong>.</p>
<p>Since each vertex is treated independently, any number of shader processors on the GPU can be applied <strong>in parallel</strong> to the incoming stream of vertices.</p>
<h4 id="Shader-Effects"><a href="#Shader-Effects" class="headerlink" title="Shader Effects"></a>Shader Effects</h4><ul>
<li>vertex blending for animating joints(动画关节的定点混合)</li>
<li>silhouette rendering（轮廓渲染）</li>
<li>Object generation, by creating a mesh only once and having it be deformed by the vertex shader.</li>
<li>Animating character’s bodies and faces using skinning and morphing（蒙皮） techniques.</li>
<li>Procedural deformations（程序变形）, such as the movement of ﬂags, cloth, or water</li>
<li>Particle creation, by sending degenerate (no area) meshes down the pipeline and having these be given an area as needed.</li>
<li>Lens distortion（镜头扭曲）, heat haze（热雾）, water ripples（水波纹）, page curls（页面卷曲）, and other eﬀects, by using the entire framebuﬀer’s contents as a texture on a screen-aligned mesh undergoing procedural deformation.</li>
<li>Applying terrain height ﬁelds by using vertex texture fetch</li>
</ul>
<h2 id="The-Tessellation-Stage-曲面细分阶段"><a href="#The-Tessellation-Stage-曲面细分阶段" class="headerlink" title="The Tessellation Stage (曲面细分阶段)"></a>The Tessellation Stage (曲面细分阶段)</h2><p>The tessellation stage allows us to render curved surfaces. The GPU’s task is to take each surface description and turn it into a representative set of triangles. This stage is an optional GPU feature .</p>
<p>Advantages:</p>
<ul>
<li>Memory Savings</li>
<li>Keep the bus between CPU and GPU from becoming the bottleneck for an animated character or object whose shape is changing each frame</li>
<li>surface can be rendered efficiently by having an appropriate number of triangles generated for the given view. This ability to control the <strong>level of detail</strong> can also allow an application to control its performance</li>
</ul>
<p>The tessellation stage always consists of three elements:</p>
<ul>
<li>hull shader: in OpenGL is the tessellation control shader</li>
<li>tesssellator: in OpenGL is primitive genearator</li>
<li>domain shader: in OpenGL is the tessellation evaluation shader</li>
</ul>
<p><img src="https://github.com/Uyouii/LearnOpenGL/raw/master/Real%20Time%20Rending%20Image/The%20tessellation%20stage.PNG" alt></p>
<blockquote>
<p>The tessellation stage. The hull shader takes in a patch deﬁned by control points. It sends the tessellation factors (TFs 曲面细分因子) and type to the ﬁxed-function tessellator. The control point set is transformed as desired by the hull shader and sent on to the domain shader, along with TFs and related patch constants. The tessellator creates the set of vertices along with their barycentric coordinates. These are then processed by the domain shader, producing the triangle mesh (control points shown for reference).</p>
</blockquote>
<h3 id="Hull-Shader"><a href="#Hull-Shader" class="headerlink" title="Hull Shader"></a>Hull Shader</h3><p>The input to the hull shader is a special patch primitive. This consists of several control points deﬁning a subdivision surface（细分曲面）, B´ezier patch, or other type of curved element.</p>
<p>Hull Shader has two functions:</p>
<ul>
<li>First, it tells the tessellator how many triangles should be generated, and in what conﬁguration. </li>
<li><p>Second, it performs processing on each of the control points.</p>
</li>
<li><p>Also, optionally, the hull shader can modify the incoming patch description, adding or removing control points as desired.</p>
</li>
</ul>
<p>The hull shader outputs its set of control points, along with the tessellation control data, to the domain<br>shader.</p>
<h3 id="Tessellator"><a href="#Tessellator" class="headerlink" title="Tessellator"></a>Tessellator</h3><p>The tessellator is a fixed-function stage in the pipeline, only used with tessellation shaders. It has the task of adding several new vertices for the domain shader to process.</p>
<p>The hull shader sends the tessellator information about what type of tessellation surface is desired: triangle, quadrilateral, or isoline.( Isolines are sets of line strips, sometimes used for hair rendering.)</p>
<p>The other important values sent by the hull shader are the <strong>tessellation factors</strong> (tessellation levels in OpenGL). These are of two types: <strong>inner and outer edge</strong>.  </p>
<ul>
<li>The two inner factors determine how much tessellation occurs inside the triangle or quadrilateral.</li>
<li>The outer factors determine how much each exterior edge is split</li>
</ul>
<h3 id="Domain-Shader"><a href="#Domain-Shader" class="headerlink" title="Domain Shader"></a>Domain Shader</h3><p>The control points for the curved surface from the hull shader are used by each invocation of the domain shader to compute the output values for each vertex. </p>
<p>The domain shader has a data ﬂow pattern like that of a vertex shader, with each input vertex from the tessellator being processed and generating a corresponding output vertex. The triangles formed are then passed on down the pipeline.</p>
<p>The domain shader takes the barycentric coordinates（重心坐标） generated for each point and uses these in the patch’s evaluation equation to generate the position, normal（法线）, texture coordinates（纹理坐标）, and other vertex information desired.</p>
<h2 id="The-Geometry-Shader"><a href="#The-Geometry-Shader" class="headerlink" title="The Geometry Shader"></a>The Geometry Shader</h2><p>Note that no output at all can be generated by the geometry shader. </p>
<p>The geometry shader is designed for modifying incoming data or making a limited number of copies. </p>
<p>The geometry shader is guaranteed to output results from primitives in the same order that they are input. This aﬀects performance, because if several shader cores run in parallel, results must be saved and ordered. </p>
<h2 id="The-Pixel-Shader"><a href="#The-Pixel-Shader" class="headerlink" title="The Pixel Shader"></a>The Pixel Shader</h2><p>This piece of a triangle partially or fully overlapping the pixel is called a <strong>fragment</strong>.</p>
<p>In OpenGL the <strong>pixel shader</strong> is known as the <strong>fragment shader</strong>, which is perhaps a better name. </p>
<p>In programming terms, the vertex shader program’s outputs, interpolated across the triangle (or line), eﬀectively become the pixel shader program’s inputs.</p>
<p>With inputs in hand, typically the pixel shader computes and outputs a fragment’s color. It can also possibly produce an opacity value and optionally modify its z-depth.</p>
<p>A pixel shader also has the unique ability to discard an incoming fragment, i.e., generate no output. </p>
<h3 id="MRT-multiple-render-targets"><a href="#MRT-multiple-render-targets" class="headerlink" title="MRT  multiple render targets"></a>MRT  multiple render targets</h3><p>Instead of sending results of a pixel shader’s program to just the color and z-buﬀer, multiple sets of values could be generated for each fragment and saved to diﬀerent buﬀers, each called a <strong>render target</strong>.</p>
<p>A single rendering pass could generate a color image in one target, object identiﬁers in another, and world-space distances in a third. This ability has also given rise to a diﬀerent type of rendering pipeline, called <strong>deferred shading</strong>, where visibility and shading are done in separate passes. The ﬁrst pass stores<br>data about an object’s location and material at each pixel. Successive passes can then eﬃciently apply illumination and other eﬀects. </p>
<h3 id="limitation"><a href="#limitation" class="headerlink" title="limitation"></a>limitation</h3><p>The pixel shader’s limitation is that it can normally write to a render target at only the fragment location handed to it, and cannot read current results from neighboring pixels. That is, when a pixel shader program executes, it cannot send its output directly to neighboring pixels, nor can it access others’ recent changes. Rather, it computes results that aﬀect only its own pixel. </p>
<p>But  an output image created in one pass can have any of its data accessed by a pixel shader in a later pass. </p>
<h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><p>There are exceptions to the rule that a pixel shader cannot know or aﬀect neighboring pixels’ results. </p>
<ul>
<li>One is that the pixel shader can immediately access information for adjacent fragments (albeit indirectly) during the computation of gradient or derivative information.</li>
</ul>
<h2 id="The-Merging-Stage"><a href="#The-Merging-Stage" class="headerlink" title="The Merging Stage"></a>The Merging Stage</h2><p>The <strong>merging stage</strong> is where the depths and colors of the individual fragments (generated in the pixel shader) are combined with the framebuﬀer. </p>
<p>The merging stage occupies the middle ground between ﬁxed-function stages, such as triangle setup, and the fully programmable shader stages. Although it is <strong>not programmable</strong>, its operation is <strong>highly conﬁgurable</strong>.</p>
<p>On most traditional pipeline diagrams, this stage is where <strong>stencil-buﬀer</strong> and <strong>z-buﬀer</strong> operations occur. If the fragment is visible, another operation that takes place in this stage is <strong>color blending</strong>. </p>
<ul>
<li>For <strong>opaque</strong> surfaces there is no real blending involved, as the fragment’s color simply replaces the previously stored color. Actual blending of the fragment and stored color is commonly used for <strong>transparency</strong> and <strong>compositing</strong> operations  </li>
</ul>
<p>The fragment is culled if hidden. This functionality is called <strong>early-z</strong>.</p>
<h2 id="The-Compute-Shader"><a href="#The-Compute-Shader" class="headerlink" title="The Compute Shader"></a>The Compute Shader</h2>
          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/11/11/100种爱你的表达方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/11/11/100种爱你的表达方式/" class="post-title-link" itemprop="url">100种爱你的表达方式</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-11 16:41:56" itemprop="dateCreated datePublished" datetime="2018-11-11T16:41:56+08:00">2018-11-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-03 18:07:07" itemprop="dateModified" datetime="2019-08-03T18:07:07+08:00">2019-08-03</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/bookread/" itemprop="url" rel="index"><span itemprop="name">bookread</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <ul>
<li>I’ve been doing a lot of thinking and the thing is, I love you. 我思考了很久，结论是，我爱你</li>
<li>you are the epitome of everything I’ve ever looked for in another human being 你拥有我梦寐以求的一切美好品质</li>
<li>Love is … is too weak a word for the way I feel. I lurv you, I loave you, I luff you  用爱这个词来形容我的感受太苍白了,我耐你，我中意你，我稀罕你啊！</li>
<li>I sort of feel like I’m on drugs when I’m with you. Not that I do drugs, unless you do drugs, in which case  I do drugs all the time. 和你在一起的感觉就像是在嗑药，不是我说真的嗑药啊，除非你嗑药, 那样的话我就一直嗑药。</li>
<li>There’s only one place in the world I call home, and it’s because you’re there 这世上只有一个我能称之为家的地方，那就是你在的地方。</li>
<li>I’d feel better sitting outside your apartment on the curb than any other place I can think of or imagine.  坐在你门口的路边感觉很好，我再想不出其他更好的地方了。</li>
<li>I’m not waking up another morning without being able to look at you next to me. 我不想清晨醒来的时候没有你在身边。</li>
<li>I would rather share one lifetime with you than face all the ages of this world alone. 我宁愿和你共度凡人短暂的一生也不愿一个人看尽这世界的沧海桑田。</li>
<li>Can’t you see what I’m trying to tell you, I love you! 你难道还看不出来我对你的心意吗？我爱你！</li>
<li>No other love but you. 除你之外别无所爱</li>
<li>Like a sickness and its cure together 就像病与药方一样难分。</li>
<li>I love you. Ditto 我爱你。 + 1</li>
<li>I should have told you every day from the moment I met you 我应该从遇见你的那一刻起每天对你说一遍</li>
<li>You complete me 你让我的人生完整了</li>
<li>I love you Chicken 我爱你小妞</li>
<li>I love you Honey Bunny 我爱你甜甜宝贝儿</li>
<li>I think that’s the only thing I’ve ever been really sure of in my entire life 这是我人生中唯一确信不疑的事</li>
<li>You are the woman that I want 你是我想要的女人</li>
<li>How many more times to I have to say it? One more time would be nice 我还要再说多少遍？再说一遍就好</li>
<li>You have bewitched me, body and soul。 你让我着了魔，从肉体到灵魂</li>
<li>Whatever I am, I’m yours 不论我是什么，我是你的</li>
<li>I am so in love with you 我是如此爱你</li>
<li>You’re the only one for me 你是我的唯一</li>
<li>I’m not a smart man, but I know what love is 我不聪明，但是我知道爱是什么</li>
<li>Love means never having to say you’re sorry 爱就是永远不用说抱歉</li>
<li>Love is a many-splendored thing. Love lifts us up where we belong. All you need is love! 爱是如此壮丽辉煌，爱会把我们带到我们所属的地方，爱就是你所需的一切</li>
<li>Some people search all their life for this and never find it. 多少人终其一生求而不得</li>
<li>You think this happens everyday? 你觉得这是等闲寻常事？</li>
<li>I love you dream woman! 我爱你女神</li>
<li>What do I have to do to prove it to you? 我要做什么才能向你证明？</li>
<li>You what the moon? 要我摘天上的月亮给你？</li>
<li>You want me to renounce my throne? 要我放弃王位？</li>
<li>The wooing, the spooning, I am all in! 各种求爱、表白，我都愿意做</li>
<li>Because when you find the one, you never give up  因为当你遇见那个人时，你永不放手</li>
<li>All I ever wanted, was you 我一直以来想要的，就是你</li>
<li>I’ve loved you more than any woman’s ever loved a rabbit 我爱你胜过对任何女人对兔子的爱</li>
<li>I love you more than anyone has ever loved 我爱你胜过任何曾经爱过的人</li>
<li>I love you more than my life 我爱你胜过我的生命</li>
<li>I love you more than band music and cookie-making 我爱你胜过爱乐队和烤饼干</li>
<li>I want to be with you 我想跟你在一起</li>
<li>I made up my mind you were the only woman for me 我想好了，你就是我的唯一</li>
<li>I’ve loved you since the first day I met you, and I’ll never stop 遇见你的第一天起我就爱上了你，而且永不停息</li>
<li>I’ll love you always 我会永远爱你</li>
<li>Until your heart stops beating 直到你的心脏停止跳动</li>
<li>Til the stars turn cold 直到星辰不再发光</li>
<li>I’ve never felt that before 我之前从未有过这样的感觉</li>
<li>I love you. Can’t believe how many times I’m saying it 我爱你，不敢相信我竟说了这么多遍</li>
<li>Because I came alive when I met you 因为遇见你，我又活了过来</li>
<li>And there’s only one person that makes me feel like I can fly 你是唯一让我觉得我可以飞翔的人</li>
<li>So I will wait forever for you, okay? I will wait the rest of my life. 我会永远等你的好不好？我会用我的余生来等待</li>
<li>I want all of you, forever, you and me, every day我想完完整整地拥有你</li>
<li>I always have 我一直都是</li>
<li>I always will 我一直都会</li>
<li>I came here tonight because when you realize you want to spend the rest of your life with somebody, you want the rest of the life to start as soon as possible. 我今晚来这里是因为，当你意识到自己想要与一个人共度余生地时候，你会希望你的余生尽快开始。</li>
<li>Just shut up, you had me at “hello” 别说了，你的一句“你好”我就已经沦陷了</li>
</ul>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/11/05/The-Graphics-Rendering-Pipeline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/11/05/The-Graphics-Rendering-Pipeline/" class="post-title-link" itemprop="url">The Graphics Rendering Pipeline</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-05 23:51:23" itemprop="dateCreated datePublished" datetime="2018-11-05T23:51:23+08:00">2018-11-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-02 11:28:18" itemprop="dateModified" datetime="2019-08-02T11:28:18+08:00">2019-08-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Real-Time-Rendering/" itemprop="url" rel="index"><span itemprop="name">Real Time Rendering</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>coarse division of the real-time rendering pipeline into four main stages:</p>
<ul>
<li>application  [CPU]</li>
<li>geometry processing [GPU]</li>
<li>rasterization [GPU]</li>
<li>pixel processing [GPU]</li>
</ul>
<p><img src="https://github.com/Uyouii/LearnOpenGL/raw/master/Real%20Time%20Rending%20Image/rendering%20pipeline.PNG" alt></p>
<h2 id="The-Application-Stage"><a href="#The-Application-Stage" class="headerlink" title="The Application Stage"></a>The Application Stage</h2><ul>
<li><strong>collision detection</strong> is commonly implemented in this stage.</li>
<li>the application stage is also the place to take care of input from other sources, such as the keyboard, the mouse, or a head-mounted display</li>
<li>Acceleration algorithms, such as particular culling algorithms are also implemented here, along with whatever else the rest of the pipeline cannot handle.</li>
</ul>
<h2 id="Geometry-Processing"><a href="#Geometry-Processing" class="headerlink" title="Geometry Processing"></a>Geometry Processing</h2><p>The geometry processing stage on the GPU is responsible for most of the per-triangle and per-vertex operations. It is further divided into the following functional stages:</p>
<ul>
<li>vertex shading</li>
<li>projection</li>
<li>clipping</li>
<li>screen mapping</li>
</ul>
<h3 id="Vertex-Shading"><a href="#Vertex-Shading" class="headerlink" title="Vertex Shading"></a>Vertex Shading</h3><ul>
<li>two main tasks:<ul>
<li>compute the position for a vertex</li>
<li>evaluate whatever the programmer may like to have as vertex output data</li>
</ul>
</li>
</ul>
<p>Traditionally much of the shade of an object was computed by applying lights to each vertex’s location and normal and storing only the resulting color at the vertex. These colors were then interpolated across the triangle. For this reason, this programmable vertex processing unit was named the <strong>vertex shader</strong>.</p>
<p><img src="https://github.com/Uyouii/LearnOpenGL/raw/master/Real%20Time%20Rending%20Image/veiw%20space.PNG" alt></p>
<p><strong>shading</strong>: the operation of determining the effect of a light on a material.</p>
<h3 id="Projection"><a href="#Projection" class="headerlink" title="Projection"></a>Projection</h3><ul>
<li>orthographic projection</li>
<li>perspective projection</li>
</ul>
<p>Although these matrices transform one volume into another, they are called projections because after display, the z-coordinate is not stored in the image generated but is stored in a z-buﬀer. In this way, the models are projected from three to two dimensions.</p>
<h3 id="Clipping"><a href="#Clipping" class="headerlink" title="Clipping"></a>Clipping</h3><ul>
<li>A primitive that lies fully inside the view volume will be passed on to the next stage as is. </li>
<li>Primitives entirely outside the view volume are not passed on further, since they are not rendered. </li>
<li>It is the primitives that are partially inside the view volume that require clipping.</li>
</ul>
<h3 id="Screen-Mapping"><a href="#Screen-Mapping" class="headerlink" title="Screen Mapping"></a>Screen Mapping</h3><p>The x- and y-coordinates of each primitive are transformed to form <strong>screen coordinates</strong>.</p>
<p>Screen coordinates together with the z-coordinates are also called <strong>window coordinates</strong>.</p>
<h2 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h2><p>Rasterization process is split up into two functional substages:</p>
<ul>
<li>triangle setup (primitive assembly)<ul>
<li>In this stage the diﬀerentials, edge equations, and other data for the triangle are computed.</li>
</ul>
</li>
<li>triangle traversal<ul>
<li>Finding which samples or pixels are inside a triangle is often called triangle traversal</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/Uyouii/LearnOpenGL/raw/master/Real%20Time%20Rending%20Image/rasterization%20and%20pixel%20processing.PNG" alt></p>
<h2 id="Pixel-Processing"><a href="#Pixel-Processing" class="headerlink" title="Pixel Processing"></a>Pixel Processing</h2><p> Pixel processing is the stage where per-pixel or per-sample computations and operations are performed on pixels or samples that are inside a primitive.</p>
<p> The pixel stage is divided into :</p>
<ul>
<li>pixel shading</li>
<li>merging</li>
</ul>
<h3 id="Pixel-Shading"><a href="#Pixel-Shading" class="headerlink" title="Pixel Shading"></a>Pixel Shading</h3><p>Any per-pixel shading computations are performed here, using the interpolated shading data as input. The end result is one or more colors to be passed on to the next stage. </p>
<p><strong>texturing</strong> is employed here.</p>
<h3 id="Merging"><a href="#Merging" class="headerlink" title="Merging"></a>Merging</h3><p>A <strong>z-buﬀer</strong> is the same size and shape as the color buﬀer, and for each pixel it stores the z-value to the currently closest primitive. </p>
<p>This means that when a primitive is being rendered to a certain pixel, the z-value on that primitive<br>at that pixel is being computed and compared to the contents of the z-buﬀer at the same pixel. </p>
<ul>
<li>If the new z-value is smaller than the z-value in the z-buﬀer, then the primitive that is being rendered is closer to the camera than the primitive that was previously closest to the camera at that pixel. </li>
<li>If the computed z-value is greater than the z-value in the z-buﬀer, then the color buﬀer and the z-buﬀer are left untouched. </li>
</ul>
<p>However, the z-buﬀer stores only a single depth at each point on the screen, so it cannot be used for partially transparent primitives. These must be rendered after all opaque primitives, and in back-to-front<br>order, or using a separate order-independent algorithm (Section 5.5). Transparency is one of the major weaknesses of the basic z-buﬀer.</p>
<p>The <strong>alpha channel</strong> is associated with the color buﬀer and stores a related opacity value for each pixel.</p>
<p>The <strong>stencil buﬀer</strong> is an oﬀscreen buﬀer used to record the locations of the rendered primitiveIt typically contains 8 bits per pixel. Primitives can be rendered into the stencil buﬀer using various functions, and the buﬀer’s contents can then be used to control rendering into the color buﬀer and z-buﬀer.</p>
<p>To avoid allowing the human viewer to see the primitives as they are being rasterized and sent to the screen, <strong>double buﬀering</strong> is used. This means that the rendering of a scene takes place oﬀ screen, in a back buﬀer. </p>
<p>Once the scene has been rendered in the back buﬀer, the contents of the back buﬀer are swapped with the contents of the front buﬀer that was previously displayed on the screen. The swapping often occurs during <strong>vertical retrace</strong>, a time when it is safe to do so.</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/07/05/读书摘要/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/07/05/读书摘要/" class="post-title-link" itemprop="url">读书摘要</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-07-05 16:36:39" itemprop="dateCreated datePublished" datetime="2018-07-05T16:36:39+08:00">2018-07-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-02 11:28:18" itemprop="dateModified" datetime="2019-08-02T11:28:18+08:00">2019-08-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/bookread/" itemprop="url" rel="index"><span itemprop="name">bookread</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="神们自己"><a href="#神们自己" class="headerlink" title="神们自己"></a>神们自己</h2><ol>
<li><p>历史往往就是由这些讨厌而且毫无目的的冲动推动的。</p>
</li>
<li><p>有人认为，公众希望环境得以保护，人类的存续得以实现，还认为那些为了这类崇高目标而奋斗的理想主义者会得到公众的爱戴，这种想法都是错的。实际上，公众所期望的只有一件事：他们自己过上安逸舒适的生活。通过二十世纪的环境危机，我们早就看明白了。当人们知道吸烟会导致患癌症的几率上升而最有效的解决办法就是禁烟时，他们却希望能够发明一种不致癌的香烟。当人们知道内燃机会对大气造成污染而最好的办法就是不再使用这类引擎时，他们却希望能够发明不污染空气的引擎。</p>
</li>
<li><p>“他们只需要拒绝相信就行。面对难题，最容易的对策就是拒绝相信它的存在。”</p>
</li>
<li><p>凡是对自己有一点利益就会选择相信。有时候即使毫无可能，人们也会顽冥不化。</p>
</li>
</ol>
<h2 id="人间失格"><a href="#人间失格" class="headerlink" title="人间失格"></a>人间失格</h2><ol>
<li><p>那是我对人类最后的求爱。我对人类极度恐惧，却无论如何也无法对人类死心。</p>
</li>
<li><p>旁人承受的痛苦的性质和大小，我完全捉摸不透。现实生活中的痛苦，只是吃个饭就能化解的痛苦，或许才是莫大的痛苦。也许，我刚才所说的那十个灾祸在这些痛苦面前不值一提。也许那些我无法理解的痛苦才是凄惨的阿鼻地狱。果真如此嘛？我不知道。但即使如此，那些人依然不想轻生、不会发狂，纵谈政治、毫不绝望、毫不屈服，继续与生活作战。他们不觉得痛苦吗？他们变得自私自利，甚至视其为理所当然，难道他们从未怀疑过自己？若真如此，那真是快活。不是每个人都是如此吧？真的都满足于此吗？我不知道······在夜里酣然入睡，一早醒来就会神清气爽吗？他们做了怎样的梦？走路时想些什么？想着钱的事情？不会仅此而已吧？我似乎听过说“民以食为天”，却从未听过“人为钱而活”。不，也许因人而异吧······我还是搞不懂······思绪渐感困惑之时，我越发惶恐不安，仿佛自己是这个世界上的异类。我与旁人几乎无法交谈，因我不知该谈些什么，也不知该如何谈起。</p>
</li>
<li><p>因此我总是黯然接收外界打击，内心却承受着疯狂的恐惧。</p>
</li>
<li><p>受人责备或怒斥时，或许没有人能保持好心情。但我在人们怒不可遏的脸上，看到了比狮子、鳄鱼、巨龙更加可怕的动物本性。寻常时候，他们似乎会将这一本性刻意隐藏，但一有机会，人类可怕的真面目就会在愤怒中不经意的暴露出来。就像在草地上安稳打盹的牛，冷不防甩尾吗“啪”地打死肚子上地牛虻。每每见到人类露出本性，我都惊悚得汗毛倒竖。而一旦想到，这种本性或许是人活于世的必备资质之一，我简直要对自己绝望了。</p>
</li>
<li><p>对讨厌的事物说不出讨厌，对喜欢的事也总是偷偷摸摸，我总是品着极为苦涩的滋味，困难以名状的恐惧痛苦挣扎。</p>
</li>
<li><p>我一向对“向人诉苦”不抱任何期待。无论是向父母说，还是向警察或者政府说，最终还是会被那些深谙处世之道的人打败，任由他们花言巧语，喋喋不休。</p>
</li>
<li><p>相互欺骗的双方竟然都相安无事，甚至未曾察觉相互欺骗之事————我以为，人类生活中无处不是这样单纯、明了的不信任之举。</p>
</li>
<li><p>对人类极度恐惧的人，反而会比任何人都渴望亲眼见识妖怪的可怕。愈是敏感、愈是胆怯，愈会企盼暴风雨降临的更加猛烈。</p>
</li>
<li><p>对我而言，听女人就自己的身世说上千言万语，也不及一句低喃让我心生共鸣。我是如此期盼听到这句低语，然而我在这世上遇到的女子，竟没有一人向我如此诉说，我深感不可思议。眼前这名女子，虽然没有用言语变现自己的寂寞，但整个身体的轮廓却无声地吐露出巨大地寂寞气息。她的身旁仿佛充斥着约莫一寸见方的气流，走近她身旁，我的身体也被那气流说包裹。这气流与我自身携带的阴郁气流完美的融合，如贴在水底岩石上的枯叶一般，是我得以从恐惧与不安中抽离。</p>
</li>
<li><p>胆小鬼连幸福都会害怕，碰到棉花都会受伤，有时还会被幸福所伤。</p>
</li>
</ol>
<h2 id="天才在左，疯子在右"><a href="#天才在左，疯子在右" class="headerlink" title="天才在左，疯子在右"></a>天才在左，疯子在右</h2><ol>
<li>人之所以会产生一些妄想或者说是幻觉，主要是因为大脑不听使唤，左脑接受了来自右脑的错误指令，因而产生了歪曲的理解和判断。</li>
<li>缺乏安全感和孤独寂寞的人最容易出现妄想症，他们最初觉得“没人关系我”，后来演变为“有人要害我”。</li>
<li>视觉对于外界光线的感应能偶帮助我们维持生物钟的正常运转。但如果用光线照射我们的双眼，大脑便会由此“上当”，从而加速或者减缓我们的生理时钟的运转。</li>
<li>“马太效应”是社会心理学的经典效应，他向我们证明了强者恒强、弱者越弱的道理。如果一个人获得了成功，那么随之而来，各种好事情都会发生在他的身上。同样，如果一个人很衰，他就会遇到各种各样衰的事情。</li>
<li>心理学家认为，人的幸或者不幸，并不是上帝在天空中决定并安排好的，实际上一个人的运气好坏是由这个人的行为和思想决定的。<br>  幸运的人通常乐观积极，活力四射，这样的心态让他们对未知的恐惧低于阈值，因为更容易接受新的挑战，更容易抓住新的机遇。<pre><code>而那些不幸的人则相反，他们多半性格孤僻，反应也不够敏捷。他们的情感关注点更多地集中于自己身上，因此很害怕周遭发生的会让自己感受到不舒服的改变。对他们而言，“未知”便是最大的恐惧和不安，处于恐惧中时，他们便会与大好的机会擦肩而过。
</code></pre></li>
<li>自我监控能力强的人显然更容易成为撒谎高手，而这种能力较弱的人，似乎用撒谎来掩饰自己的意识较差。</li>
<li>六度分隔假说，其含义是世界上任意两个欲取得联系的陌生人之间，最多只隔着六个人，便能够达成联系。</li>
<li>越是急于证明自己，就越是证明不了。因为没有人愿意跟着你的思路去思考问题。</li>
<li>车尔尼雪夫斯基说：“在人间有什么会更有诗意，更为迷人，胜于那怀着欢乐的爱，对自己觉得像自己本身一样崇高、纯洁和美妙的一切东西都发生共鸣的纯真的纯真的少年心灵呢？”</li>
<li>童年对一个作家的影响是深入骨髓的，是融贯在灵魂中的，同年是我们的精神故乡，同年所遭受的创伤会让人铭记在心。创伤在灵魂的深处生了根，就好像在土地中播撒了种子般，在岁月流逝中，种子逐渐发芽、长出了树枝，成长为参天大树，然而其根基仍然是当初的种子，是由幼时的创伤繁衍出来的。创伤及由此而形成的思想就由此成为作家作品的内核。</li>
<li>有人曾这样描述弗吉尼亚.伍尔夫：“她的记忆有着隐秘的两面——一面澄清，一面黑暗；一面寒冷，一面温热；一面创造，一面是毁灭；一面铺洒着天堂之光，一面燃烧着地狱之火。</li>
</ol>
<h2 id="解忧杂货店"><a href="#解忧杂货店" class="headerlink" title="解忧杂货店"></a>解忧杂货店</h2><ol>
<li>他们内心都破了个洞，重要的东西正从那个破洞中流失。人的心声是绝对不能无视的。</li>
<li>很多时候，咨询的人心里已经有个答案，来咨询只是想确认自己的决定是对的。所以有些人读过回信后，会再次写信过来，大概就是因为回答的内容和他的想法不一样吧。</li>
<li>如果自己不想积极乐观的生活，不管得到什么样的回答都没有用。</li>
<li>虽然至今为止的道路绝非一片坦途，但想到正因为或者才有机会感受到痛楚，我就成功克服了种种困难。</li>
<li>人与人之间请以断绝，并不需要什么具体的理由。就算表面上有，也很可能只是心已经离开的结果，事后才编造出的借口而已。因为倘若心没有离开，当将会导致关系破裂的师太发生时，理应有人努力去挽救。如果没有，说明其实关系早已破裂。</li>
<li>可是换个角度来看，正因为是一张白纸，才可以随心所欲地描绘地图。一切全在你自己。对你来说，一切都是自由的，在你面前是无限的可能。这可是很棒的事呀。我衷心祈祷你可以相信自己，无悔地燃烧自己的人生。</li>
<li>话语教给我们很多，但善恶还是可以自明。话语想要教给我们，人与人生来就不平等。在人间，尊卑有序是永恒的真理，但你也可以不听。</li>
</ol>
<h2 id="无人生还"><a href="#无人生还" class="headerlink" title="无人生还"></a>无人生还</h2><ol>
<li>直到现在我才明白，艺术家永远不会只满足于创造艺术。他渴望自己的艺术得到世人的青睐，是人性使然。</li>
</ol>
<h2 id="小王子"><a href="#小王子" class="headerlink" title="小王子"></a>小王子</h2><ol>
<li>如果有一个人爱上在这亿万颗星星中仅有的一朵花，这人望着星空的时候，就会觉得幸福。</li>
<li>审判自己，比审判别人难得多。你若是能够公正地审判自己，那你就是一个真正地贤士。</li>
<li>在我看来，你只不过是一个小男孩，跟成千上万地男孩毫无两样。我不需要你，你也不需要我。对你来说我只不过是一只狐狸，跟成千上万的狐狸毫无两样。但是，你如果驯养了我，那么我们俩就彼此相互需要。对我来说，你是世界上独一无二的；我在你看来，也是世界上独一无二的……</li>
<li>只有用心看，才能看的清楚；本质的东西，眼睛是看不见的。</li>
<li>正是因为你为你的玫瑰，花费了时间，才使你的花儿变得那么重要。</li>
<li>对你驯养的东西，你要永远负责。你必须对你的玫瑰花负责……</li>
<li>“沙漠美丽”，小王子说，“是因为在某个地方藏着一口水井……”</li>
<li>无论是房子、星星或沙漠，使它们美丽的东西是看不见的。</li>
<li>这水，不只是一种饮料，它是从披星戴月地长途跋涉、轱辘的歌声、我的双臂的力量产生出来的。这水，像是一份礼物，使心田得到慰藉。在我小的时候，只有圣诞树的光、子夜弥撒的音乐、甜蜜的微笑，这一切才使得我的圣诞礼物光芒四射。</li>
<li>眼睛是什么也看不见的。应该用心灵去找。</li>
<li>你倘若爱上一朵生长在星星上的花，那么，在夜间，你看看天空就会感到愉快。所有的星星都像盛开的鲜花。</li>
<li>“每个人都有星星，“小王子说，”但在不同的人眼里就是不一样。对旅行者，星星是指引路的。对另一些人，星星只是一些小亮光。对学者，星星是探讨的问题。对我的那个商人，星星是黄金。但是，所有的星星都是一声不响的。你有的那些星星，是别人得不到的！“</li>
<li>”你夜间仰望星空时，由于我就住在其中的一颗星星上，由于我在其中的一颗星上笑，那么，对你来说，所有的星星仿佛都在笑。唯有你，有一些会笑的星星。“</li>
</ol>
<h2 id="情人"><a href="#情人" class="headerlink" title="情人"></a>情人</h2><ol>
<li>一种可以自由地支配时间的快感和一种怎样来支配这段时间的犹豫往往老是搅和在一起。</li>
<li>男人与女人并不是整天厮守在一起才算幸福，男人女人如果没有共同理想，各自没有独立的能力，很难保持男女间的关系至始至终。</li>
<li>不管怎么爱着这个男人，也不想失去自己一个人时的清静，自己 有属于自己的时间，这是最重要的。</li>
<li>但是人会喜欢上一个人也不是瞎说，世界上就是有着这种不合道理的道理，这要靠每个人的良知与道德修养来做出评判。</li>
<li>我可不是你想象的那样漂亮美丽、心地善良的女人呦。我有人们所具有的假面，在你看到的这假面背后，傲慢、猥琐、任性等等的毛病，我是应有尽有的呢。</li>
<li>男人与女人之间就应该有这么一面不能捅破的隔墙，才能使两人之间的关系保持长久的新鲜感。</li>
<li>也许有人会感到这种关系不太近人情。但是格子生活的全部都相互缠在一起，人生特有的趣味便会淡漠无存。</li>
<li>“请与我结婚吧”这句话，对女人来说都是梦寐以求的，不管她喜不喜欢这个男人。这句话，是绝对能将女人的心彻彻底底地打动地。</li>
<li>情人的地位确实不稳定，但同时却代表着美丽的存在。</li>
<li>忘记日常生活的琐碎杂事，相互体贴，相互慰藉。难得的见面，使双方都将自己的美德表现出来。生日呀，两人初恋的日子呀，每一个有意义的日子，两人都一起过，那样的时刻便是最珍贵，最幸福的。</li>
<li>有不少女人是只愿当情人，不愿做妻子的，这种情人的爱情，不是一生一世，而是一时一刻的。这样才更适合自己，能更自由自在，更能展示自己的魅力。为此而忌讳那种结婚名分的女人并不为少。</li>
</ol>
<h2 id="百年孤独"><a href="#百年孤独" class="headerlink" title="百年孤独"></a>百年孤独</h2><ol>
<li>死神一直追随者他的脚步，嗅闻他的行踪，但尚未下定决心给他最后一击。</li>
<li>“世上正发生着不可思议的事情，”他对乌尔苏拉说，“就在那边，在河的另一边，各种魔法机器应有尽有，而我们却还像驴子一样生活。”</li>
<li>蕾梅黛丝在下午两点令人昏昏欲睡的空气中，蕾梅黛丝在玫瑰无声的呼吸中，蕾梅黛丝在清晨面包的热其中，蕾梅黛丝无所不在，蕾梅黛丝无视或缺。</li>
<li>你那么憎恨军人，跟他们斗了这么久，琢磨了他们这么久，最终却变得和他们一样。人世间没有任何理想值得以这样的沉沦作为代价。</li>
<li>约略懂得幸福的晚年秘诀不过是与孤独签下不失尊严的协定罢了。</li>
<li>过去都是假的，回忆没有归路，春天总是一去不复返，最疯狂执着的爱情也终究是过往云烟。</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/07/05/python为什么是伪多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/07/05/python为什么是伪多线程/" class="post-title-link" itemprop="url">python为什么是伪多线程</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-07-05 16:35:01" itemprop="dateCreated datePublished" datetime="2018-07-05T16:35:01+08:00">2018-07-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-02 11:28:18" itemprop="dateModified" datetime="2019-08-02T11:28:18+08:00">2019-08-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/learning-python/" itemprop="url" rel="index"><span itemprop="name">learning python</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="python为什么是为多线程"><a href="#python为什么是为多线程" class="headerlink" title="python为什么是为多线程"></a>python为什么是为多线程</h1><p>Python由于有全锁局的存在（同一时间只能有一个线程执行），并不能利用多核优势。所以，如果你的多线程进程是CPU密集型的，那多线程并不能带来效率上的提升，相反还可能会因为线程的频繁切换，导致效率下降；如果是IO密集型，多线程进程可以利用IO阻塞等待时的空闲时间执行其他线程，提升效率。</p>
<p>来源： <a href="https://www.zhihu.com/question/22191088/answer/20576021" target="_blank" rel="noopener">https://www.zhihu.com/question/22191088/answer/20576021</a></p>
<h1 id="GIL-全局解释器锁"><a href="#GIL-全局解释器锁" class="headerlink" title="GIL 全局解释器锁"></a>GIL 全局解释器锁</h1><p>GIL：<strong>Global Interpreter Lock</strong> </p>
<p>Python代码的执行是由Python虚拟机（又名解释器主循环）控制的。Python在设计时是这样考虑的，在主循环中同时只能有一个控制线程在执行，尽管Python解释器可以同时运行多个线程，但是在任意给定时刻只有一个线程会被解释器执行。</p>
<p>对Python虚拟机的访问是由全局解释器锁（GIL）控制的。这个锁就是用来保证同时只能有一个线程运行的。在多线程环境中，Python虚拟机将按照下面所述的方式执行：</p>
<ol>
<li>设置GIL</li>
<li>切换进一个线程去运行</li>
<li>执行下面操作之一<ol>
<li>指定数量的字节码指令</li>
<li>线程主动让出控制权（可以调用time.sleep(0)来完成）</li>
</ol>
</li>
<li>把线程设置回睡眠状态（切换出线程）</li>
<li>解锁GIL</li>
<li>重复上述步骤</li>
</ol>
<p>当调用外部代码（即，任意C/C++扩展的内置函数）时，GIL会保持锁定，直至函数执行结束（因为在这期间没有Python字节码计数）。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/logo1.jpg"
      alt="Uyouii">
  <p class="site-author-name" itemprop="name">Uyouii</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/Uyouii" title="GitHub &rarr; https://github.com/Uyouii" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:taiyoudong@gmail.com" title="E-Mail &rarr; mailto:taiyoudong@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Uyouii</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
    
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  <script src="/js/utils.js?v=7.3.0"></script>

  
  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>



  

  <script src="/js/next-boot.js?v=7.3.0"></script>

  

  

  


  

































    


</body>
</html>
