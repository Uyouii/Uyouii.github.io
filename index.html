<!DOCTYPE html>





<html class="theme-next gemini" lang="en">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Uyouii&#39;s Blogs">
<meta property="og:url" content="https://uyouii.github.io/index.html">
<meta property="og:site_name" content="Uyouii&#39;s Blogs">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Uyouii&#39;s Blogs">
  <link rel="canonical" href="https://uyouii.github.io/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Uyouii's Blogs</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Uyouii's Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">There are many things need to learn.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
    </ul>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/10/27/Effective-Modern-C-2-理解auto型别推导/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/27/Effective-Modern-C-2-理解auto型别推导/" class="post-title-link" itemprop="url">Effective Modern C++ 2 理解auto型别推导</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-10-27 22:38:12 / Modified: 22:40:16" itemprop="dateCreated datePublished" datetime="2019-10-27T22:38:12+08:00">2019-10-27</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/effective-modern-c/" itemprop="url" rel="index"><span itemprop="name">effective modern c++</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="条款2：-理解auto-型别推导"><a href="#条款2：-理解auto-型别推导" class="headerlink" title="条款2： 理解auto 型别推导"></a>条款2： 理解auto 型别推导</h2><p>在模板型别推导和auto型别推导可以建立起一一映射，它们之间也确实存在着双向的算法变换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line">f(expr);	<span class="comment">// 以某表达式调用f</span></span><br></pre></td></tr></table></figure>
<p>在f的调用语句中，编译器会利用expr来推导T和ParamType的型别。</p>
<p>当某变量采用auto来声明的时候，auto就扮演了模板中T这个角色，而变量的饰词则扮演的是ParamType的角色。</p>
<ul>
<li>情况1: <em>ParamType</em>是个指针或者引用，但不是个万能引用</li>
<li>情况2: <em>ParamType</em>是个万能引用</li>
<li>情况3: <em>ParamType</em>既非指针也非引用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况1 或 情况3</span></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>;		<span class="comment">// 情况3（x既非指针也非引用）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cx = x;	<span class="comment">// 情况3（cx既非指针也非引用）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; rx = x;	<span class="comment">// 情况1（rx是个引用，但不是个万能引用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况2</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref1 = x;	<span class="comment">// x的型别是int，且是左值</span></span><br><span class="line">					<span class="comment">// 所以uref1的型别是int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref2 = x;	<span class="comment">// cx的型别是const int，且是左值</span></span><br><span class="line">					<span class="comment">// 所以uref2的型别是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref3 = <span class="number">27</span>;	<span class="comment">// 27的型别是int，且是右值</span></span><br><span class="line">					<span class="comment">// 所以uref2的型别是int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>数组和函数的情况也适用于auto型别的推导</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[] = <span class="string">"xxxxxx"</span>	<span class="comment">// name的型别是 const char [7]</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">auto</span> arr1 = name;				<span class="comment">// arr1的型别是const char *</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> arr2 = name;				<span class="comment">// arr1的型别是const char (&amp;)[7]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span>		<span class="comment">// someFunc是个函数，型别是void(int, double)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> func1 </span>= someFunc;			<span class="comment">// fun1的型别是 void(*)(int, double)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; func2 = someFunc;			<span class="comment">// func2的型别是void(&amp;)(int, double)</span></span><br></pre></td></tr></table></figure>
<h3 id="auto和模板类型的不同"><a href="#auto和模板类型的不同" class="headerlink" title="auto和模板类型的不同"></a>auto和模板类型的不同</h3><p>声明一个int并初始化，C++98中有两种语法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x1 = <span class="number">27</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>C++11为了支持统一初始化(uniform initialization)，增加了下面的语法选项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x3 = &#123;<span class="number">27</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> x4&#123;<span class="number">27</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>如果用auto：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = <span class="number">27</span>;		<span class="comment">// 型别是int，值是27</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;		<span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">auto</span> x3 = &#123;<span class="number">27</span>&#125;;		<span class="comment">// 型别是 std::initializer_list&lt;int&gt;，值是&#123;27&#125;</span></span><br><span class="line"><span class="keyword">auto</span> x4&#123;<span class="number">27</span>&#125;;		<span class="comment">// 同上</span></span><br></pre></td></tr></table></figure>
<p>后面两个语句，声明了这么一个变量，其型别类型为std::initializer_list<int>，且含有单个值为27的元素。</int></p>
<p>当用于auto声明变量的初始表达式是大括号起时，推导所得的型别就属于std::initizlizer_list。</p>
<p>对于大括号初始表达式的处理方式，是auto型别推导和模板型别推导的唯一不同之处。当采用auto声明的变量使用大括号初始化表达式进行初始化时，推导所得的型别是std::initializer_list的一个实例型别。</p>
<p>但是如果向对应模板传入一个同样的初始化表达式，型别类型推导将会失败，代码将不同通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;		<span class="comment">// x的型别是 std::initializer_list&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line">f(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)				<span class="comment">//错误，无法推导T的型别</span></span><br></pre></td></tr></table></figure>
<p>auto和模板类型推导的唯一区别是，auto会假定用大括号起的初始化表达式是一个std::initialize_list，但是模板型别推导不会。</p>
<p>C++14允许使用auto来说明函数返回值需要推导，而且C++14中的lamba表达式也会在形参中用到auto。然而，这些auto的用法是在使用模板型别推导，而非auto型别推导，所以，带有auto返回值的函数如果需要返回一个大括号起的初始化表达式，是通不过编译的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createInitList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;			<span class="comment">// 错误，无法为&#123;1,2,3&#125;完成型别类型推导</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用auto来指定C++14中lambda式的形参型别时，也不能使用大括号起的初始化表达式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> resetV =</span><br><span class="line">  [&amp;v](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; newValue) &#123; v = newValue; &#125;;     <span class="comment">// C++14</span></span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">resetV(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);          <span class="comment">// error! can't deduce type</span></span><br><span class="line">                              <span class="comment">// for &#123; 1, 2, 3 &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>在一般情况下，auto型别推导和模板型别推导时一模一样的，但是auto型别推导会假定用大括号括起的初始化表达式代表一个std::intializer_list，但是模板型别推导不会</li>
<li>在函数返回值或lambda式的形参中使用auto，意思是使用模板型别推导而非auto型别推导。</li>
</ul>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/10/27/Effective-Modern-C-1-理解模板型别推导/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/27/Effective-Modern-C-1-理解模板型别推导/" class="post-title-link" itemprop="url">Effective Modern C++ 1 理解模板型别推导</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-10-27 22:37:41 / Modified: 22:39:59" itemprop="dateCreated datePublished" datetime="2019-10-27T22:37:41+08:00">2019-10-27</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/effective-modern-c/" itemprop="url" rel="index"><span itemprop="name">effective modern c++</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="条款1：理解模版型别推导"><a href="#条款1：理解模版型别推导" class="headerlink" title="条款1：理解模版型别推导"></a>条款1：理解模版型别推导</h2><p>函数模版形如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一次调用形如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(expr);</span><br></pre></td></tr></table></figure>
<p>编译器会通过expre推导两个型别：一个是T的型别，一个是ParamType的型别，这两个型别通常不一样，因为ParamType通常包含了一些饰词，如const或引用符号等限定词。</p>
<p>T的型别推导结果，不仅仅以来expr的型别，还依赖ParamType的形式。具体分三种情况讨论。</p>
<h3 id="情况1-ParamType是个指针或者引用，但不是个万能引用"><a href="#情况1-ParamType是个指针或者引用，但不是个万能引用" class="headerlink" title="情况1: ParamType是个指针或者引用，但不是个万能引用"></a>情况1: <em>ParamType</em>是个指针或者引用，但不是个万能引用</h3><p>这种情形下，型别推导会这样运作：</p>
<ol>
<li>若expr具有引用型别，现将引用部分忽略</li>
<li>对expr的型别和ParamType的型别执行模式匹配，来决定T的型别</li>
</ol>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;		<span class="comment">// param是个引用</span></span><br><span class="line"></span><br><span class="line">声明变量：</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;				<span class="comment">// x的类型是int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;		<span class="comment">// cx的类型是const int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;		<span class="comment">// rx是x的型别为const int的引用</span></span><br><span class="line"></span><br><span class="line">f(x);	<span class="comment">// T的类型是int，param的类型是int&amp;</span></span><br><span class="line">f(cx);	<span class="comment">// T的类型是const int，param的类型是const int&amp;</span></span><br><span class="line">f(rx);	<span class="comment">// T的类型是const int，param的类型是const int&amp;</span></span><br></pre></td></tr></table></figure>
<p>由于cx和rx的值都被指明为const ，所以T的型别被推到为const int，从而形参的型别就成了const int&amp;。</p>
<p>当人们向引用型别传入const 对象时，他们期望对该对象保持不可修改的属性，即期望该形参成为const的引用型别。</p>
<p>向持有T&amp;型别的模版传入const对象是安全的：该对象的常量性（constness）会成为T的型别推导结果的组成部分。</p>
<p>而引用性（reference-ness）会在型别推导过程中被忽略。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;	<span class="comment">// param是个引用</span></span><br><span class="line"></span><br><span class="line">声明变量：</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;				<span class="comment">// 同前</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;		<span class="comment">// 同前</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;		<span class="comment">// 同前</span></span><br><span class="line"></span><br><span class="line">f(x);	<span class="comment">// T的类型是int，param的类型是const int&amp;</span></span><br><span class="line">f(cx);	<span class="comment">// T的类型是int，param的类型是const int&amp;</span></span><br><span class="line">f(rx);	<span class="comment">// T的类型是int，param的类型是const int&amp;</span></span><br></pre></td></tr></table></figure>
<p>rx的引用性在型别推导过程中是被忽略的。</p>
<p>如果param是个指针，而非引用，运作方式上本质上没有不同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;	<span class="comment">// param是个指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *px = &amp;x;	<span class="comment">// px是指到x的指针，类型为 const int</span></span><br><span class="line">f(&amp;x);				<span class="comment">// T的类型是int，param的类型是int*</span></span><br><span class="line">f(px);				<span class="comment">// T的类型是const int，param的类型是const int*</span></span><br></pre></td></tr></table></figure>
<h3 id="情况2-ParamType是个万能引用"><a href="#情况2-ParamType是个万能引用" class="headerlink" title="情况2: ParamType是个万能引用"></a>情况2: <em>ParamType</em>是个万能引用</h3><p>万能引用的声明型别写作：T&amp;&amp;</p>
<ul>
<li>如果expr是个左值，T和ParamType都会被推导为左值引用。这个结果具有双重奇特之处：首先，这是在模版类型推导中，T被推导为引用型的唯一情形。其次，尽管在声明时使用的是右值引用语法，它的型别推导结果却是左值引用。</li>
<li>如果expre是个右值，则应用“常规”的规则。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;	<span class="comment">// param是个万能引用</span></span><br><span class="line"></span><br><span class="line">声明变量：</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;				<span class="comment">// 同前</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;		<span class="comment">// 同前</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;		<span class="comment">// 同前</span></span><br><span class="line"></span><br><span class="line">f(x);	<span class="comment">// x是个左值，所以T的型别是int&amp;，param的型别也是int&amp;</span></span><br><span class="line">f(cx);	<span class="comment">// cx是个左值，所以T的型别是const int&amp;</span></span><br><span class="line">		<span class="comment">// param的型别也是const int&amp;</span></span><br><span class="line">f(rx);	<span class="comment">// rx是个左值，所以T的型别是const int&amp;</span></span><br><span class="line">		<span class="comment">// param的型别也是const int&amp;</span></span><br><span class="line">f(<span class="number">27</span>);	<span class="comment">// 27是个右值，所以T的型别是int</span></span><br><span class="line">		<span class="comment">// param就成了int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>万能引用的推导规则不同于左值引用和右值引用形参。当遇到万能引用时，型别推导类型规则会区分实参是左值还是右值。而非万能引用时从来不会作这样的区分的。</p>
<h3 id="情况3-ParamType既非指针也非引用"><a href="#情况3-ParamType既非指针也非引用" class="headerlink" title="情况3: ParamType既非指针也非引用"></a>情况3: <em>ParamType</em>既非指针也非引用</h3><p>既非指针，也非引用，就是按值传递了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;	<span class="comment">// param是按值传递</span></span><br></pre></td></tr></table></figure>
<p>无论传入的是什么，param都会是它的一个副本，也即是一个全新的对象。</p>
<ul>
<li>exper具有引用型别，则忽略其引用部分</li>
<li>忽略引用部分之后，若expre是个const对象，也忽略。如果是一个volatile对象，也忽略。</li>
</ul>
<p>所以</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;				<span class="comment">// 同前</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;		<span class="comment">// 同前</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;		<span class="comment">// 同前</span></span><br><span class="line"></span><br><span class="line">f(x);	<span class="comment">// T和prama都是int</span></span><br><span class="line">f(cx);	<span class="comment">// T和prama都是int</span></span><br><span class="line">f(rx);	<span class="comment">// T和prama都是int</span></span><br></pre></td></tr></table></figure>
<p>cx和rx代表const值，param仍然不具有const型别，这是合理的。</p>
<p>param是个完全独立于cx和rx存在的对象——是cx和rx的一个<strong>副本</strong>，cx和rx不能修改不能说明param不能修改。expre的常量性和挥发性（volatileness，若有）可以在推导param的型别时忽略。</p>
<p>重点说明的是，const（和volatile）仅会在按值形参处被忽略。若形参是const的引用或者指针，expre的常量性会在型别推导过程中加以保留。</p>
<p>但是这种情况，expr是一个指到const对象的const指针，且expr按值传递给param：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> ptr = <span class="string">"xxxx"</span>;</span><br><span class="line">f(ptr);			<span class="comment">// 传递类型为 const char * const</span></span><br></pre></td></tr></table></figure>
<p>ptr这个指针自己会按值传递，按照按值传递的规则，ptr的常量性会被忽略，param的型别会被推导为const char*。</p>
<p>即ptr的指向对象的常量性会被保留，但是其自身的常量性会在以复制方式创建新指针param时被忽略。</p>
<h3 id="数组实参"><a href="#数组实参" class="headerlink" title="数组实参"></a>数组实参</h3><p>数组型别有别于指针型别，很多语境下，数组会退化成指到其首元素的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[] = <span class="string">"xxx"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line">f(name);</span><br></pre></td></tr></table></figure>
<p>由于数组形参声明会按照他们好像是指针形参那样处理，按值传递给函数模版的数组型别会被推导成指针型别。</p>
<p>在模版f调用中，其型别类型T会被推导成const char*</p>
<p>难点来了，尽管函数无法声明真正的数组类型形参，它们却能够将形参声明成数组的引用。如果修改模版f，制定按照引用的方式传递实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line">f(name);			<span class="comment">// 向f传递一个数组</span></span><br></pre></td></tr></table></figure>
<p>这种情况下，T的型别会推导成实际数组的型别，这个型别包含数组的尺寸。</p>
<p>本例中，T的型别推导类型结果为 const char [4]，而f的形参被推导为 const char (&amp;)[4]。</p>
<p>可以利用数组引用这一能力创造一个模版，用来推导数组含有的元素个数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以编译期常量的形式返回数组尺寸</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> arraySize( T(&amp;)[N]) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将该函数声明为constexpr，能够使得其返回值在编译期间可用。从而就可以指定一个数组时，制定其尺寸和另一个数组相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> keyVals = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> mappedVals[arraySize(keyVals)];</span><br></pre></td></tr></table></figure>
<h3 id="函数实参"><a href="#函数实参" class="headerlink" title="函数实参"></a>函数实参</h3><p>数组并非c++唯一可以退化为指针之物。函数型别也同样可以退化为函数指针，针对数组型别的推导的一切导论适用于函数向其指针的退化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;		<span class="comment">// param按值传递</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(T param)</span></span>;		<span class="comment">// param按引用传递</span></span><br><span class="line"></span><br><span class="line">f1(someFunc);			<span class="comment">// param被推导为函数指针</span></span><br><span class="line">						<span class="comment">// 具体类型为 void(*)(int, double)</span></span><br><span class="line">f2(someFunc);			<span class="comment">// param被推导为函数引用</span></span><br><span class="line">						<span class="comment">// 具体类型为 void(&amp;)(int, double)</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>在模版类型推导过程中，具有引用类型的实参会被当成非引用类型来处理。即其引用性会被忽略</li>
<li>对万能引用形参进行推导时，左值实参会进行特殊处理</li>
<li>对按值传递的形参进行推导时，若实参中带有const 或 volatile饰词，则它们还是会被当作不带const或volatile饰词的型别来处理</li>
<li>在模版型别推导过程中，数组或函数类型的实参会退化成对应的指针，除非它们被用来初始化引用。</li>
</ul>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/三体/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/三体/" class="post-title-link" itemprop="url">三体</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:18:23 / Modified: 18:19:32" itemprop="dateCreated datePublished" datetime="2019-08-03T18:18:23+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/bookread/" itemprop="url" rel="index"><span itemprop="name">bookread</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="三体"><a href="#三体" class="headerlink" title="三体"></a>三体</h2><ol>
<li>那是一个荒凉的山谷，雪山从山谷的尽头露出一抹白；山谷的这一端，半截沧桑的枯木占据几乎三分之一的画面。汪淼在想象中把那个萦绕在他脑海里中的身影叠印到画面上。让她位于山谷的深处，看上去很小很小；这时汪淼惊奇地发现，整个画面苏醒过来，仿佛照片中的世界认出了那个身影，放佛这一切本来就是为她而存在。他又依次在想象中将那个身影叠印到另外几幅作品上，有时还将她那双眼睛作为照片上空旷苍穹的背景，那些画面也都苏醒过来，展现出一种汪淼从未想象过的美。以前，汪淼总觉得自己的摄影作品缺少某种灵魂；现在他知道了，缺的是她。</li>
<li>“那你的生活是一种偶然，世界有这么多变换莫测的因素，你的人生却没什么变故。”</li>
<li>“射手”假说：有一名神枪手，在一个靶子上每隔十厘米打一个洞。设想这个靶子的平面上生活着一种二维智能生物，它们中的科学家在对自己的宇宙进行观察后，发现了一个伟大的定律：“宇宙每隔10厘米，必然会有一个洞。”它们把这个神枪手一时兴起的随意行为，看成了自己宇宙的铁律。</li>
<li>“农场主假说” 则有一层令人不安的恐怖色彩：一个农场里有一群火鸡，农场主每天中午十一点来给它们喂食。火鸡中的一名科学家观察到这个现象，一直观察了近一年都没有例外，于是它也发现了自己宇宙的伟大定律：“每天上午十一点，就有食物降临。”它在感恩节早晨向火鸡们公布了这个定律，但这天上午十一点食物没有降临，农场主进来把它们都捉去杀了。</li>
<li>地球生命真的是宇宙偶然里的偶然，宇宙是个空荡荡的大宫殿，人类是这宫殿中唯一的一只小蚂蚁。这想法让我的后半辈子有一种很矛盾的心态：有时觉得生命珍贵，一切都重如泰山；有时又觉得人是那么渺小，什么都不值一提。反正日子就在这种奇怪的感觉中一天天过去，不知不觉人就老了……</li>
<li>城市就是森林，每一个男人都是猎手，每一个女人都是陷阱。</li>
<li>生活需要平滑，但也需要一个方向，不能总是回到起点。</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/明朝那些事儿/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/明朝那些事儿/" class="post-title-link" itemprop="url">明朝那些事儿</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:18:05 / Modified: 18:21:23" itemprop="dateCreated datePublished" datetime="2019-08-03T18:18:05+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/bookread/" itemprop="url" rel="index"><span itemprop="name">bookread</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="明朝那些事儿-卷1"><a href="#明朝那些事儿-卷1" class="headerlink" title="明朝那些事儿 卷1"></a>明朝那些事儿 卷1</h2><ol>
<li>这是一个伟大的转变，很多人可能穷其一辈子也无法实现。转变的关键在于心。 对于我们来说，心是最柔弱的地方，它特别容易被伤害，爱情的背叛、亲情的失去·友情的丢失，都将是重重的一击。 是的，即使你拥有人人羡慕的容貌、博览群书的才学、挥霍不尽的财富，也不能证明你的强大。因为心的强大，才是真正的强大。</li>
<li>自古以来，建立一个王朝很难，毁灭一个却相对容易的多，所谓“墙倒众人推，破鼓万人捶”，不是没有道理的。</li>
<li>当愤怒和不满超过了限度，当连狗一样生存下去都成为一种奢望的时候，反抗是唯一的道路。反抗是为了生存。</li>
<li>知道可能面对的困难和痛苦，在死亡的恐惧中不断挣扎，而仍然能战胜自己，选择这条道路，才是真正的勇气。</li>
<li>所以我认为中国历史上的农民起义确实是值得肯定的，他们也许不是那么厚道，他们也许有自己各自的打算，但他们确实别无选择。</li>
<li>一个人要显示自己的力量，从来不是靠暴力，挑战这一准则的人必然会被历史从强者的行列中淘汰，历来如此。</li>
<li>迷信是封建时代人们的通病，要想占有天下，必须要占据王气之地。南京就是这么一个地方，紫金山纵横南北，恰似巨龙潜伏，而石头山则临江陡峭，如虎盘踞，这就是南京龙蟠虎踞的来历。</li>
<li>张士诚和陈友谅，这两个人都是当世之豪杰，如果他们分别出现在不同的朝代，应该都能成就大业，可惜，历史注定要让这个时代热闹一点。这是一场淘汰赛，只有坚持到最后的人才能获得胜利。</li>
<li>张士诚，朱元璋对他有一个精准的评价：器小。这个人确实没有大志向，但他的的确确是个好人，还是个大好人。他生来就沉默寡言，待人宽大，免除了浙江一带的赋税，江浙一带的百姓都受了他的恩惠，纷纷为他修建祠堂。但他的过于宽大和无主见也使得他无法成为枭雄，而只能做一个豪杰。</li>
<li>在战役实施中，只有一个时机是最适合的，能抓住这个时机的，即是天才。 —— 拿破仑</li>
<li>越接近对方的水平，就越了解对方的强大，就会越来越畏惧。当他的畏惧达到极点的时候，也就是他能与对手匹敌的时候！</li>
<li>毫无疑问，陈友谅是一个传统意义上的坏人，但在那个乱世里，他的行为法则却是当时通用的选择。如果要生存下去，这似乎又是必然的选择，他的错误在于将这种法则发展到了极致，直到走火入魔的地步。迷信暴力，不讲基本的信用使他丧失了人心。但他又是一个真正的枭雄，他坏事做尽，却又敢作敢当（后来的朱元璋也没有能够做到），具有极强的军事和政治才能，反抗元王朝的统治，能够自始至终，从来没有向元王朝妥协，坚持到了最后。从这个角度看，他是条好汉。可惜，在这个乱世里，他只是个枭雄，真正的英雄是朱元璋。</li>
<li>一位著名的历史学家说过，农民两千年的起义只是为了一块土地。不是农民就是地主！别无选择！</li>
<li>性格决定命运</li>
<li>张士诚是一个有着坚强意志的人，他白手起家，成就一方霸业。但他的缺点和他的优点一样突出，作为乱世群雄中的一个，他走着小富即安的心理，却并不明白，再这样的环境中进行的，只能是淘汰赛，胜利者只有一个。但他是值得敬佩，他意志坚强，反抗元的暴虐统治，虽曾投降过，但毕竟只是权宜之计。在死亡面前毫不畏惧，把自己的信念坚持到了最后一刻。不怕死的人是值得尊敬的。</li>
<li>一个人的气节和尊严正是在最困难的时候体现出来的</li>
<li>常遇春的一生，从太平之战自告奋勇，到北出沙漠，所向无敌，他用自己的行动证明了他是真正的军事天才，是真正的第一先锋。他的生命就像灿烂的流星，虽然短暂，却光耀照人。</li>
<li>朱元璋只是历史的执行者，他并不是历史的创造者。即使没有朱元璋，也会有李元璋、王元璋来完成历史的使命，推翻旧的王朝，建立新的帝国。历史是一个好客的主人，但却从不容许客人取代它的位置。历史也从来就不是一个人或者几个人可以支配创造的。所谓时势造英雄，实乃至理名言。真正支配历史的人，不是朱元璋，是稻田里辛勤劳作的老农，是管道上来往的商贾，是朝堂上进言的官员，是孤灯下孤独的学子。他们中大多数人注定默默无闻，都无法在历史上留下他们的名字，但他们才是历史真正的主人。从古至今，从无例外。</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/Game-of-Thrones/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/Game-of-Thrones/" class="post-title-link" itemprop="url">Game of Thrones</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:17:50 / Modified: 18:24:45" itemprop="dateCreated datePublished" datetime="2019-08-03T18:17:50+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/bookread/" itemprop="url" rel="index"><span itemprop="name">bookread</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="Game-of-Thrones"><a href="#Game-of-Thrones" class="headerlink" title="Game of Thrones"></a>Game of Thrones</h2><ol>
<li>If you would take a man’s life, you owe it to him to look into his eyes and hear his final words. And if you cant bear to do that, then perhaps the man does not deserve to die.</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/百年孤独/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/百年孤独/" class="post-title-link" itemprop="url">百年孤独</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:17:38 / Modified: 18:21:04" itemprop="dateCreated datePublished" datetime="2019-08-03T18:17:38+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/bookread/" itemprop="url" rel="index"><span itemprop="name">bookread</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="百年孤独"><a href="#百年孤独" class="headerlink" title="百年孤独"></a>百年孤独</h2><ol>
<li>死神一直追随者他的脚步，嗅闻他的行踪，但尚未下定决心给他最后一击。</li>
<li>“世上正发生着不可思议的事情，”他对乌尔苏拉说，“就在那边，在河的另一边，各种魔法机器应有尽有，而我们却还像驴子一样生活。”</li>
<li>蕾梅黛丝在下午两点令人昏昏欲睡的空气中，蕾梅黛丝在玫瑰无声的呼吸中，蕾梅黛丝在清晨面包的热其中，蕾梅黛丝无所不在，蕾梅黛丝无视或缺。</li>
<li>你那么憎恨军人，跟他们斗了这么久，琢磨了他们这么久，最终却变得和他们一样。人世间没有任何理想值得以这样的沉沦作为代价。</li>
<li>约略懂得幸福的晚年秘诀不过是与孤独签下不失尊严的协定罢了。</li>
<li>过去都是假的，回忆没有归路，春天总是一去不复返，最疯狂执着的爱情也终究是过往云烟。</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/情人/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/情人/" class="post-title-link" itemprop="url">情人</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:17:30 / Modified: 18:21:29" itemprop="dateCreated datePublished" datetime="2019-08-03T18:17:30+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/bookread/" itemprop="url" rel="index"><span itemprop="name">bookread</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="情人"><a href="#情人" class="headerlink" title="情人"></a>情人</h2><ol>
<li>一种可以自由地支配时间的快感和一种怎样来支配这段时间的犹豫往往老是搅和在一起。</li>
<li>男人与女人并不是整天厮守在一起才算幸福，男人女人如果没有共同理想，各自没有独立的能力，很难保持男女间的关系至始至终。</li>
<li>不管怎么爱着这个男人，也不想失去自己一个人时的清静，自己 有属于自己的时间，这是最重要的。</li>
<li>但是人会喜欢上一个人也不是瞎说，世界上就是有着这种不合道理的道理，这要靠每个人的良知与道德修养来做出评判。</li>
<li>我可不是你想象的那样漂亮美丽、心地善良的女人呦。我有人们所具有的假面，在你看到的这假面背后，傲慢、猥琐、任性等等的毛病，我是应有尽有的呢。</li>
<li>男人与女人之间就应该有这么一面不能捅破的隔墙，才能使两人之间的关系保持长久的新鲜感。</li>
<li>也许有人会感到这种关系不太近人情。但是格子生活的全部都相互缠在一起，人生特有的趣味便会淡漠无存。</li>
<li>“请与我结婚吧”这句话，对女人来说都是梦寐以求的，不管她喜不喜欢这个男人。这句话，是绝对能将女人的心彻彻底底地打动地。</li>
<li>情人的地位确实不稳定，但同时却代表着美丽的存在。</li>
<li>忘记日常生活的琐碎杂事，相互体贴，相互慰藉。难得的见面，使双方都将自己的美德表现出来。生日呀，两人初恋的日子呀，每一个有意义的日子，两人都一起过，那样的时刻便是最珍贵，最幸福的。</li>
<li>有不少女人是只愿当情人，不愿做妻子的，这种情人的爱情，不是一生一世，而是一时一刻的。这样才更适合自己，能更自由自在，更能展示自己的魅力。为此而忌讳那种结婚名分的女人并不为少。</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/小王子/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/小王子/" class="post-title-link" itemprop="url">小王子</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:17:20 / Modified: 18:22:38" itemprop="dateCreated datePublished" datetime="2019-08-03T18:17:20+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/bookread/" itemprop="url" rel="index"><span itemprop="name">bookread</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="小王子"><a href="#小王子" class="headerlink" title="小王子"></a>小王子</h2><ol>
<li>如果有一个人爱上在这亿万颗星星中仅有的一朵花，这人望着星空的时候，就会觉得幸福。</li>
<li>审判自己，比审判别人难得多。你若是能够公正地审判自己，那你就是一个真正地贤士。</li>
<li>在我看来，你只不过是一个小男孩，跟成千上万地男孩毫无两样。我不需要你，你也不需要我。对你来说我只不过是一只狐狸，跟成千上万的狐狸毫无两样。但是，你如果驯养了我，那么我们俩就彼此相互需要。对我来说，你是世界上独一无二的；我在你看来，也是世界上独一无二的……</li>
<li>只有用心看，才能看的清楚；本质的东西，眼睛是看不见的。</li>
<li>正是因为你为你的玫瑰，花费了时间，才使你的花儿变得那么重要。</li>
<li>对你驯养的东西，你要永远负责。你必须对你的玫瑰花负责……</li>
<li>“沙漠美丽”，小王子说，“是因为在某个地方藏着一口水井……”</li>
<li>无论是房子、星星或沙漠，使它们美丽的东西是看不见的。</li>
<li>这水，不只是一种饮料，它是从披星戴月地长途跋涉、轱辘的歌声、我的双臂的力量产生出来的。这水，像是一份礼物，使心田得到慰藉。在我小的时候，只有圣诞树的光、子夜弥撒的音乐、甜蜜的微笑，这一切才使得我的圣诞礼物光芒四射。</li>
<li>眼睛是什么也看不见的。应该用心灵去找。</li>
<li>你倘若爱上一朵生长在星星上的花，那么，在夜间，你看看天空就会感到愉快。所有的星星都像盛开的鲜花。</li>
<li>“每个人都有星星，“小王子说，”但在不同的人眼里就是不一样。对旅行者，星星是指引路的。对另一些人，星星只是一些小亮光。对学者，星星是探讨的问题。对我的那个商人，星星是黄金。但是，所有的星星都是一声不响的。你有的那些星星，是别人得不到的！“</li>
<li>”你夜间仰望星空时，由于我就住在其中的一颗星星上，由于我在其中的一颗星上笑，那么，对你来说，所有的星星仿佛都在笑。唯有你，有一些会笑的星星。“</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/无人生还/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/无人生还/" class="post-title-link" itemprop="url">无人生还</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:16:42 / Modified: 18:22:30" itemprop="dateCreated datePublished" datetime="2019-08-03T18:16:42+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/bookread/" itemprop="url" rel="index"><span itemprop="name">bookread</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="无人生还"><a href="#无人生还" class="headerlink" title="无人生还"></a>无人生还</h2><ol>
<li>直到现在我才明白，艺术家永远不会只满足于创造艺术。他渴望自己的艺术得到世人的青睐，是人性使然。</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2019/08/03/解忧杂货店/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/03/解忧杂货店/" class="post-title-link" itemprop="url">解忧杂货店</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-03 18:16:30 / Modified: 18:21:17" itemprop="dateCreated datePublished" datetime="2019-08-03T18:16:30+08:00">2019-08-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/bookread/" itemprop="url" rel="index"><span itemprop="name">bookread</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="解忧杂货店"><a href="#解忧杂货店" class="headerlink" title="解忧杂货店"></a>解忧杂货店</h2><ol>
<li>他们内心都破了个洞，重要的东西正从那个破洞中流失。人的心声是绝对不能无视的。</li>
<li>很多时候，咨询的人心里已经有个答案，来咨询只是想确认自己的决定是对的。所以有些人读过回信后，会再次写信过来，大概就是因为回答的内容和他的想法不一样吧。</li>
<li>如果自己不想积极乐观的生活，不管得到什么样的回答都没有用。</li>
<li>虽然至今为止的道路绝非一片坦途，但想到正因为或者才有机会感受到痛楚，我就成功克服了种种困难。</li>
<li>人与人之间请以断绝，并不需要什么具体的理由。就算表面上有，也很可能只是心已经离开的结果，事后才编造出的借口而已。因为倘若心没有离开，当将会导致关系破裂的师太发生时，理应有人努力去挽救。如果没有，说明其实关系早已破裂。</li>
<li>可是换个角度来看，正因为是一张白纸，才可以随心所欲地描绘地图。一切全在你自己。对你来说，一切都是自由的，在你面前是无限的可能。这可是很棒的事呀。我衷心祈祷你可以相信自己，无悔地燃烧自己的人生。</li>
<li>话语教给我们很多，但善恶还是可以自明。话语想要教给我们，人与人生来就不平等。在人间，尊卑有序是永恒的真理，但你也可以不听。</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/logo1.jpg"
      alt="Uyouii">
  <p class="site-author-name" itemprop="name">Uyouii</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/Uyouii" title="GitHub &rarr; https://github.com/Uyouii" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:taiyoudong@gmail.com" title="E-Mail &rarr; mailto:taiyoudong@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Uyouii</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
    
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  <script src="/js/utils.js?v=7.3.0"></script>

  
  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>



  

  <script src="/js/next-boot.js?v=7.3.0"></script>

  

  

  


  

































    


</body>
</html>
