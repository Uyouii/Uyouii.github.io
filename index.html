<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Uyouii&#39;s Blogs">
<meta property="og:url" content="https://uyouii.github.io/index.html">
<meta property="og:site_name" content="Uyouii&#39;s Blogs">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Uyouii&#39;s Blogs">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://uyouii.github.io/"/>





  <title>Uyouii's Blogs</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Uyouii's Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">There are many things need to learn.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/07/05/读书摘要/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/05/读书摘要/" itemprop="url">读书摘要</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-05T16:36:39+08:00">
                2018-07-05
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-07-05T16:40:09+08:00">
                2018-07-05
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bookread/" itemprop="url" rel="index">
                    <span itemprop="name">bookread</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="神们自己"><a href="#神们自己" class="headerlink" title="神们自己"></a>神们自己</h2><ol>
<li><p>历史往往就是由这些讨厌而且毫无目的的冲动推动的。</p>
</li>
<li><p>有人认为，公众希望环境得以保护，人类的存续得以实现，还认为那些为了这类崇高目标而奋斗的理想主义者会得到公众的爱戴，这种想法都是错的。实际上，公众所期望的只有一件事：他们自己过上安逸舒适的生活。通过二十世纪的环境危机，我们早就看明白了。当人们知道吸烟会导致患癌症的几率上升而最有效的解决办法就是禁烟时，他们却希望能够发明一种不致癌的香烟。当人们知道内燃机会对大气造成污染而最好的办法就是不再使用这类引擎时，他们却希望能够发明不污染空气的引擎。</p>
</li>
<li><p>“他们只需要拒绝相信就行。面对难题，最容易的对策就是拒绝相信它的存在。”</p>
</li>
<li><p>凡是对自己有一点利益就会选择相信。有时候即使毫无可能，人们也会顽冥不化。</p>
</li>
</ol>
<h2 id="人间失格"><a href="#人间失格" class="headerlink" title="人间失格"></a>人间失格</h2><ol>
<li><p>那是我对人类最后的求爱。我对人类极度恐惧，却无论如何也无法对人类死心。</p>
</li>
<li><p>旁人承受的痛苦的性质和大小，我完全捉摸不透。现实生活中的痛苦，只是吃个饭就能化解的痛苦，或许才是莫大的痛苦。也许，我刚才所说的那十个灾祸在这些痛苦面前不值一提。也许那些我无法理解的痛苦才是凄惨的阿鼻地狱。果真如此嘛？我不知道。但即使如此，那些人依然不想轻生、不会发狂，纵谈政治、毫不绝望、毫不屈服，继续与生活作战。他们不觉得痛苦吗？他们变得自私自利，甚至视其为理所当然，难道他们从未怀疑过自己？若真如此，那真是快活。不是每个人都是如此吧？真的都满足于此吗？我不知道······在夜里酣然入睡，一早醒来就会神清气爽吗？他们做了怎样的梦？走路时想些什么？想着钱的事情？不会仅此而已吧？我似乎听过说“民以食为天”，却从未听过“人为钱而活”。不，也许因人而异吧······我还是搞不懂······思绪渐感困惑之时，我越发惶恐不安，仿佛自己是这个世界上的异类。我与旁人几乎无法交谈，因我不知该谈些什么，也不知该如何谈起。</p>
</li>
<li><p>因此我总是黯然接收外界打击，内心却承受着疯狂的恐惧。</p>
</li>
<li><p>受人责备或怒斥时，或许没有人能保持好心情。但我在人们怒不可遏的脸上，看到了比狮子、鳄鱼、巨龙更加可怕的动物本性。寻常时候，他们似乎会将这一本性刻意隐藏，但一有机会，人类可怕的真面目就会在愤怒中不经意的暴露出来。就像在草地上安稳打盹的牛，冷不防甩尾吗“啪”地打死肚子上地牛虻。每每见到人类露出本性，我都惊悚得汗毛倒竖。而一旦想到，这种本性或许是人活于世的必备资质之一，我简直要对自己绝望了。</p>
</li>
<li><p>对讨厌的事物说不出讨厌，对喜欢的事也总是偷偷摸摸，我总是品着极为苦涩的滋味，困难以名状的恐惧痛苦挣扎。</p>
</li>
<li><p>我一向对“向人诉苦”不抱任何期待。无论是向父母说，还是向警察或者政府说，最终还是会被那些深谙处世之道的人打败，任由他们花言巧语，喋喋不休。</p>
</li>
<li><p>相互欺骗的双方竟然都相安无事，甚至未曾察觉相互欺骗之事————我以为，人类生活中无处不是这样单纯、明了的不信任之举。</p>
</li>
<li><p>对人类极度恐惧的人，反而会比任何人都渴望亲眼见识妖怪的可怕。愈是敏感、愈是胆怯，愈会企盼暴风雨降临的更加猛烈。</p>
</li>
<li><p>对我而言，廷煜仁就自己的身世说上千言万语，也不及一句低喃让我心生共鸣。我是如此期盼听到这句低语，然而我在这世上遇到的女子，竟没有一人向我如此诉说，我深感不可思议。眼前这名女子，虽然没有用言语变现自己的寂寞，但整个身体的轮廓却无声地吐露出巨大地寂寞气息。她的身旁仿佛充斥着约莫一寸见方的气流，走近她身旁，我的身体也被那气流说包裹。这气流与我自身携带的阴郁气流完美的融合，如贴在水底岩石上的枯叶一般，是我得以从恐惧与不安中抽离。</p>
</li>
<li><p>胆小鬼连幸福都会害怕，碰到棉花都会受伤，有时还会被幸福所伤。</p>
</li>
<li></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/07/05/python为什么是伪多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/05/python为什么是伪多线程/" itemprop="url">python为什么是伪多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-05T16:35:01+08:00">
                2018-07-05
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-07-05T16:36:16+08:00">
                2018-07-05
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/learning-python/" itemprop="url" rel="index">
                    <span itemprop="name">learning python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="python为什么是为多线程"><a href="#python为什么是为多线程" class="headerlink" title="python为什么是为多线程"></a>python为什么是为多线程</h1><p>Python由于有全锁局的存在（同一时间只能有一个线程执行），并不能利用多核优势。所以，如果你的多线程进程是CPU密集型的，那多线程并不能带来效率上的提升，相反还可能会因为线程的频繁切换，导致效率下降；如果是IO密集型，多线程进程可以利用IO阻塞等待时的空闲时间执行其他线程，提升效率。</p>
<p>来源： <a href="https://www.zhihu.com/question/22191088/answer/20576021" target="_blank" rel="noopener">https://www.zhihu.com/question/22191088/answer/20576021</a></p>
<h1 id="GIL-全局解释器锁"><a href="#GIL-全局解释器锁" class="headerlink" title="GIL 全局解释器锁"></a>GIL 全局解释器锁</h1><p>GIL：<strong>Global Interpreter Lock</strong> </p>
<p>Python代码的执行是由Python虚拟机（又名解释器主循环）控制的。Python在设计时是这样考虑的，在主循环中同时只能有一个控制线程在执行，尽管Python解释器可以同时运行多个线程，但是在任意给定时刻只有一个线程会被解释器执行。</p>
<p>对Python虚拟机的访问是由全局解释器锁（GIL）控制的。这个锁就是用来保证同时只能有一个线程运行的。在多线程环境中，Python虚拟机将按照下面所述的方式执行：</p>
<ol>
<li>设置GIL</li>
<li>切换进一个线程去运行</li>
<li>执行下面操作之一<ol>
<li>指定数量的字节码指令</li>
<li>线程主动让出控制权（可以调用time.sleep(0)来完成）</li>
</ol>
</li>
<li>把线程设置回睡眠状态（切换出线程）</li>
<li>解锁GIL</li>
<li>重复上述步骤</li>
</ol>
<p>当调用外部代码（即，任意C/C++扩展的内置函数）时，GIL会保持锁定，直至函数执行结束（因为在这期间没有Python字节码计数）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/05/14/ENet 源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/14/ENet 源码分析/" itemprop="url">ENet 源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-14T17:23:00+08:00">
                2018-05-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-05-14T17:33:58+08:00">
                2018-05-14
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/network/" itemprop="url" rel="index">
                    <span itemprop="name">network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://enet.bespin.org/index.html" target="_blank" rel="noopener">ENet官方文档地址</a></p>
<p>首先看一下ENet官方给出的ENet的特性(Feature)。</p>
<h1 id="ENet-特性"><a href="#ENet-特性" class="headerlink" title="ENet 特性"></a>ENet 特性</h1><p>ENet是一个具有TCP和UDP各自优点的基于UDP封装的一个网络库。</p>
<p>UDP缺少排序，连接管理，带宽管理，包大小限制等。TCP不能同时打开多个套接字故缺少多流的通信，并且由于其缓冲特性，其包管理机制过于复杂。</p>
<p>ENet则致力于将TCP和UDP的优点结合实现一个统一的网络协议库。</p>
<h2 id="连接管理-Connection-Management"><a href="#连接管理-Connection-Management" class="headerlink" title="连接管理 (Connection Management)"></a>连接管理 (Connection Management)</h2><p>ENet提供了一个简单的与外部主机通信的接口。连接的生命周期通过频繁的ping外部主机动态监管，同时通过主机与外部机器的包的往返时间和丢包情况来监管网络状况。</p>
<h2 id="排序-Sequencing"><a href="#排序-Sequencing" class="headerlink" title="排序 (Sequencing)"></a>排序 (Sequencing)</h2><p>ENet提供了多个的合理排序的网络包流而不是一个单一的比特流从而简化了不同类型数据的传输。</p>
<p>ENet通过为每个发送的网络包编号来实现对包的排序。这些序号会随着包的发送而增长。ENet保证序列号低的包优先发送，从而确保了所有的网络包都按次序发送。</p>
<p>对于不可靠的网络包，如果具有高序号的网络包已经到达，ENet则会简单的丢弃那些低序号的网络包。这样就保证了网络包到达后就可以立即被接收，从而减少了网络延时。对于可靠的网络包，如果一个高序号的包已经到达，但是之前的包确没有到达，ENet会推迟高序号包的接受直到其之前相应序号的网络包均已到达。</p>
<h2 id="通道-Channels"><a href="#通道-Channels" class="headerlink" title="通道 (Channels)"></a>通道 (Channels)</h2><p>既然ENet会推迟可靠网络包的提交来确保网络包的序号，但是无论到达的包是可靠的还是不可靠的，如果之前的网络包是可靠的包，他们都要被推迟提交，这样做可能会造成一些不需要严格保证次序的包同样被推迟提交，从而造成额外的延时。</p>
<p>为了解决上述问题并减少对包的次序的限制，ENet为一个连接提供了多个交流的通道(channel)。每个通道下的网络包可以独立排序，所以一个通道下的包的传送状态不会影响其他通道下的包的传送。</p>
<h2 id="可靠性-Reliability"><a href="#可靠性-Reliability" class="headerlink" title="可靠性 (Reliability)"></a>可靠性 (Reliability)</h2><p>ENet为传送的包提供了可靠性选择，并确保外部主机会确认收到所有的可靠的网络包。如果外部主机在特定时间内没有确认收到网络包，ENet会尝试在合理的次数内重传这个网络包。 重传超时的时间会根据失败次数的增加变得更加宽松便于应对网络临时的混乱和拥塞。</p>
<h2 id="拆分和重组-Fragmentation-and-Reassembly"><a href="#拆分和重组-Fragmentation-and-Reassembly" class="headerlink" title="拆分和重组 (Fragmentation and Reassembly)"></a>拆分和重组 (Fragmentation and Reassembly)</h2><p>ENet在发送包的时候不会考虑包的大小。大的网络包会被分成若干个大小合适的网络包，并在外部机器上重组为发送前的网络包便于远程机器接收。整个过程对于开发者来说都是透明的。</p>
<h2 id="聚合-Aggregation"><a href="#聚合-Aggregation" class="headerlink" title="聚合 (Aggregation)"></a>聚合 (Aggregation)</h2><p>ENet包括了大部分协议指令，包括acknowledgement，packet transfer，确保连接的可用性，减少丢包的机会及其可能造成的延时等。</p>
<h2 id="适应性-Adaptability"><a href="#适应性-Adaptability" class="headerlink" title="适应性 (Adaptability)"></a>适应性 (Adaptability)</h2><p>ENet为可靠包提供了一个动态适应的数据窗口以确保连接不会大量的网络包淹没掉。它也提供了一个静态的带宽分配机制以确保机器在发送和接受包时不会超过这个机器承载的范围。更近一步，ENet提供了一个动态的阀门来响应网络连接时带来的偏差，通过限制发送发送包的数量来应对各种类型的网络拥塞问题。</p>
<h1 id="ENet数据结构"><a href="#ENet数据结构" class="headerlink" title="ENet数据结构"></a>ENet数据结构</h1><h2 id="ENetHost"><a href="#ENetHost" class="headerlink" title="ENetHost"></a>ENetHost</h2><p>ENetHost即ENet的客户端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetHost</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetSocket           socket;</span><br><span class="line">   ENetAddress          address;                    </span><br><span class="line">   enet_uint32          incomingBandwidth;          </span><br><span class="line">   enet_uint32          outgoingBandwidth;          </span><br><span class="line">   enet_uint32          bandwidthThrottleEpoch;</span><br><span class="line">   enet_uint32          mtu;</span><br><span class="line">   enet_uint32          randomSeed;</span><br><span class="line">   <span class="keyword">int</span>                  recalculateBandwidthLimits;</span><br><span class="line">   ENetPeer *           peers;                      </span><br><span class="line">   <span class="keyword">size_t</span>               peerCount;                   </span><br><span class="line">   <span class="keyword">size_t</span>               channelLimit;                </span><br><span class="line">   enet_uint32          serviceTime;</span><br><span class="line">   ENetList             dispatchQueue;</span><br><span class="line">   <span class="keyword">int</span>                  continueSending;</span><br><span class="line">   <span class="keyword">size_t</span>               packetSize;</span><br><span class="line">   enet_uint16          headerFlags;</span><br><span class="line">   ENetProtocol         commands [ENET_PROTOCOL_MAXIMUM_PACKET_COMMANDS];</span><br><span class="line">   <span class="keyword">size_t</span>               commandCount;</span><br><span class="line">   ENetBuffer           buffers [ENET_BUFFER_MAXIMUM];</span><br><span class="line">   <span class="keyword">size_t</span>               bufferCount;</span><br><span class="line">   ENetChecksumCallback checksum;                    </span><br><span class="line">   ENetCompressor       compressor;</span><br><span class="line">   enet_uint8           packetData [<span class="number">2</span>][ENET_PROTOCOL_MAXIMUM_MTU];</span><br><span class="line">   ENetAddress          receivedAddress;</span><br><span class="line">   enet_uint8 *         receivedData;</span><br><span class="line">   <span class="keyword">size_t</span>               receivedDataLength;</span><br><span class="line">   enet_uint32          totalSentData;               </span><br><span class="line">   enet_uint32          totalSentPackets;            </span><br><span class="line">   enet_uint32          totalReceivedData;           </span><br><span class="line">   ENetInterceptCallback intercept;                  </span><br><span class="line">   <span class="keyword">size_t</span>               connectedPeers;</span><br><span class="line">   <span class="keyword">size_t</span>               bandwidthLimitedPeers;</span><br><span class="line">   <span class="keyword">size_t</span>               duplicatePeers;              </span><br><span class="line">   <span class="keyword">size_t</span>               maximumPacketSize;           </span><br><span class="line">   <span class="keyword">size_t</span>               maximumWaitingData;          </span><br><span class="line">&#125; ENetHost;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">内部变量</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>socket</strong></td>
<td style="text-align:left">用于数据传输和连接的UDP套接字句柄</td>
</tr>
<tr>
<td style="text-align:left"><strong>address</strong></td>
<td style="text-align:left">host的socket地址</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingBandwidth</strong></td>
<td style="text-align:left">host接收数据的带宽，即download bandwidth</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingBandwidth</strong></td>
<td style="text-align:left">host上传数据的带宽，即upstream bandwidth</td>
</tr>
<tr>
<td style="text-align:left"><strong>bandwidthThrottleEpoch</strong></td>
<td style="text-align:left">记录host流量控制的时间戳，如果流量控制的时间间隔超过<code>bandwidthThrottleEpoch</code>，则进行流量控制。host流量控制时间间隔设置为1000ms。</td>
</tr>
<tr>
<td style="text-align:left"><strong>mtu</strong></td>
<td style="text-align:left">即最大传输单元，当需要发送的单个packet的大小超过该值时会进行分片操作</td>
</tr>
<tr>
<td style="text-align:left"><strong>randomSeed</strong></td>
<td style="text-align:left">用于生成connectID的随机数种子</td>
</tr>
<tr>
<td style="text-align:left"><strong>recalculateBandwidthLimits</strong></td>
<td style="text-align:left">用于记录是否需要重新计算带宽的标记变量，当有peer连接或者断开连接时会被置为1</td>
</tr>
<tr>
<td style="text-align:left"><strong>peers</strong></td>
<td style="text-align:left">host中用于储存peer的数组，在host初始化时设置，大小为<code>peerCount</code>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>peerCount</strong></td>
<td style="text-align:left">创建host时指定的peerCount，即最大的peer数。如果此时的peer数为<code>peerCount</code>，则在发起连接或者被动连接（收到connect command）时会失败，没有空间容纳新的peer。</td>
</tr>
<tr>
<td style="text-align:left"><strong>channelLimit</strong></td>
<td style="text-align:left">每个peer中可以容纳的channel数，最大为255，最小为1。</td>
</tr>
<tr>
<td style="text-align:left"><strong>serviceTime</strong></td>
<td style="text-align:left">标记host当前时间的时间戳</td>
</tr>
<tr>
<td style="text-align:left"><strong>dispatchQueue</strong></td>
<td style="text-align:left">待处理的peer队列。当peer中有event产生时，则将peer放入dispatchQueue中。</td>
</tr>
<tr>
<td style="text-align:left"><strong>continueSending</strong></td>
<td style="text-align:left">用于标记peer中的数据是否发送完的变量。在发送peer中的数据时为保证公平性，则对peer进行轮询发送，每次至多发送一个数据量小于mtu udp数据报，如果peer中数据没有发送完，则将该变量置为1，在下次循环继续发送。</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetSize</strong></td>
<td style="text-align:left">用于标记当前待发送的udp数据报中数据的大小，在添加数据前如果<code>packetSize</code>大小大于mtu，则将<code>continueSending</code>置为1，跳出循环，将当前数据发送出去，等待下次循环中发送剩余数据。</td>
</tr>
<tr>
<td style="text-align:left"><strong>headerFlags</strong></td>
<td style="text-align:left">标记发送特性的一些flag，例如是否发送当前时间，是否需要压缩等。<code>host-&gt;headerFlags</code>会携带到发送数据报的头部中发送到peer端。</td>
</tr>
<tr>
<td style="text-align:left"><strong>commands</strong></td>
<td style="text-align:left">用于储存当前待发送udp数据报中的command</td>
</tr>
<tr>
<td style="text-align:left"><strong>commandCount</strong></td>
<td style="text-align:left">记录当前待发送udp数据报中的command的数量，如果需要发送的command的数量大于<code>ENET_PROTOCOL_MAXIMUM_PACKET_COMMANDS</code>，则将当前数据报发送出去，剩余数据等待下次循环发送。</td>
</tr>
<tr>
<td style="text-align:left"><strong>buffers</strong></td>
<td style="text-align:left">储存需要发送数据的buffer，用于传递给socket接口发送数据</td>
</tr>
<tr>
<td style="text-align:left"><strong>bufferCount</strong></td>
<td style="text-align:left">记录buffers中buffer的个数，同样传递给相应socke接口用于数据发送。最大值为<code>ENET_BUFFER_MAXIMUM</code>，如果buffers中buffer的个数大于该值，则先将当前数据报发送出去，剩余数据等待下次循环发送。</td>
</tr>
<tr>
<td style="text-align:left"><strong>checksum</strong></td>
<td style="text-align:left">计算校验和的回调函数，需要用户自己设置</td>
</tr>
<tr>
<td style="text-align:left"><strong>compressor</strong></td>
<td style="text-align:left">用于压缩和解压的结构变量，需要用户自己设置</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetData</strong></td>
<td style="text-align:left">一个二维数组，其中packetData[0]用于储存接收的数据，packetData[1]用于储存压缩后待发送的数据</td>
</tr>
<tr>
<td style="text-align:left"><strong>receivedAddress</strong></td>
<td style="text-align:left">接收数据的socket地址，host和port都设为0则意味接收任意地址的数据</td>
</tr>
<tr>
<td style="text-align:left"><strong>receivedData</strong></td>
<td style="text-align:left">用于标记当前读取到packetData[0]中位置的指针</td>
</tr>
<tr>
<td style="text-align:left"><strong>receivedDataLength</strong></td>
<td style="text-align:left">当前接收的数据的长度</td>
</tr>
<tr>
<td style="text-align:left"><strong>totalSentData</strong></td>
<td style="text-align:left">host发送出的总的数据量</td>
</tr>
<tr>
<td style="text-align:left"><strong>totalSentPackets</strong></td>
<td style="text-align:left">host发送出的总的udp数据报数</td>
</tr>
<tr>
<td style="text-align:left"><strong>totalReceivedData</strong></td>
<td style="text-align:left">host接收的总的数据量</td>
</tr>
<tr>
<td style="text-align:left"><strong>totalReceivedPackets</strong></td>
<td style="text-align:left">host接收的总的udp数据报数</td>
</tr>
<tr>
<td style="text-align:left"><strong>connectedPeers</strong></td>
<td style="text-align:left">当前连接的peer的数量</td>
</tr>
<tr>
<td style="text-align:left"><strong>bandwidthLimitedPeers</strong></td>
<td style="text-align:left">需要进行流量控制的peer的数量</td>
</tr>
<tr>
<td style="text-align:left"><strong>duplicatePeers</strong></td>
<td style="text-align:left">允许重复的ip的最大的peer的数量，默认值为<code>ENET_PROTOCOL_MAXIMUM_PEER_ID</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>maximumPacketSize</strong></td>
<td style="text-align:left">允许一个单个的<code>ENetPacket</code>发送和接收的最大的数据量</td>
</tr>
<tr>
<td style="text-align:left"><strong>maximumWaitingData</strong></td>
<td style="text-align:left">允许等待在buffer中的最大的数据量</td>
</tr>
</tbody>
</table>
<h2 id="ENetPeer"><a href="#ENetPeer" class="headerlink" title="ENetPeer"></a>ENetPeer</h2><p>用于储存通信对端的信息的数据结构，同时控制数据的发送，重传等操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetPeer</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">   ENetListNode  dispatchList;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">ENetHost</span> * <span class="title">host</span>;</span></span><br><span class="line">   enet_uint16   outgoingPeerID;</span><br><span class="line">   enet_uint16   incomingPeerID;</span><br><span class="line">   enet_uint32   connectID;</span><br><span class="line">   enet_uint8    outgoingSessionID;</span><br><span class="line">   enet_uint8    incomingSessionID;</span><br><span class="line">   ENetAddress   address;           </span><br><span class="line">   <span class="keyword">void</span> *        data;               </span><br><span class="line">   ENetPeerState state;</span><br><span class="line">   ENetChannel * channels;</span><br><span class="line">   <span class="keyword">size_t</span>        channelCount;       </span><br><span class="line">   enet_uint32   incomingBandwidth;  </span><br><span class="line">   enet_uint32   outgoingBandwidth;  </span><br><span class="line">   enet_uint32   incomingBandwidthThrottleEpoch;</span><br><span class="line">   enet_uint32   outgoingBandwidthThrottleEpoch;</span><br><span class="line">   enet_uint32   incomingDataTotal;</span><br><span class="line">   enet_uint32   outgoingDataTotal;</span><br><span class="line">   enet_uint32   lastSendTime;</span><br><span class="line">   enet_uint32   lastReceiveTime;</span><br><span class="line">   enet_uint32   nextTimeout;</span><br><span class="line">   enet_uint32   earliestTimeout;</span><br><span class="line">   enet_uint32   packetLossEpoch;</span><br><span class="line">   enet_uint32   packetsSent;</span><br><span class="line">   enet_uint32   packetsLost;</span><br><span class="line">   enet_uint32   packetLoss;         </span><br><span class="line">   enet_uint32   packetLossVariance;</span><br><span class="line">   enet_uint32   packetThrottle;</span><br><span class="line">   enet_uint32   packetThrottleLimit;</span><br><span class="line">   enet_uint32   packetThrottleCounter;</span><br><span class="line">   enet_uint32   packetThrottleEpoch;</span><br><span class="line">   enet_uint32   packetThrottleAcceleration;</span><br><span class="line">   enet_uint32   packetThrottleDeceleration;</span><br><span class="line">   enet_uint32   packetThrottleInterval;</span><br><span class="line">   enet_uint32   pingInterval;</span><br><span class="line">   enet_uint32   timeoutLimit;</span><br><span class="line">   enet_uint32   timeoutMinimum;</span><br><span class="line">   enet_uint32   timeoutMaximum;</span><br><span class="line">   enet_uint32   lastRoundTripTime;</span><br><span class="line">   enet_uint32   lowestRoundTripTime;</span><br><span class="line">   enet_uint32   lastRoundTripTimeVariance;</span><br><span class="line">   enet_uint32   highestRoundTripTimeVariance;</span><br><span class="line">   enet_uint32   roundTripTime;           </span><br><span class="line">   enet_uint32   roundTripTimeVariance;</span><br><span class="line">   enet_uint32   mtu;</span><br><span class="line">   enet_uint32   windowSize;</span><br><span class="line">   enet_uint32   reliableDataInTransit;</span><br><span class="line">   enet_uint16   outgoingReliableSequenceNumber;</span><br><span class="line">   ENetList      acknowledgements;</span><br><span class="line">   ENetList      sentReliableCommands;</span><br><span class="line">   ENetList      sentUnreliableCommands;</span><br><span class="line">   ENetList      outgoingReliableCommands;</span><br><span class="line">   ENetList      outgoingUnreliableCommands;</span><br><span class="line">   ENetList      dispatchedCommands;	</span><br><span class="line">   <span class="keyword">int</span>           needsDispatch;</span><br><span class="line">   enet_uint16   incomingUnsequencedGroup;</span><br><span class="line">   enet_uint16   outgoingUnsequencedGroup;</span><br><span class="line">   enet_uint32   unsequencedWindow [ENET_PEER_UNSEQUENCED_WINDOW_SIZE / <span class="number">32</span>]; </span><br><span class="line">   enet_uint32   eventData;</span><br><span class="line">   <span class="keyword">size_t</span>        totalWaitingData;</span><br><span class="line">&#125; ENetPeer;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">内部变量</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>dispatchList</strong></td>
<td style="text-align:left">在host中的<code>dispatchQueue</code>的链表节点。每当该peer产生一个event时，便将peer放入 <code>host-&gt;disptachQueue</code>中</td>
</tr>
<tr>
<td style="text-align:left"><strong>host</strong></td>
<td style="text-align:left">peer所在的host的指针</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingPeerID</strong></td>
<td style="text-align:left">对端<code>host-&gt;peers</code>中的peer的index</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingPeerID</strong></td>
<td style="text-align:left">peer在本地<code>host-&gt;peers</code>中的index</td>
</tr>
<tr>
<td style="text-align:left"><strong>connectID</strong></td>
<td style="text-align:left">在创建host时会生成一个随机数种子，每次请求新的连接时，会将随机数种子递增1产生 connectID。用于匹配收到的 verify connect 是否对应之前connect请求。当需要计算校验和时，connectID也参与校验和的计算。</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingSessionID</strong></td>
<td style="text-align:left">本地用于发送时封装protocol header的会话号，接收端在收到数据报时会将该 sessionid 取出与接收端的<code>peer-&gt;incomingSessionID</code>进行匹配。</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingSessionID</strong></td>
<td style="text-align:left">没到收到一个udp数据报时，会将protocol header中封装的session ID 取出与本地的<code>incomingSessionID</code>匹配，用于判断收到的数据报是否属于本次会话。</td>
</tr>
<tr>
<td style="text-align:left"><strong>address</strong></td>
<td style="text-align:left">该peer的socket地址</td>
</tr>
<tr>
<td style="text-align:left"><strong>state</strong></td>
<td style="text-align:left">peer当前的状态，例如已经连接，断开连接等。</td>
</tr>
<tr>
<td style="text-align:left"><strong>channels</strong></td>
<td style="text-align:left">peer用于发送数据的channel</td>
</tr>
<tr>
<td style="text-align:left"><strong>channelCount</strong></td>
<td style="text-align:left"><code>channels</code>的大小</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingBandwidth</strong></td>
<td style="text-align:left">该peer下载的带宽(字节/秒)</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingBandwidth</strong></td>
<td style="text-align:left">该peer上传的带宽(字节/秒)</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingBandwidthThrottleEpoch</strong></td>
<td style="text-align:left">在调节packetThrottle时用于记录调节该peer下载带宽的时间戳</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingBandwidthThrottleEpoch</strong></td>
<td style="text-align:left">在调节packetThrottle时用于记录调节该peer上传带宽的时间戳</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingDataTotal</strong></td>
<td style="text-align:left">记录在流量控制的间隔时间内从该peer接收的总的数据量的大小</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingDataTotal</strong></td>
<td style="text-align:left">记录在流量控制的间隔时间内向该peer发送的总的数据量的大小</td>
</tr>
<tr>
<td style="text-align:left"><strong>lastSendTime</strong></td>
<td style="text-align:left">记录上次发送数据包的时间戳</td>
</tr>
<tr>
<td style="text-align:left"><strong>lastReceiveTime</strong></td>
<td style="text-align:left">记录上次收到ack的时间，如果超过一定时间没有收到ack，则host会向该peer发送ping包用于判断该peer是否已经断开连接</td>
</tr>
<tr>
<td style="text-align:left"><strong>nextTimeout</strong></td>
<td style="text-align:left">下次有数据包超时的时间戳。在发送command和接收ack时会根据数据包的rto设置peer下次超时的时间戳。如果检测到当前时间戳大于该值，则调用<code>enet_protocol_check_timeouts</code>进行超时检测。</td>
</tr>
<tr>
<td style="text-align:left"><strong>earliestTimeout</strong></td>
<td style="text-align:left">记录当前时间段内的最早的超时时间。每当收到ack时会将<code>earliestTimeout</code>重置为0</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetThrottle</strong></td>
<td style="text-align:left">流量控制的阀门，通过该值进行流量控制，最大值为32，最小为1</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetThrottleLimit</strong></td>
<td style="text-align:left">在进行流量控制时会根据peer设置的带宽计算出该peer的<code>packetThrottle</code>的上限，确保数据的发送不会超过host的发送能力和peer的接收能力。<code>packetThrottle</code>的大小不会超过<code>packetThrottleLimit</code>的大小</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetThrottleCounter</strong></td>
<td style="text-align:left">在发送不可靠包时会根据<code>packekThrottleCounter</code>的值和<code>packetThrottle</code>的值判断是否会在发送前丢掉该不可靠包</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetThrottleEpoch</strong></td>
<td style="text-align:left">记录当前更新<code>lastRoundTripTime</code>,<code>lastRoundTripTimeVariance</code>,<code>lowestRoundTripTime</code>,<code>highestRoundTripTimeVariance</code>的时间戳，每隔<code>packetThrottleInterval</code>的时间间隔会刷新一次</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetThrottleAcceleration</strong></td>
<td style="text-align:left">每当收到rtt时用于增加<code>packetThrottle</code>的增量</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetThrottleDeceleration</strong></td>
<td style="text-align:left">每当收到rtt试用于减少<code>packetThrottle</code>的增量</td>
</tr>
<tr>
<td style="text-align:left"><strong>packetThrottleInterval</strong></td>
<td style="text-align:left">流量控制中相应变量更新周期的大小</td>
</tr>
<tr>
<td style="text-align:left"><strong>pingInterval</strong></td>
<td style="text-align:left">如果超过<code>pingInterval</code>的时间没有收到ack，则向peer发送一个ping包，用于探测是否断开连接</td>
</tr>
<tr>
<td style="text-align:left"><strong>lastRoundTripTime</strong></td>
<td style="text-align:left">记录上个流量控制周期中最小的rtt</td>
</tr>
<tr>
<td style="text-align:left"><strong>lowestRoundTripTime</strong></td>
<td style="text-align:left">记录当前流量控制周期中最小的rtt</td>
</tr>
<tr>
<td style="text-align:left"><strong>lastRoundTripTimeVariance</strong></td>
<td style="text-align:left">记录上个流量控制周期中最大的rtt的变化值</td>
</tr>
<tr>
<td style="text-align:left"><strong>highestRoundTripTimeVariance</strong></td>
<td style="text-align:left">记录当前流量控制周期中最大的rtt的变化值</td>
</tr>
<tr>
<td style="text-align:left"><strong>roundTripTime</strong></td>
<td style="text-align:left">该peer当前平滑的rtt</td>
</tr>
<tr>
<td style="text-align:left"><strong>roundTripTimeVariance</strong></td>
<td style="text-align:left">该peer当前平滑的rtt的变化值</td>
</tr>
<tr>
<td style="text-align:left"><strong>mtu</strong></td>
<td style="text-align:left">该peer的最大传输单元，当需要发送的单个packet的大小超过该值时会进行分片操作</td>
</tr>
<tr>
<td style="text-align:left"><strong>reliableDataInTransit</strong></td>
<td style="text-align:left">正在传输过程中的可靠包的大小（已经发送但没有收到ack的），如果其值超过由<code>packetThrottle</code>计算出的发送窗口的大小，则暂停发送</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingReliableSequenceNumber</strong></td>
<td style="text-align:left">由peer发送的ENet的系统指令的当前的包的序号。所谓系统指令指connect，disconnect，ping等指令。而reliable，unreliable数据包会在channel中发送，用的是channel的序号。</td>
</tr>
<tr>
<td style="text-align:left"><strong>acknowledgements</strong></td>
<td style="text-align:left">等待发送ack的队列</td>
</tr>
<tr>
<td style="text-align:left"><strong>sentReliableCommands</strong></td>
<td style="text-align:left">已经发送reliable但是没收到ack的队列</td>
</tr>
<tr>
<td style="text-align:left"><strong>sentUnreliableCommands</strong></td>
<td style="text-align:left">已经发送的unreliable的队列</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingReliableCommands</strong></td>
<td style="text-align:left">等待发送reliable的队列</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingUnreliableCommands</strong></td>
<td style="text-align:left">等待发送unreliable的队列</td>
</tr>
<tr>
<td style="text-align:left"><strong>dispatchedCommands</strong></td>
<td style="text-align:left">已经收到的，等待用户处理的指令队列</td>
</tr>
<tr>
<td style="text-align:left"><strong>needsDispatch</strong></td>
<td style="text-align:left">是否需要用户处理，如果<code>dispatchedCommands</code>队列中有指令，则将该值置为1</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingUnsequencedGroup</strong></td>
<td style="text-align:left">peer记录的当前到来的unsequenced数据包的该group的头部的序号</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingUnsequencedGroup</strong></td>
<td style="text-align:left">发送的unsequenced数据包的序号</td>
</tr>
<tr>
<td style="text-align:left"><strong>unsequencedWindow</strong></td>
<td style="text-align:left">用位图的方式记录当前unsequenced group的数据包有没有重复</td>
</tr>
<tr>
<td style="text-align:left"><strong>totalWaitingData</strong></td>
<td style="text-align:left">ENet已经收到的但是用户还未处理的数据大小的总和</td>
</tr>
</tbody>
</table>
<h3 id="SessionID的作用"><a href="#SessionID的作用" class="headerlink" title="SessionID的作用"></a>SessionID的作用</h3><p>ENet使用简单的SessionID的匹配防止两个具有相同ip地址和端口号的前后两次连接发送的数据发生混淆。（这种情况是在断开连接后如果发起的新的连接的端口号和之前的端口号相同，在连接时会被判定为相同的连接，这时如果之前连接发送的网络包在网络中没有消逝并发送到对端，会与本次的连接发送的数据产生混淆。TCP使主动断开连接的一方处于<code>TIME_WAIT</code>的状态来防止这种情况的发生。）</p>
<p>在每次请求连接时，接收请求连接的一方会更新相应的session并返回给该peer，在第二次握手时请求连接方会同步该Session的数值。在每次发送数据时会将SessionID包含在<code>ENetProtocolHeader.peerID</code>中，接收端在每次收到UDP数据报时会首先检测protocol header中的session ID不匹配，则丢掉该数据报中的数据，表明该数据报不是本次连接中发送的数据。</p>
<p>因为仅仅时简单的ID匹配，所以并不能像TCP那样100%防止两次连接中数据包混淆这种情况的发生，但是大部分情况下仍是有效的。</p>
<h2 id="ENet-Channel"><a href="#ENet-Channel" class="headerlink" title="ENet Channel"></a>ENet Channel</h2><p>每个peer中会有多个Channel用于数据的发送，每个Channel发送和接收数据的过程和对command的编号彼此是独立的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetChannel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   enet_uint16  outgoingReliableSequenceNumber;</span><br><span class="line">   enet_uint16  outgoingUnreliableSequenceNumber;</span><br><span class="line">   enet_uint16  usedReliableWindows;</span><br><span class="line">   enet_uint16  reliableWindows [ENET_PEER_RELIABLE_WINDOWS];</span><br><span class="line">   enet_uint16  incomingReliableSequenceNumber;</span><br><span class="line">   enet_uint16  incomingUnreliableSequenceNumber;</span><br><span class="line">   ENetList     incomingReliableCommands;</span><br><span class="line">   ENetList     incomingUnreliableCommands;</span><br><span class="line">&#125; ENetChannel;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">内部变量</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>outgoingReliableSequenceNumber</strong></td>
<td style="text-align:left">channel中当前发送的可靠包的序号</td>
</tr>
<tr>
<td style="text-align:left"><strong>outgoingUnreliableSequenceNumber</strong></td>
<td style="text-align:left">channel中当前发送的不可靠包的序号</td>
</tr>
<tr>
<td style="text-align:left"><strong>usedReliableWindows</strong></td>
<td style="text-align:left">用位图的方式记录已经使用的发送窗口的序号</td>
</tr>
<tr>
<td style="text-align:left"><strong>reliableWindows</strong></td>
<td style="text-align:left">每个发送窗口中已经发送但是还没有收到ack的指令的个数</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingReliableSequenceNumber</strong></td>
<td style="text-align:left">已经收到的可靠包的序号</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingUnreliableSequenceNumber</strong></td>
<td style="text-align:left">已经收到的不可靠包的序号</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingReliableCommands</strong></td>
<td style="text-align:left">已经收到的reliable数据包，等待有序排序后转到<code>peer-&gt;dispatchedCommands</code>队列中</td>
</tr>
<tr>
<td style="text-align:left"><strong>incomingUnreliableCommands</strong></td>
<td style="text-align:left">已经收到的unreliable的数据包，等待转到<code>peer-&gt;dispatchedCommands</code>队列中</td>
</tr>
</tbody>
</table>
<h3 id="关于reliableWindow"><a href="#关于reliableWindow" class="headerlink" title="关于reliableWindow"></a>关于reliableWindow</h3><p>由于ENet采用的是选择重传的方式，为保证新窗口与老窗口的序号没有重叠，窗口的最大尺寸不应该超过序号空间的一半。ENet在发送新的数据包时会通过<code>usedReliableWindows</code>判断当前窗口占用是否与空闲窗口重叠，如果重叠则暂停数据包的发送。<code>reliableWindows</code>会记录各个窗口中目前在传输中的包的个数。</p>
<h1 id="ENet-协议"><a href="#ENet-协议" class="headerlink" title="ENet 协议"></a>ENet 协议</h1><p>ENet发送数据时以一个udp数据报为单位，在发送时首先会在每个udp数据报的头部包含一个4个字节的<code>protocol header</code>表明当前数据报内的各个command由哪个peer发送和相应的发送时间。 在protocl header后会包含多个command。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                  |&lt;------------ command1 -----------&gt;|&lt;------------ command2 -----------&gt;|  </span><br><span class="line">-------------------------------------------------------------------------------------------------------</span><br><span class="line">| protocol Header | command1 header | command1 data   | command2 header | command2 data   |     ...</span><br><span class="line">-------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h2 id="协议头部-Protocol-Header"><a href="#协议头部-Protocol-Header" class="headerlink" title="协议头部 (Protocol Header)"></a>协议头部 (Protocol Header)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   enet_uint16 peerID;</span><br><span class="line">   enet_uint16 sentTime;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolHeader;</span><br></pre></td></tr></table></figure>
<p>Protocol Header是ENet整个协议的头部，由于ENet底层由UDP封装而成，在发送UDP数据报时该字段会放在整个UDP数据报的头部，用于标记该数据报的peer和发送时间。</p>
<p>与TCP的端对端连接不同，ENet可以是多对多的连接，所以需要<code>peerID</code>字段标记相应的peer。peerID的同步会在三次握手时同步完成。</p>
<blockquote>
<p>protocol header<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|&lt;------------ 4 bytes ------------&gt;|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|      peerID     |     sentTime    | </span><br><span class="line">+--------+--------+--------+--------+ </span><br><span class="line">|&lt;---------protocol header---------&gt;|</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="指令头部-Command-Header"><a href="#指令头部-Command-Header" class="headerlink" title="指令头部(Command Header)"></a>指令头部(Command Header)</h2><p>ENet中共有12种command，其中每个command会有一个相同的4个字节的command heaer，包含command每个command必须的信息：command类型，所在的channelID和该command的序列号。除去command header，每个command剩余的内容根据command类型而不同，所以ENet不同类型的command的大小是不同的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolCommandHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   enet_uint8 command;</span><br><span class="line">   enet_uint8 channelID;</span><br><span class="line">   enet_uint16 reliableSequenceNumber;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolCommandHeader;</span><br></pre></td></tr></table></figure>
<p>在每次发送的UDP的数据报中可能会包含多个指令(Command)，所以由每个指令的头部来标记该指令的信息，包括:</p>
<ul>
<li><strong>command</strong>: 指令类型</li>
<li><strong>channelID</strong>:该command的所在channel的序号</li>
<li><strong>reliableSequenceNumber</strong>:该指令在相应channel的序号</li>
</ul>
<p>每个指令对应固定的格式，所以根据<code>command</code>对应的指令类型，便可以得到该指令对应的长度。</p>
<blockquote>
<p>command header<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|&lt;-------------------- 4 bytes --------------------&gt;|</span><br><span class="line">+------------+------------+------------+------------+</span><br><span class="line">|   command  |  channelID | reliableSequenceNumber  | </span><br><span class="line">+------------+------------+------------+------------+ </span><br><span class="line">|&lt;------------------command header-----------------&gt;|</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="ENet-协议类型"><a href="#ENet-协议类型" class="headerlink" title="ENet 协议类型"></a>ENet 协议类型</h2><p>ENet共有12种协议类型，每种协议类型会对应一个<code>Command Number</code>。</p>
<p>协议类型定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _ENetProtocolCommand</span><br><span class="line">&#123;</span><br><span class="line">   ENET_PROTOCOL_COMMAND_NONE               = <span class="number">0</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_ACKNOWLEDGE        = <span class="number">1</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_CONNECT            = <span class="number">2</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_VERIFY_CONNECT     = <span class="number">3</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_DISCONNECT         = <span class="number">4</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_PING               = <span class="number">5</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_SEND_RELIABLE      = <span class="number">6</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE    = <span class="number">7</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_SEND_FRAGMENT      = <span class="number">8</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_SEND_UNSEQUENCED   = <span class="number">9</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_BANDWIDTH_LIMIT    = <span class="number">10</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_THROTTLE_CONFIGURE = <span class="number">11</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE_FRAGMENT = <span class="number">12</span>,</span><br><span class="line">   ENET_PROTOCOL_COMMAND_COUNT              = <span class="number">13</span>,</span><br><span class="line"></span><br><span class="line">   ENET_PROTOCOL_COMMAND_MASK               = <span class="number">0x0F</span></span><br><span class="line">&#125; ENetProtocolCommand;</span><br></pre></td></tr></table></figure></p>
<p>由于在协议中每个<code>Command Number</code>由一个字节储存，但是总共的协议号不超过16，所以4个bit便足够储存，剩下的4位bit ENet用于标记该Command的一些特性，例如是否需要排序，是否需要发送验证（Ack）等。</p>
<h3 id="Acknowledge指令"><a href="#Acknowledge指令" class="headerlink" title="Acknowledge指令"></a>Acknowledge指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolAcknowledge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint16 receivedReliableSequenceNumber;</span><br><span class="line">   enet_uint16 receivedSentTime;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolAcknowledge;</span><br><span class="line">```                                                                  </span><br><span class="line">Acknowledge是接收确认指令，在收到可靠包后需要向发送端发送Acknowledge指令来表明已经收到了相应的数据包。其中包含了：</span><br><span class="line">- **header**: 相应command的头部</span><br><span class="line">- **receivedReliableSequenceNumber**: 需要返回Ack的相应指令的序号（不是该Acknowledge的序号，而是其对应发送端发送的指令的序号）</span><br><span class="line">- **receivedSentTime**:其对应指令的发送时间，用于计算相应指令的rtt。</span><br><span class="line"></span><br><span class="line">对于每个`CommandHeader`中commnd参数带有`ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE`标记的command，接收端都会向发送端发送Ack指令。如果发送端在相应时间内没有收到Ack，则会重发该command，直到收到Ack。`ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE`的值是`<span class="number">1</span> &lt;&lt; <span class="number">7</span>`,占用commandNumber中空白位来标记该command是否需要重传。</span><br><span class="line"></span><br><span class="line">### Connect指令</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolConnect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint16 outgoingPeerID;</span><br><span class="line">   enet_uint8  incomingSessionID;</span><br><span class="line">   enet_uint8  outgoingSessionID;</span><br><span class="line">   enet_uint32 mtu;</span><br><span class="line">   enet_uint32 windowSize;</span><br><span class="line">   enet_uint32 channelCount;</span><br><span class="line">   enet_uint32 incomingBandwidth;</span><br><span class="line">   enet_uint32 outgoingBandwidth;</span><br><span class="line">   enet_uint32 packetThrottleInterval;</span><br><span class="line">   enet_uint32 packetThrottleAcceleration;</span><br><span class="line">   enet_uint32 packetThrottleDeceleration;</span><br><span class="line">   enet_uint32 connectID;</span><br><span class="line">   enet_uint32 data;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolConnect;</span><br></pre></td></tr></table></figure>
<p>connect指令用于主动发起连接的一端进行主动连接操作，其中包含的参数较多：</p>
<ul>
<li><strong>header</strong>: command的头部</li>
<li><strong>outgoingPeerID</strong>: 对应本地端的<code>ENetPeer.incomingPeerID</code>，后续通信通过该peerID访问<code>host-&gt;peers</code>中的相应的peer。</li>
<li><strong>incomingSessionID</strong>: 对应本地端的<code>ENetPeer.incomingSessionID</code>，本地用于匹配对端发送的Session ID，即每次收到该peer的UDP数据报时会与数据报中的Session ID的值进行匹配。</li>
<li><strong>outgoingSessionID</strong>: 对应本地端的<code>ENetPeer.outgoingSessionID</code>，本地用于发送时封装protocol header的会话号，接收端在收到数据报时会将该sessionid取出与接收端的<code>incomingSessionID</code>进行匹配。</li>
<li><strong>mtu</strong>:即最大传输单元。在发送数据大小大于mtu的packet时，ENet会在本地进行分片，并在接收端进行重组。</li>
<li><strong>windowSize</strong>: ENet发送窗口的大小，控制ENet在传输过程中的可靠包的数据量。每个peer会独立计算windowSize，在发送数据包时如果检测到正在传输的数据</li>
<li><strong>channelCount</strong>:channel的数量</li>
<li><strong>incominBandwidth</strong>: 对应本地的<code>host-&gt;incomingBandwidth</code>，即host的下载带宽。</li>
<li><strong>outgoingBandwidth</strong>: 对应本地的<code>host-&gt;outgoingBandwidth</code>，即host的上传带宽。</li>
<li><strong>packetThrottleInterval</strong>: 通过rtt对<code>packetThrottle</code>调节周期的设置。</li>
<li><strong>packetThrottleAcceleration</strong>：</li>
<li><strong>packetThrottleDeceleration</strong>：</li>
<li><strong>connectID</strong>：防止重复的连接（比如：connect 命令丢掉后重发）</li>
</ul>
<h3 id="Verify-Connet指令"><a href="#Verify-Connet指令" class="headerlink" title="Verify Connet指令"></a>Verify Connet指令</h3><p>verify Connect用于三次握手连接的第二次握手，同时用于主动连接方同步被动连接方的相关信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolVerifyConnect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint16 outgoingPeerID;</span><br><span class="line">   enet_uint8  incomingSessionID;</span><br><span class="line">   enet_uint8  outgoingSessionID;</span><br><span class="line">   enet_uint32 mtu;</span><br><span class="line">   enet_uint32 windowSize;</span><br><span class="line">   enet_uint32 channelCount;</span><br><span class="line">   enet_uint32 incomingBandwidth;</span><br><span class="line">   enet_uint32 outgoingBandwidth;</span><br><span class="line">   enet_uint32 packetThrottleInterval;</span><br><span class="line">   enet_uint32 packetThrottleAcceleration;</span><br><span class="line">   enet_uint32 packetThrottleDeceleration;</span><br><span class="line">   enet_uint32 connectID;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolVerifyConnect;</span><br></pre></td></tr></table></figure>
<p>其中参数基本和connect命令中的参数相同，不一一列举了。</p>
<h3 id="Protocol-Bandwidth-Limit指令"><a href="#Protocol-Bandwidth-Limit指令" class="headerlink" title="Protocol Bandwidth Limit指令"></a>Protocol Bandwidth Limit指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolBandwidthLimit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint32 incomingBandwidth;</span><br><span class="line">   enet_uint32 outgoingBandwidth;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolBandwidthLimit;</span><br></pre></td></tr></table></figure>
<p>Bandwidth Limit指令用于流量控制时调节对端对应本地的peer的带宽的相应的数值。</p>
<ul>
<li><strong>header</strong>: command的头部</li>
<li><strong>incomingBandwidth</strong>: 对应本地端的<code>host-&gt;incomingBandwidth</code>，设置对端的peer对应本地的host的下载带宽的数值。</li>
<li><strong>outgoingBandwidth</strong>: 对应本地端的<code>host-&gt;outgoingBandwidth</code>，设置对端的peer对应本地host的上行带宽的数值。</li>
</ul>
<h3 id="Throttle-Configure-指令"><a href="#Throttle-Configure-指令" class="headerlink" title="Throttle Configure 指令"></a>Throttle Configure 指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolThrottleConfigure</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint32 packetThrottleInterval;</span><br><span class="line">   enet_uint32 packetThrottleAcceleration;</span><br><span class="line">   enet_uint32 packetThrottleDeceleration;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolThrottleConfigure;</span><br></pre></td></tr></table></figure>
<p>Throttle Configure用于调节由rtt控制 packetThrottle的相关设置，关于packetThrottle的作用请看ENet流量控制相关章节。</p>
<ul>
<li><strong>header</strong>: command的头部</li>
<li><strong>packetThrottleInterval</strong>: peer调节rtt相关参数的周期</li>
<li><strong>packetThrottleAcceleration</strong>: 根据rtt调节packetThrottle的增加的速率</li>
<li><strong>packetThrottleDeceleration</strong>： 根据rtt调节packetThrottle的减小的速率</li>
</ul>
<h3 id="Disconnect-指令"><a href="#Disconnect-指令" class="headerlink" title="Disconnect 指令"></a>Disconnect 指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolDisconnect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint32 data;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolDisconnect;</span><br></pre></td></tr></table></figure>
<p>用于断开连接。</p>
<h3 id="Ping指令"><a href="#Ping指令" class="headerlink" title="Ping指令"></a>Ping指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolPing</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolPing;</span><br></pre></td></tr></table></figure>
<p>ENet当检测到超过一定的时间没有收到ack时便会发送ping指令以判断当前相连的peer是否已经断开连接。因为是探测指令，所以只发送指令头即可。</p>
<h3 id="Send-Reliable-指令"><a href="#Send-Reliable-指令" class="headerlink" title="Send Reliable 指令"></a>Send Reliable 指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolSendReliable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint16 dataLength;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolSendReliable;</span><br></pre></td></tr></table></figure>
<p>用于发送不用分片的可靠包的指令，在发送时，相应的data数据会跟在指令的后面。</p>
<ul>
<li><strong>header</strong>: 指令头部</li>
<li><strong>dataLength</strong>: 发送数据的长度</li>
</ul>
<h3 id="Send-Unreliable-指令"><a href="#Send-Unreliable-指令" class="headerlink" title="Send Unreliable 指令"></a>Send Unreliable 指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolSendUnreliable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint16 unreliableSequenceNumber;</span><br><span class="line">   enet_uint16 dataLength;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolSendUnreliable;</span><br></pre></td></tr></table></figure>
<p>发送不需要分片的Unreliable指令，与ENet unrealiable包的实现机制相关，不仅需要携带reliable sequence number，还需要携带unreliable sequence number。</p>
<ul>
<li><strong>unreliableSequeceNumber</strong>: 不可靠包的序号</li>
<li><strong>dataLength</strong>: 发送数据的长度</li>
</ul>
<h3 id="Send-Unsequenced指令"><a href="#Send-Unsequenced指令" class="headerlink" title="Send Unsequenced指令"></a>Send Unsequenced指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolSendUnsequenced</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint16 unsequencedGroup;</span><br><span class="line">   enet_uint16 dataLength;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolSendUnsequenced;</span><br></pre></td></tr></table></figure>
<p>发送不需要分片的Unsequenced指令，与reliable包和unreliable包的实现都不同，unsequenced不会用到header中的reliable sequence number，而是用相应的unsequencedGroup标记相应的序号。</p>
<ul>
<li><strong>unsequencedGroup</strong>: 用于标记unsequenced包的序号</li>
<li><strong>dataLength</strong>: 需要发送的数据的长度</li>
</ul>
<h3 id="Send-Fragment指令"><a href="#Send-Fragment指令" class="headerlink" title="Send Fragment指令"></a>Send Fragment指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENetProtocolSendFragment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ENetProtocolCommandHeader header;</span><br><span class="line">   enet_uint16 startSequenceNumber;</span><br><span class="line">   enet_uint16 dataLength;</span><br><span class="line">   enet_uint32 fragmentCount;</span><br><span class="line">   enet_uint32 fragmentNumber;</span><br><span class="line">   enet_uint32 totalLength;</span><br><span class="line">   enet_uint32 fragmentOffset;</span><br><span class="line">&#125; ENET_PACKED ENetProtocolSendFragment;</span><br></pre></td></tr></table></figure>
<p>fragment用于发送所有需要分片的数据包，通过flag标记相应包的类型，例如reliable和unreliable等。</p>
<ul>
<li><strong>startSequenceNumber</strong>: 被分片的数据包的开始的序号</li>
<li><strong>dataLength</strong>: 该分片携带的数据的长度</li>
<li><strong>fragmentCount</strong>: 总的分片的数量</li>
<li><strong>fragmentNumber</strong>: 该分片在所有分片中的序号，从0开始</li>
<li><strong>totalLength</strong>: 分片前的总的数据长度</li>
<li><strong>fragmentOffset</strong>: 该分片的起始位置在分片前的数据包中的偏移量</li>
</ul>
<h1 id="ENet数据包类型"><a href="#ENet数据包类型" class="headerlink" title="ENet数据包类型"></a>ENet数据包类型</h1><p>ENet中主要的数据包类型有：<strong>Reliable</strong>，<strong>Unreliable</strong>和<strong>Unsequenced</strong>和系统指令。</p>
<p>数据包的类型是通过commandheader中的command的携带的protocolFlag标记的。</p>
<p>由于command有8个字节，而ENet只有13种指令，只需要用到前4个bit，所以剩下的bit可以用来标记相应的数据包的类型，用于标记数据包的类型主要有两个flag：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE = (<span class="number">1</span> &lt;&lt; <span class="number">7</span>),</span><br><span class="line">ENET_PROTOCOL_COMMAND_FLAG_UNSEQUENCED = (<span class="number">1</span> &lt;&lt; <span class="number">6</span>),</span><br></pre></td></tr></table></figure></p>
<p>acknowledge和unsequenced。</p>
<p>如果标记unsequenced，则该数据包对应为unsequence数据包。<br>如果标记acknowledge，则对应reliable数据包，意味着需要对端返回ack指令。<br>如果都没有标记，则对应unreliable数据包。</p>
<p>系统指令一般是reliable的，如果标记了unsequenced，则会当成unsequenced处理，例如diconnectnow功能中的disconnect指令。</p>
<h2 id="系统指令"><a href="#系统指令" class="headerlink" title="系统指令"></a>系统指令</h2><p>系统指令包括有：<code>connect</code>,<code>verifyConnect</code>, <code>disconnect</code>, <code>ping</code>, <code>bandwidthLimit</code>, <code>throttleConfigure</code>。</p>
<p>系统指令所在的Channel是255，即不会占用peer中的任何一个channel。</p>
<p>系统指令一般都是需要对端发送ack的。</p>
<p>并且系统指令的发送不会受流量控制的限制，流量控制只是针对发送数据包的指令有效。</p>
<h2 id="Reliable数据包"><a href="#Reliable数据包" class="headerlink" title="Reliable数据包"></a>Reliable数据包</h2><p>如果相应命令标记了acknowledge，则会要求接收方收到后返回ack指令，如果没有收到ack，则会对数据包进行重传。如果重传次数超过一定的限制，则对该peer进行断开连接。</p>
<p>如果命令标记acknowledge的命令是<code>ENetProtocolSendReliable</code>和<code>ENetProtocolSendFragment</code>类型，接收方还会对指令进行排序。</p>
<p>对于<code>ENetProtocolSendReliable</code>则会对数据包进行排序，之后收到连续有序的数据包才会dispatch给用户。如果序号较大的数据包已经到达，而之前的数据包没有到达，ENet则会等待之前的数据包都到达以后，才会将相应的数据包发给用户。</p>
<p>对于<code>ENetProtocolSendFragment</code>类型的指令，接收方只有当分片中所有的数据包都收到后才会将数据dispatch给用户，如果有任何一个没有收到，则会等待至所有数据包都收到后。</p>
<p>reliable数据包的流量控制通过packetThrottle计算发送窗口大小实现，如果发现已经在传输中的reliable数据的量超过发送窗口大小，则会暂停对reliable数据包的传输，直到有空闲的发送窗口大小。</p>
<h2 id="Unreliable-数据包"><a href="#Unreliable-数据包" class="headerlink" title="Unreliable 数据包"></a>Unreliable 数据包</h2><p>对于Unreliable数据包，不会要求对端返回ack指令，同样会对数据包进行排序，但是与reliable数据包不同的是，如果后续的数据包已经到达，而之前的数据包则没有收到，则直接会将已经收到的数据包dispatch给用户，如果之前的数据包再次到达的话，则会直接丢弃。</p>
<p>并且Unreliable数据包的编号需要依赖reliable 序号，每次发送reliable数据包时，都会将unreliable数据包的编号重置为0开始传输。每个unreliable数据包会携带当前channel的reliable序号和unreliable序号。如果后续的reliable序号已经到达，则当前unreliable会被丢弃，如果后续的unreliable包到达，则当前unreliable序号同样会丢弃。</p>
<p>同时需要注意的一个细节是，ENet的每个数据包的sequence number的大小只有16位，也就是说最大序号只有65535，如果需要overflow的话，会从0开始重新统计。reliable包在进行接收的时候会判断当前的序号有没有已经overflow，但是对unreliable包确没有进行这种判断。</p>
<p>对于fragment的unreliable数据包，同样会等待所有分片都到达后才会将该数据包dispatch给用户，如果在处理分片的过程中，有该所有分片的后续序号的数据包到达，该分片中所有的数据包也会被丢弃。</p>
<p>unreliable数据包在进行流量控制的时候是通过packetThrottle计算一个数值在发送前进行概率性的随机丢弃的。如果packetThrottle是最大值，则不会丢弃，如果packetThrottle的值越小，则被丢弃的可能性越大。</p>
<h2 id="Unsequenced数据包"><a href="#Unsequenced数据包" class="headerlink" title="Unsequenced数据包"></a>Unsequenced数据包</h2><p>Unsequenced数据包同样是不会要求返回ack命令的，与unreliable不同的是，它不会依赖于reliable序号，也不会排序，对端只要收到，便会直接dispatch给用户。</p>
<p>unsequended数据包占用的队列其实是unreliable数据包的队列，所以流量控制也与unreliable数据包相同，会通过pakcetThrottle计算数值概率随机丢弃。</p>
<p>unsequenced数据包没有分片类型，如果需要分片，则会直接转成unreliable fragment发送。</p>
<h1 id="ENet整体流程框架"><a href="#ENet整体流程框架" class="headerlink" title="ENet整体流程框架"></a>ENet整体流程框架</h1><h2 id="收发数据过程"><a href="#收发数据过程" class="headerlink" title="收发数据过程"></a>收发数据过程</h2><p>ENet会在创建时建立一个<code>ENetHost</code>作为通信的客户端，host中包含与peer进行通信的socket，一个<code>ENetList dispatchQueue</code>：用于存放有事件产生的peer队列，和一个<code>ENetPeer* peers</code>数组用于存放与外部客户端通信的peer数据结构。</p>
<p>每个<code>ENetPeer</code>结构主要用于管理与外部的连接和数据发送，<code>ENetPeer</code>中用于数据发送的队列主要有5个：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ENetList      acknowledgements;</span><br><span class="line">ENetList      sentReliableCommands;</span><br><span class="line">ENetList      sentUnreliableCommands;</span><br><span class="line">ENetList      outgoingReliableCommands;</span><br><span class="line">ENetList      outgoingUnreliableCommands;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>acknowledgements</strong>: 用于发送ack</li>
<li><strong>sentReliableCommands</strong>: 用于储存已经发送的可靠包</li>
<li><strong>sentUnreliableCommands</strong>: 用于储存已经发送的不可靠包</li>
<li><strong>outgoingReliableCommands</strong>: 准备发送的可靠包队列</li>
<li><strong>outgpingUnreliableCommands</strong>: 准备发送的不可靠包队列</li>
</ul>
<p>其中需要ack的指令均由reliable队列管理，unreliable和unsequenced数据包均由unreliable队列管理。</p>
<p>在调用enet_peer_send函数时，会将需要发送的数据压入到outgoing队列中。而ack则是在收到可靠包时，将数据压入到<code>acknowledgements</code>队列中。</p>
<p>peer中还有一个队列：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENetList      dispatchedCommands;</span><br></pre></td></tr></table></figure></p>
<p>用于储存已经接收好准备dispatch给用户的数据。</p>
<p>每个<code>ENetPeer</code>中还有一个<code>ENetChannel</code>数组，<code>ENetChannel</code>主要用于接收对端发送回来的数据。</p>
<p><code>ENetChannel</code>中有两个队列：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENetList     incomingReliableCommands;</span><br><span class="line">ENetList     incomingUnreliableCommands;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>incomingRelibaleCommands</strong>: 用于储存已经收到的可靠数据包。</li>
<li><strong>incomingUnreliableCommands</strong>: 用于储存已经收到的不可靠数据包</li>
</ul>
<p>对数据的排序操作会在将其放进channel中的这两个incoming队列中进行，在channel中已经排序好的数据（reliable 数据包的话还需要保证序号连续）会放到peer的<code>dispatchedCommands</code>队列中，并且将peer放到host的<code>dispatchQueue</code>，当host下次处理时如果发现<code>dispatchQueue</code>中已经有peer存在，则会对其进行处理。如果没有，则会进入正常的收发包流程。</p>
<h2 id="host运行过程"><a href="#host运行过程" class="headerlink" title="host运行过程"></a>host运行过程</h2><p>host的主要运行通过一个<code>enet_host_service</code>函数，当有事件产生时，<code>enet_host_service</code>函数就会返回1，并将相应的event储存在传入的<code>ENetEvent</code>指针中，如果没有超过时间限制没有事件产生，则会返回0，出现错误时，<code>enet_host_service</code>会返回-1。</p>
<p><code>enet_host_service</code>的整体流程如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enet_protocol_dispatch_incoming_commands (host, event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    enet_host_bandwidth_throttle (host);</span><br><span class="line"></span><br><span class="line">    enet_protocol_send_outgoing_commands (host, event, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    enet_protocol_receive_incoming_commands (host, event);</span><br><span class="line"></span><br><span class="line">    enet_protocol_send_outgoing_commands (host, event, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    enet_protocol_dispatch_incoming_commands (host, event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        enet_socket_wait();</span><br><span class="line">    &#125;<span class="keyword">while</span></span><br><span class="line">&#125;<span class="keyword">while</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>enet_host_service</code>函数的每一个步骤中如果产生了Evnet，则直接返回。</p>
<p>首先会调用<code>protocol_dispatch_incoming_commands</code>函数查看当前是否存在待处理的事件，如果存在则直接返回。</p>
<p>否则进入循环，首先如果当前系统时间到达下次设置带宽限制的时间戳，则进行带宽限制。</p>
<p>然后发送相应的命令，<code>enet_protocol_send_outgoing_commands</code>会发送用户传入的数据和系统产生的指令。</p>
<p>随后调用<code>enet_protocol_receive_incoming_commands</code>从udp缓冲区中接收相应数据并处理。</p>
<p>随后再次调用<code>enet_protocol_send_outgoing_commands</code>发送相应数据</p>
<p>随后再次调用<code>enet_protocol_dispatch_incoming_commands</code>检测是否有事件产生，如果仍无事件产生，则进入<code>enet_socket_wait()</code>函数的循环</p>
<p><code>enet_socket_wait()</code>内部由select函数实现，用于监听socket读是否有相应，如果udp缓冲区中有数据到达，则重新进入上述循环，如果无数据，则等待用户传入的等待时间后退出。</p>
<h3 id="循环中两次调用send的原因"><a href="#循环中两次调用send的原因" class="headerlink" title="循环中两次调用send的原因"></a>循环中两次调用send的原因</h3><p>在调用<code>enet_protocol_receive_incoming_commands</code>函数后，如果接收到数据后会产生相应的ack指令，这是再次调用<code>enet_protocol_send_outgoing_commands</code>函数，则会立即将ack发送出去，不会像TCP那样捎带发送，减少了网络库对丢包的判断过程。</p>
<h1 id="ENet连接管理"><a href="#ENet连接管理" class="headerlink" title="ENet连接管理"></a>ENet连接管理</h1><h2 id="连接建立流程"><a href="#连接建立流程" class="headerlink" title="连接建立流程"></a>连接建立流程</h2><p>ENet在连接建立过程中同样需要三次握手，并且在建立连接的过程中改变peer的状态。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/61D4208945A14AACBFAC8C8244D5D633?method=download&amp;shareKey=a153c7cc67542b94fd4ca5db0a7a19f5" alt="ENet Connect"></p>
<p>首先两个host建立连接前需要保证peers数组内有空闲的peer(状态为disconnected)。</p>
<p>建立连接时，主动连接方首先找到一个状态为<code>disconnected</code>的peer，并向对端发送connect指令，并且将其状态变为<code>connecting</code>。</p>
<p>对端接收到connect指令后同样找到一个状态为<code>disconnected</code>的peer，并将其状态变为<code>acknowledgeing connect</code>，并返回一个verify connect指令。</p>
<p>主动连接方收到verify connect指令后，将其状态变为<code>connected</code>，意味着连接建立，并且向用户dispatch一个connect event事件，并返回ack指令。</p>
<p>对端接收到ack命令后，将其状态变为<code>connnected</code>，连接建立完成，并同样向用户dispatch一个connect event事件。</p>
<p>至此，双方连接建立完成。</p>
<h2 id="断开连接流程"><a href="#断开连接流程" class="headerlink" title="断开连接流程"></a>断开连接流程</h2><p>ENet提供了三种断开连接的方式：disconnect, disconneted now和disconnect later</p>
<h3 id="disconnect"><a href="#disconnect" class="headerlink" title="disconnect"></a>disconnect</h3><p><img src="https://note.youdao.com/yws/api/personal/file/628E534F2D974B4EA989C7A85C1AE7FC?method=download&amp;shareKey=b23593745ca476e3fa5e6744bde76abf" alt="ENet Disonnect"></p>
<p>断开连接时，主动断开连接的一方向对端发送disconnect指令，并把状态由<code>connected</code>变为<code>disconnecting</code>。</p>
<p>对端收到disconnect指令之后，将状态由<code>connected</code>变为<code>acknowledging disconnect</code>，并且返回ack指令，在发送完ack指令之后，将状态变为<code>zombie</code>状态，并将断开连接事件dispatch给用户之后，将状态由<code>zombie</code>变为<code>disconnected</code>。</p>
<p>主动连接方收到ack后，将状态由<code>disconnecting</code>变为<code>zombie</code>，将断开连接事件dispatch给用户之后，将状态由<code>zombie</code>变为<code>disconnected</code>。</p>
<h4 id="为什么要有acknowledging-disconnect状态"><a href="#为什么要有acknowledging-disconnect状态" class="headerlink" title="为什么要有acknowledging disconnect状态"></a>为什么要有acknowledging disconnect状态</h4><p>因为需要返回ack时，不能将peer状态设为<code>zombie</code>或者<code>disconnected</code>，因为在发送数据时，这两个状态的peer是被忽略的，所以需要设置一个状态，等待将ack发送出去之后，再将状态设置为<code>zombie</code>。</p>
<h4 id="为什么要有zombie状态"><a href="#为什么要有zombie状态" class="headerlink" title="为什么要有zombie状态"></a>为什么要有zombie状态</h4><p>因为需要将断开连接的事件返回给用户，<code>zombie</code>状态就是已经准备断开连接，但是还没断开连接时的状态，被标记为<code>zombie</code>状态的peer不会分配给新的连接，除非用户已经处理该事件。当用户已经收到断开连接的事件后，才会真正将该peer的状态从<code>zombie</code>变为<code>disconnected</code>。</p>
<h3 id="disconnect-later"><a href="#disconnect-later" class="headerlink" title="disconnect later"></a>disconnect later</h3><p>disconnect later会首先将该peer的状态改为<code>disconnect later</code>。状态为<code>disconnect later</code>的peer不会再添加新的数据，也不会处理已经到来的数据，当检测到将现有queue中的数据发送完后，则会发送disconnect命令，进入之前的断开连接流程。</p>
<h3 id="disconnect-now"><a href="#disconnect-now" class="headerlink" title="disconnect now"></a>disconnect now</h3><p><img src="https://note.youdao.com/yws/api/personal/file/D8987E62E0484750BE92D1423E27EF83?method=download&amp;shareKey=bdea1ac300e791babc51ec62feb5c94e" alt="ENet DisConnectNow"></p>
<p>与disconnect不同的是，发送方在调用disconnect_now函数之后，会将peer现有队列中的数据和一个unsequenced的disconnect发送给对端，并直接将状态变为<code>disconnceted</code>，并且不会dispatch event给用户。</p>
<p>对端在收到unsequenced的disconnect指令之后，会将状态变为<code>zombie</code>，在将断开连接事件<code>dispatch</code>给用户之后，将状态变为<code>disconnected</code>。</p>
<h1 id="ENet-数据的发送"><a href="#ENet-数据的发送" class="headerlink" title="ENet 数据的发送"></a>ENet 数据的发送</h1><p>ENet数据发送主要在<code>enet_protocol_send_outgoing_commands</code>函数中进行，该函数会将在outgoing queue中的command和packet调用socket接口发送出去。</p>
<p><code>enet_protocol_send_outgoing_commands</code>函数的大致流程为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(host-&gt;continueSending) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(peer in host-&gt;peers) &#123;</span><br><span class="line"></span><br><span class="line">        send_acknowldeges();</span><br><span class="line"></span><br><span class="line">        check_timeouts();</span><br><span class="line"></span><br><span class="line">        send_reliable_outgoing_commands();</span><br><span class="line"></span><br><span class="line">        send_unreliable_outgoing_commands();</span><br><span class="line"></span><br><span class="line">        enet_socket_send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ENet在发送时会遍历host中每个已经连接的peer，其中不同指令发送的顺序依次是：</p>
<ol>
<li>将ack放入host-&gt;buffers中</li>
<li>检测当前send reliable queue中的命令是否超时，如果超时则将其加到outgoing command的队列头部</li>
<li>将outgoing reliable queue中的命令放入host-&gt;buffers中</li>
<li>将outgoing unreliable queue中的命令放入host-&gt;buffers中（包括unreliable 和 unsequenced命令）</li>
<li>调用socket接口，将host-&gt;buffers中的数据用一个udp数据报发送出去</li>
</ol>
<p>ENet在发送时会保证发送的udp数据报的大小不会超过peer的mtu的大小，如果一个peer内的数据没有发送完，则会将<code>host-&gt;continueSending</code>置为1，意味着还需要继续发送，在下次遍历peer时将数据发送出去。</p>
<p>为保证公平性，不会因为单个peer的需要发送的数据量过大而影响其余peer数据的发送，所以每次对单个peer发送的数据量至多为mtu，如果仍有数据没有发送，则会在下次循环中继续发送，直到<code>host-&gt;contingueSending</code>不再被置为1。</p>
<h2 id="reliable数据包的发送"><a href="#reliable数据包的发送" class="headerlink" title="reliable数据包的发送"></a>reliable数据包的发送</h2><p>在发送reliable数据时，会检测三个条件：</p>
<ol>
<li>发送的数据的范围是否在滑动窗口的有效范围内（选择重传的方法要求发送中的序号不超过序号空间的一半）。</li>
<li>在传输中的数据总量的大小是否超过了发送窗口大小的限制。</li>
<li>host-&gt;buffers是否已经占满或者当前buffer中数据的大小是否超过mtu。</li>
</ol>
<p>如果上述条件均不满足，意味着可以向buffer中继续添加数据，则从<code>peer -&gt; outgoingReliableCommands</code>中将该command取出，放入buffer中，并将该command转移到<code>peer -&gt; sentReliableCommands</code>队列中。</p>
<p><code>peer -&gt; sentReliableCommands</code>会缓存已经发送的但是还没有收到ack的可靠包的command，在每次超时检测时，会检测<code>peer -&gt; sentReliableCommands</code>队列中的command是否已经超时，如果超时则会将该command重新放入到<code>peer -&gt; outgoingReliableCommands</code>队列的头部，在发送数据时将其重新发送。如果一个command的rto超过最大限制或者重传次数超过最大限制，则判定当前peer已经断开连接，进入断开连接流程。</p>
<p>每当收到ack时，会从<code>peer -&gt; sentReliableCommands</code>队列中将相应的command移除。</p>
<h2 id="unreliable数据报的发送"><a href="#unreliable数据报的发送" class="headerlink" title="unreliable数据报的发送"></a>unreliable数据报的发送</h2><p>在发送unreliable数据时，会首先检测两个条件：</p>
<ol>
<li>发送的数据的范围是否在滑动窗口的有效范围内</li>
<li>随机性丢弃一些数据。</li>
</ol>
<p>与reliable数据不同，unreliable不会缓存已经发送的数据，因为它们不需要ack，但是为了避免发送的数据超过peer的带宽限制，则根据带宽控制阀门计算出的随机数在发送前为了保证在传输的数据量不超过peer的带宽，将不可靠包根据<code>packetThrottle</code>的值进行概率随机丢弃。</p>
<p>在发送时同样会将已经发送的command从<code>peer -&gt; outgoingUnreliableCommands</code>放入<code>peer -&gt; sentUnreliableCommands</code>，在每次调用<code>enet_socket_send</code>函数将数据发送出去后则会立即清空<code>peer -&gt; sentUnreliableCommands</code>队列。</p>
<h3 id="不立即清空peer-gt-sentUnreliableCommands队列的原因"><a href="#不立即清空peer-gt-sentUnreliableCommands队列的原因" class="headerlink" title="不立即清空peer -&gt; sentUnreliableCommands队列的原因"></a>不立即清空<code>peer -&gt; sentUnreliableCommands</code>队列的原因</h3><p>host-&gt;buffers储存的内容不是真正意义的buffer，而是需要发送的数据的packet的指针。需要发送的数据的内容实际上仍在各个队列的command中存储，这样避免了数据拷贝的额外消耗。</p>
<p>如果直接将队列清空的话，在调用<code>enet_socket_send</code>发送时则会出现不可预知的错误，所以将<code>peer -&gt; sentUnreliableCommands</code>队列在调用socket接口发送后清空。</p>
<h1 id="ENet-数据的接收"><a href="#ENet-数据的接收" class="headerlink" title="ENet 数据的接收"></a>ENet 数据的接收</h1><p>ENet在创建host时将socket设置为非阻塞模式。在每次接收数据时至多接收256次UDP数据报，如果udp缓冲区中没有数据或者接收次数达到256次，则跳出接收循环，先将接收到的数据dispatch给用户。</p>
<p>接收数据在<code>enet_protocol_receive_incoming_commands</code>函数中进行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (packets = <span class="number">0</span>; packets &lt; <span class="number">256</span>; ++ packets)</span><br><span class="line">&#123;</span><br><span class="line">    receivedLength = enet_socket_receive ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (receivedLength &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (receivedLength == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   enet_protocol_handle_incoming_commands ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>enet_protocol_handle_incoming_commands</code>函数会对接收到的数据进行解析和处理。</p>
<p>在对数据进行解析和处理时，如果是系统指令，则直接对其进行相应的操作。如果是需要接收的数据类型的指令，例如send_reliable，send_unreliable指令，则需要对其进行排序，分片后的重组等操作。</p>
<h2 id="接收send-reliable指令"><a href="#接收send-reliable指令" class="headerlink" title="接收send reliable指令"></a>接收send reliable指令</h2><p>ENet在接收reliable指令时会首先将其按发送序号存放在<code>channel -&gt; incomingReliableCommands</code>队列中。首先需要在<code>channel -&gt; incomingReliableCommands</code>队列中查找到合适的位置，如果相应序号的指令已经存在，则将指令丢弃，如果不存在，则插入到队列中。</p>
<p>这里需要注意的时，由于ENet的序号只有16位，也就是最大只有65535，很容易发生越界。在进行插入的时候同样需要判断序号是否已经出现越界。</p>
<p>每次有新的数据包到来后，则会将<code>channel -&gt; incomingReliableCommands</code>队列中连续不中断的commands移动到<code>peer -&gt; dispatchedCommands</code>队列中，在下次调用<code>enet_host_service</code>函数时，该peer便会产生一个接收数据的事件，并将接收到的数据包返回给用户。</p>
<h2 id="接收send-unreliable指令"><a href="#接收send-unreliable指令" class="headerlink" title="接收send unreliable指令"></a>接收send unreliable指令</h2><p>unreliable指令的接收与reliable大致相似，同样会对数据包进行排序，不同的是，在将数据包从<code>channel -&gt; incomingUnreliableCommands</code>队列转移到<code>peer -&gt; dispatchedCommands</code>队列中时，不会保证数据包的连续性，如果序号较大的已经到了，而序号较小的没有到达，则直接将已经收到的数据包放入<code>peer -&gt; dispatchedCommands</code>队列中，如果后续较小序号的数据包到达的话，则直接丢弃。</p>
<p>还有一点不同的是，之前已经介绍到unreliable数据包的序号要依赖reliable数据包的序号，如果发送新的reliable数据包，则会将该peer中unreliable数据包的序号刷新。所以ENet默认unreliable序号不会超过65535的序号空间，也就没有对unreliable数据包的序号的越界情况进行考虑。</p>
<p>由于unsequenced指令同样放在unreliable队列中处理，如果有unsequenced的指令的话，则会直接放到<code>peer -&gt; dispatchedCommands</code>队列中。</p>
<h2 id="接收fragment指令"><a href="#接收fragment指令" class="headerlink" title="接收fragment指令"></a>接收fragment指令</h2><p>fragment分为reliable和unreliable两种类型。</p>
<p>在处理fragment指令时，会首先判断该分片组中的第一个分片是否已经在<code>channel -&gt; incomingReliableCommands</code>或者<code>channel -&gt; incomingUnreliableCommands</code>队列中。</p>
<p>如果已经到达，则将新到达的数据包的数据并入该第一个分片的command中，如果没有到达，则新建一个command，将其序号设置为分片组的start sequencenum，即第一个分片的序号，插入到<code>channel -&gt; incomingReliableCommands</code>或者<code>channel -&gt; incomingUnreliableCommands</code>队列中的合适位置，并将到达的command中的数据copy到该新建的command中。</p>
<p>在新建分片组第一个分片序号的command时，会同时建立一个位图，判断相应位置的command是否已经到达，如果相应分片已经全部到达，则调用dispatch函数将<code>channel -&gt; incomingReliableCommands</code>或者<code>channel -&gt; incomingUnreliableCommands</code>队列中的数据dispatch到<code>peer -&gt; dispatchedCommands</code>队列中。</p>
<p>如果fragment是unreliable类型的话，操作与reliable类型的command基本相同，不同的是在调用dispatch函数时，如果后续序号的command已经到达，则会将没有重组完全的分片组全部丢弃，而不会进行等待。</p>
<h1 id="ENet-RTT-和-RTO设置"><a href="#ENet-RTT-和-RTO设置" class="headerlink" title="ENet RTT 和 RTO设置"></a>ENet RTT 和 RTO设置</h1><h2 id="RTT运算过程"><a href="#RTT运算过程" class="headerlink" title="RTT运算过程"></a>RTT运算过程</h2><p>ENet在每次收到reliable包的acknowledge时，会对该peer的<code>roundTripTime</code>和<code>roundTripTimeVariance</code>进行更新。更新时并不是将该peer的<code>roundTripTime</code>设置为当前的rtt，而是根据当前的rtt和peer的<code>roundTripTime</code>的差值对<code>roundTripTime</code>和<code>roundTripTimeVariance</code>进行平滑的更新。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rtt_var_thistime = rtt_thistime - peer-&gt;rtt</span><br><span class="line">peer-&gt;rtt = rtt + rtt_var_thistime / <span class="number">8</span></span><br><span class="line">peer-&gt;rtt_var = peer-&gt;rtt_var * <span class="number">3</span>/<span class="number">4</span> + rtt_var_thistime / <span class="number">4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (peer -&gt; roundTripTime &lt; peer -&gt; lowestRoundTripTime)</span><br><span class="line">    peer -&gt; lowestRoundTripTime = peer -&gt; roundTripTime;</span><br><span class="line"><span class="keyword">if</span> (peer -&gt; roundTripTimeVariance &gt; peer -&gt; highestRoundTripTimeVariance) </span><br><span class="line">    peer -&gt; highestRoundTripTimeVariance = peer -&gt; roundTripTimeVariance;</span><br></pre></td></tr></table></figure>
<p>并根据<code>peer-&gt;rountTripTime</code>和<code>peer-&gt;roundTripTimeVariance</code>来更新<code>peer-&gt;lowestRoundTripTime</code>和<code>peer-&gt;highestRoundTripTimeVariance</code>这两个最值。</p>
<p><code>peer-&gt;lowestRoundTripTime</code>和<code>peer-&gt;highestRoundTripTimeVariance</code>它们在每个<code>packetThrottleInterval</code>时间间隔中会被重置为该peer的<code>peer-&gt;rountTripTime</code>和<code>peer-&gt;roundTripTimeVariance</code>当前的值。</p>
<p>这两个最值用于<code>enet_peer_throttle</code>函数中对<code>peer-&gt;packetThrottle</code>的调控和更新</p>
<h2 id="RTO的设置"><a href="#RTO的设置" class="headerlink" title="RTO的设置"></a>RTO的设置</h2><p>ENet在<code>enet_protocol_send_reliable_outgoing_commands</code>函数中每次发送相应可靠包时会为其设置rto，用于判断该包是否超时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command-&gt;rto = peer-&gt;rtt + <span class="number">4</span> * peer-&gt;rtt_var</span><br></pre></td></tr></table></figure>
<p>在<code>enet_protocol_check_timeouts</code>函数中每当检测到一个command超时后，会将其rto设置为原来的2倍，并重发该command。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command-&gt;rto *= <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>当一个command的<code>roundTripTimeout</code>大于该command的<code>rounTripTimeout</code>,并且host在相应时间内没有收到相应peer发送的command，则视为该peer已经断开连接，并进入断开连接的流程。</p>
<h1 id="ENet-流量控制"><a href="#ENet-流量控制" class="headerlink" title="ENet 流量控制"></a>ENet 流量控制</h1><p>ENet流量控制在创建host时，如果设置incomingBandWidth或者outgoingBandWidth为0，则将相应的流量控制关闭，否则则将其打开。</p>
<p>ENet的流量控制简单的通过一个packetThrottle变量实现，通过各个peer的带宽和相应时间内发送的数据量以及收发包的延迟对packetThrottle进行调控，从而达到控制发送数据量的目的。</p>
<p>对于可靠包的发送，ENet在发送数据前会根据padketThrottle计算一个发送窗口的大小，如果当前在传输过程中的数据量的大小超过了发送窗口的大小，则暂停数据的发送，直到发送窗口有足够的空间。</p>
<p>对于不可靠数据包，ENet在发送时会根据packetThrottle计算一个数值来随机丢弃相应的不可靠包，确保数据的发送不会超过peer的发送能力。</p>
<p>ENet流量控制分为两个部分：</p>
<ol>
<li>调节host端的发送能力，确保peer的download bandwidth足够承载host向其发送的数据。</li>
<li>调节peer端的发送能力，确保peer端发送的数据不会超过host端download bandwitdh的承载能力。</li>
</ol>
<h2 id="调节host端的发送"><a href="#调节host端的发送" class="headerlink" title="调节host端的发送"></a>调节host端的发送</h2><p>调节host的发送能力其实是通过对<code>peer-&gt;packetThrottle</code>的调节完成的，ENet在发送数据时，会通过<code>peer-&gt;packetThrottle</code>计算出一个windowSize(发送窗口大小)，如果检测到在发送中的数据的量大于<code>peer-&gt;packetThrottle</code>的话，则暂停发送，直到发送窗口大小有足够的空间。</p>
<p>对于<code>peer-&gt;packetThrottle</code>的调节又分为两个步骤：</p>
<ul>
<li>在每次收到ack时通过本次rtt对于之前rtt的变化对<code>peer-&gt;packetThrottle</code>进行调节</li>
<li>通过比较host的<code>outgoingBandwidth</code>和host在一定时间内发送的数据总量以及peer的<code>incomingBandwitdh</code>和相同时间内向该peer发送的数据量进行调节，确保host的发送不会超过peer的接收能力。</li>
</ul>
<p>如果未打开流量控制，则步骤2的调节可以忽略。</p>
<h3 id="通过rtt对packetThrottle进行调节"><a href="#通过rtt对packetThrottle进行调节" class="headerlink" title="通过rtt对packetThrottle进行调节"></a>通过rtt对packetThrottle进行调节</h3><p>在ENet收到reliable包的ack时，会根据本次的rtt和lasttime_rtt对该peer的<code>packetThrottle</code>进行调节。</p>
<p>具体过程在<code>enet_peer_throttle</code>函数中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enet_peer_throttle</span> <span class="params">(ENetPeer * peer, enet_uint32 rtt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (peer -&gt; lastRoundTripTime &lt;= peer -&gt; lastRoundTripTimeVariance)</span><br><span class="line">    &#123;</span><br><span class="line">        peer -&gt; packetThrottle = peer -&gt; packetThrottleLimit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rtt &lt; peer -&gt; lastRoundTripTime)</span><br><span class="line">    &#123;</span><br><span class="line">        peer -&gt; packetThrottle += peer -&gt; packetThrottleAcceleration;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (peer -&gt; packetThrottle &gt; peer -&gt; packetThrottleLimit)</span><br><span class="line">            peer -&gt; packetThrottle = peer -&gt; packetThrottleLimit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rtt &gt; peer -&gt; lastRoundTripTime + <span class="number">2</span> * peer -&gt; lastRoundTripTimeVariance)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (peer -&gt; packetThrottle &gt; peer -&gt; packetThrottleDeceleration)</span><br><span class="line">            peer -&gt; packetThrottle -= peer -&gt; packetThrottleDeceleration;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            peer -&gt; packetThrottle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于<code>peer-&gt;lastRoundTripTime</code>和<code>peer-&gt;lastRoundTripTimeVariance</code>的更新过程在函数<code>enet_protocol_handle_acknowledge</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (peer -&gt; packetThrottleEpoch == <span class="number">0</span> ||</span><br><span class="line">    ENET_TIME_DIFFERENCE (host -&gt; serviceTime, peer -&gt; packetThrottleEpoch) &gt;= peer -&gt; packetThrottleInterval)</span><br><span class="line">&#123;</span><br><span class="line">    peer -&gt; lastRoundTripTime = peer -&gt; lowestRoundTripTime;</span><br><span class="line">    peer -&gt; lastRoundTripTimeVariance = peer -&gt; highestRoundTripTimeVariance;</span><br><span class="line">    peer -&gt; lowestRoundTripTime = peer -&gt; roundTripTime;</span><br><span class="line">    peer -&gt; highestRoundTripTimeVariance = peer -&gt; roundTripTimeVariance;</span><br><span class="line">    peer -&gt; packetThrottleEpoch = host -&gt; serviceTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>peer-&gt;lastRoundTripTime</code>取得是上一个时间段内peer统计的rtt的最小值。而<code>peer-&gt;lastRountRripTimeVariance</code>取得是上一个时间段内rtt_var的最大值。并且每次更新后将peer中相应的<code>lowestRoundTripTime</code>和<code>highestRoundTripTimeVariance</code>重置为当前的值。</p>
<p>在enet_peer_throttle函数中，</p>
<ol>
<li>如果上个时间段中rtt的最小值小于rtt的变化的最大幅度，可以理解为rtt至少在上个时间段内变为原来的一半，则直接将<code>peer-&gt;pakcetThrottle</code>设置为其上限<code>peer-&gt;packetThrottleLimit</code>。</li>
<li>如果本次的rtt小于上个时间端内rtt的最小值，说明当前网络状况较好，则对该peer的<code>packetThrottle</code>进行相应的增加。</li>
<li>如果本次的rtt大于上次的rtt的最小值加上2倍的rtt变化的最大值，说明当前网络延时有所增加，当前网络的拥塞状况较差，则对该peer的<code>packetThrottle</code>进行相应的减少。</li>
</ol>
<h3 id="通过带宽和数据发送对packetThrottle进行调节"><a href="#通过带宽和数据发送对packetThrottle进行调节" class="headerlink" title="通过带宽和数据发送对packetThrottle进行调节"></a>通过带宽和数据发送对packetThrottle进行调节</h3><p>首先统计出距离上次流量调节的时间间隔内的host发送的数据总量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (host -&gt; outgoingBandwidth != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    dataTotal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bandwidth = (host -&gt; outgoingBandwidth * elapsedTime) / <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (peer = host -&gt; peers; peer &lt; &amp; host -&gt; peers [host -&gt; peerCount]; ++ peer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (peer -&gt; state != ENET_PEER_STATE_CONNECTED &amp;&amp; peer -&gt; state != ENET_PEER_STATE_DISCONNECT_LATER)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        dataTotal += peer -&gt; outgoingDataTotal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>elapsedTime</code>是距离上次流量控制的间隔时间。<br><code>bandwidth</code>可以理解为在该间隔时间内host发送数据的能力。<br><code>dataTotal</code>是在间隔时间内host向已连接的peer发送的数据的总量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (peersRemaining &gt; <span class="number">0</span> &amp;&amp; needsAdjustment != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    needsAdjustment = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dataTotal &lt;= bandwidth)</span><br><span class="line">        throttle = ENET_PEER_PACKET_THROTTLE_SCALE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        throttle = (bandwidth * ENET_PEER_PACKET_THROTTLE_SCALE) / dataTotal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (peer = host -&gt; peers; peer &lt; &amp; host -&gt; peers [host -&gt; peerCount]; ++ peer)</span><br><span class="line">    &#123;</span><br><span class="line">        enet_uint32 peerBandwidth;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((peer -&gt; state != ENET_PEER_STATE_CONNECTED &amp;&amp; </span><br><span class="line">            peer -&gt; state != ENET_PEER_STATE_DISCONNECT_LATER) ||	</span><br><span class="line">            peer -&gt; incomingBandwidth == <span class="number">0</span> ||						</span><br><span class="line">            peer -&gt; outgoingBandwidthThrottleEpoch == timeCurrent)	</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        peerBandwidth = (peer -&gt; incomingBandwidth * elapsedTime) / <span class="number">1000</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((throttle * peer -&gt; outgoingDataTotal) / ENET_PEER_PACKET_THROTTLE_SCALE &lt;= peerBandwidth)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        peer -&gt; packetThrottleLimit = (peerBandwidth *  ENET_PEER_PACKET_THROTTLE_SCALE) / peer -&gt; outgoingDataTotal;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (peer -&gt; packetThrottleLimit == <span class="number">0</span>)</span><br><span class="line">            peer -&gt; packetThrottleLimit = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (peer -&gt; packetThrottle &gt; peer -&gt; packetThrottleLimit)</span><br><span class="line">            peer -&gt; packetThrottle = peer -&gt; packetThrottleLimit;</span><br><span class="line"></span><br><span class="line">        peer -&gt; outgoingBandwidthThrottleEpoch = timeCurrent;</span><br><span class="line"></span><br><span class="line">        peer -&gt; incomingDataTotal = <span class="number">0</span>;</span><br><span class="line">        peer -&gt; outgoingDataTotal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        needsAdjustment = <span class="number">1</span>;</span><br><span class="line">        -- peersRemaining;</span><br><span class="line">        bandwidth -= peerBandwidth;</span><br><span class="line">        dataTotal -= peerBandwidth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (peersRemaining &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataTotal &lt;= bandwidth)</span><br><span class="line">        throttle = ENET_PEER_PACKET_THROTTLE_SCALE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        throttle = (bandwidth * ENET_PEER_PACKET_THROTTLE_SCALE) / dataTotal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (peer = host -&gt; peers; peer &lt; &amp; host -&gt; peers [host -&gt; peerCount]; ++ peer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((peer -&gt; state != ENET_PEER_STATE_CONNECTED &amp;&amp; </span><br><span class="line">            peer -&gt; state != ENET_PEER_STATE_DISCONNECT_LATER) ||</span><br><span class="line">            peer -&gt; outgoingBandwidthThrottleEpoch == timeCurrent)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        peer -&gt; packetThrottleLimit = throttle;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (peer -&gt; packetThrottle &gt; peer -&gt; packetThrottleLimit)</span><br><span class="line">            peer -&gt; packetThrottle = peer -&gt; packetThrottleLimit;</span><br><span class="line"></span><br><span class="line">        peer -&gt; incomingDataTotal = <span class="number">0</span>;</span><br><span class="line">        peer -&gt; outgoingDataTotal = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>throttle</code>是host的<code>bandwidth</code>和发送数据总量的比值的调节值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((throttle * peer -&gt; outgoingDataTotal) / ENET_PEER_PACKET_THROTTLE_SCALE &lt;= peerBandwidth)</span><br><span class="line">   <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<p>如果<code>peer-&gt;incomingBandWidth</code>/<code>peer-&gt;outgoingDataTotal</code>的比值大于throttle，意味着此时peer的带宽足够承载host对peer发送数据的速度，则暂时不予处理，否则则对<code>peer-&gt;packetThrottleLimit</code>进行调节。设置相应peer的<code>packetThrottleLimit</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer -&gt; packetThrottleLimit = (peerBandwidth * ENET_PEER_PACKET_THROTTLE_SCALE) / peer -&gt; outgoingDataTotal;</span><br></pre></td></tr></table></figure></p>
<p>ENet会保证<code>peer-&gt;packetThrottle</code>不超过<code>peer-&gt;packetThrottleLimit</code>。通过设置<code>packetThrottleLimit</code>保证发送数据时host向peer发送的数据量不会超过peer的<code>incomingBandwidth</code>。</p>
<p>对于之前没有设置的peer则统一将其<code>packetThrottle</code>设置为throttle。</p>
<h4 id="采用双层循环的原因"><a href="#采用双层循环的原因" class="headerlink" title="采用双层循环的原因"></a>采用双层循环的原因</h4><p>每次循环中会将 向peer发送数据量/peer的download bandwidth &lt; throttle的peer的<code>packetThrottleLimit</code>设置为其当前的值，并在bandwidth和dataTotal中减去相应的peerBandwidth，再下一次循环中计算出的throttle会比上一次计算得出的throttle跟更高。如果只是单次循环并将剩下的peer的<code>packetThrottleLimit</code>设置为当前的throttle，会<br>对peer的incomingBandwidth造成浪费。</p>
<h4 id="最后统一设置为thtottle原因"><a href="#最后统一设置为thtottle原因" class="headerlink" title="最后统一设置为thtottle原因"></a>最后统一设置为thtottle原因</h4><p>为保证平均高效的利用host的带宽，虽然剩余的peer的<code>incomingBandwidth</code>足够承载host的发送的数据，但是host在发送数据时也需要考虑到host总的<code>outgoingBandwidth</code>，所以将剩下的peer的<code>pakcetThrottleLimit</code>设置为throttle，防止单个peer发送数据过多占满host的upload bandwidth。</p>
<h2 id="调节peer端的发送"><a href="#调节peer端的发送" class="headerlink" title="调节peer端的发送"></a>调节peer端的发送</h2><p>每当ENet中有peer连接或者断开连接时，会将<code>ENetHost-&gt;recalculateBandwidthLimits</code>结构变量置为1，在下次<code>enet_host_service</code>函数中调用<code>enet_host_bandwidth_throttle</code>时会进行该项的流量控制。</p>
<p>调节peer端发送能力，通过向该peer发送<code>ENetProtocolBandwidthLimit</code>指令实现。其中</p>
<ul>
<li><code>ENetProtocolBandwidthLimit.outgoingBandwidth</code>简单的对应<code>host -&gt; outgoingBandwidth</code></li>
<li><code>ENetProtocolBandwidthLimit.incomingBandwidth</code>则是host端对该peer调节后的bandwidthLimit</li>
</ul>
<p>host通过向peer发送<code>ENetProtocolBandwidthLimit</code>指令设置client端对应host的peer的<code>incomingBandwidth</code>，进而client端通过<code>incomingBandwidth</code>调节对应host的peer中的<code>packetThrottleLimit</code>和<code>packetThrottle</code>来控制对host流量传输。</p>
<p>具体调节流程可以看如下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">host -&gt; recalculateBandwidthLimits = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">peersRemaining = (enet_uint32) host -&gt; connectedPeers;</span><br><span class="line">bandwidth = host -&gt; incomingBandwidth;</span><br><span class="line">needsAdjustment = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bandwidth == <span class="number">0</span>)</span><br><span class="line">    bandwidthLimit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (peersRemaining &gt; <span class="number">0</span> &amp;&amp; needsAdjustment != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    needsAdjustment = <span class="number">0</span>;</span><br><span class="line">    bandwidthLimit = bandwidth / peersRemaining;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (peer = host -&gt; peers; peer &lt; &amp; host -&gt; peers [host -&gt; peerCount]; ++ peer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((peer -&gt; state != ENET_PEER_STATE_CONNECTED &amp;&amp; </span><br><span class="line">            peer -&gt; state != ENET_PEER_STATE_DISCONNECT_LATER) ||	</span><br><span class="line">            peer -&gt; incomingBandwidthThrottleEpoch == timeCurrent)	</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (peer -&gt; outgoingBandwidth &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            peer -&gt; outgoingBandwidth &gt;= bandwidthLimit)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        peer -&gt; incomingBandwidthThrottleEpoch = timeCurrent;</span><br><span class="line"></span><br><span class="line">        needsAdjustment = <span class="number">1</span>;</span><br><span class="line">        -- peersRemaining;</span><br><span class="line">        bandwidth -= peer -&gt; outgoingBandwidth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (peer = host -&gt; peers; peer &lt; &amp; host -&gt; peers [host -&gt; peerCount];  ++ peer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (peer -&gt; state != ENET_PEER_STATE_CONNECTED &amp;&amp; peer -&gt; state != ENET_PEER_STATE_DISCONNECT_LATER)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    command.header.command = ENET_PROTOCOL_COMMAND_BANDWIDTH_LIMIT | ENET_PROTOCOL_COMMAND_FLAG_ACKNOWLEDGE;</span><br><span class="line">    command.header.channelID = <span class="number">0xFF</span>;	</span><br><span class="line">    command.bandwidthLimit.outgoingBandwidth = ENET_HOST_TO_NET_32 (host -&gt; outgoingBandwidth);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (peer -&gt; incomingBandwidthThrottleEpoch == timeCurrent)</span><br><span class="line">        command.bandwidthLimit.incomingBandwidth = ENET_HOST_TO_NET_32 (peer -&gt; outgoingBandwidth);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        command.bandwidthLimit.incomingBandwidth = ENET_HOST_TO_NET_32 (bandwidthLimit);</span><br><span class="line"></span><br><span class="line">    enet_peer_queue_outgoing_command (peer, &amp; command, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>peersRemaining</code>指与host已经连接的peer的数量。<br><code>bandwidth</code>指host的download bandwidth的大(incomingBandwidth)。</p>
<p>如果host端未开启流量控制，即<code>host -&gt; incomingBandwidth</code>的值为0，则设置bandwidthLimit为0。</p>
<p>否则通过双层循环对带宽限制进行调节。</p>
<p>每次while循环会重新计算<code>bandwidthLimit</code>，并将不需要带宽限制的peer或者发送能力小于<code>bandwidthLimit</code>的peer标记出来。在接下来发送<code>ENetProtocolBandwidthLimit</code>指令时则将其中的<code>incomingBandwidth</code>设置为<code>peer-&gt;outgoingBandwidth</code>，即不用改变。对于发送能力大于<code>bandwidthLimit</code>的peer，则将相应的<code>ENetProtocolBandwidthLimit</code>指令中的<code>incomingBandwidth</code>设置为bandwidthlimit。</p>
<h3 id="关于用双层循环的原因"><a href="#关于用双层循环的原因" class="headerlink" title="关于用双层循环的原因"></a>关于用双层循环的原因</h3><p>如果第一次循环将所有发送能力大于<code>bandwidthLimit</code>的peer都设置为<code>bandwidthLimit</code>而对于那些发送能力小的则不改变的话，host的<code>incomingBandwidth</code>其实是没有使用完的，会造成浪费。</p>
<p>在每次for循环中将发送发送能力小于<code>bandwidthLimit</code>的peer剔除之后，重新计算的<code>bandwidthLimit</code>会增大，意味着host的<code>incomingBandwidth</code>可以承载更多的带宽，低于该值的peer都是不用调节的，这样可以更加充分的利用host的带宽，而不造成浪费。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/05/12/记一次闹心的网络调试经历/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/12/记一次闹心的网络调试经历/" itemprop="url">记一次闹心的网络调试经经历</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-12T20:26:19+08:00">
                2018-05-12
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-05-12T21:08:45+08:00">
                2018-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Personal-Journal/" itemprop="url" rel="index">
                    <span itemprop="name">Personal Journal</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前为测试下自己毕业设计实现的网络库，手边没有两台电脑，所以就打算在本机测试实现，方法是通过修改本极路由表，让发向本地ip的网络包不直接通过回环端口，而是先发送到网关，在通过网关返回回来，这样通过丢包模拟软件设置本地网卡的丢包率和延时便可以模拟真实网络环境的波动，进而进行测试。</p>
<p>环境是：<code>Windows 10</code>，丢包模拟软件是：<code>Network Emulator Client</code></p>
<p>修改本地路由表的命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add [本地ip] mask 255.255.255.255 [网关ip]</span><br></pre></td></tr></table></figure></p>
<h2 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h2><p>这种方法首先在公司是可行的，可是回到自己住的地方后，再通过这种方法发现发向本地ip的UDP包无法收到，ping本地ip测试之后，返回的是这个结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reply from 192.168.31.1: Destination port unreachable.</span><br></pre></td></tr></table></figure></p>
<p>目标端口不可达，这就非常奇怪了。</p>
<p>一开始以为是本机防火墙的锅，但是修改了win10防火墙各种参数之后还是没有效果。</p>
<p>并且通过测试可以发现，同一子网下的不同的两台主机之间是可以ping通的，所以不存在路由器找不到mac地址的问题，既然能找到mac地址，很有可能是路由器把这个包丢掉了。</p>
<h2 id="解决尝试"><a href="#解决尝试" class="headerlink" title="解决尝试"></a>解决尝试</h2><p>既然是路由器的问题，一种方法是直接将路由器去掉，把网线直接插到网口上面，这样直接在上层的子网内尝试向本机ip发包，然后这次问题变成了超时，由于房间内网线上层连接的是2层交换机，交换机会进行什么样的操作就无法干预了，退回到路由器的问题。</p>
<h2 id="远程连接路由器"><a href="#远程连接路由器" class="headerlink" title="远程连接路由器"></a>远程连接路由器</h2><p>路由器管理员界面是没有提供发包调试的功能，也没有命令行页面的，仅仅通过管理员界面是无法对路由表和防火墙进行操作的，没办法，先试着远程链接下路由器。</p>
<p>由于我的路由器的型号是小米路由器3，通过查阅资料发现，要远程连接路由器首先需要将路由器刷机到开发版，然后给路由器装上ssh，这样就可以远程连接了。</p>
<p>然后就去重官网上下载了小米路由器3开发版的最新版，尝试了几次之后给路由器成功刷成了开发者版本。</p>
<p>发现安装ssh要通过u盘进行操作，然后先去找室友借到了u盘，下好ssh文件，插到路由器上后，重启，尝试连接，没有反应。</p>
<p>这样反复几次之后，突然意识到u盘需要时fat32格式的，借到的u盘太大，无法格式化为fat32格式，只能是NTFS和EXFAT格式，因为FAT32最好的支持是小于32g的U盘，太大的U盘格式化便没了这个选项。</p>
<p>没办法，费劲心力找到了一个8g的小U盘，格式化为FAT32格式的，插入路由器，安装，OK，重启，尝试连接，成功！</p>
<h2 id="远程路由器"><a href="#远程路由器" class="headerlink" title="远程路由器"></a>远程路由器</h2><p>不得不说小米是骚气，路由器登陆界面竟然是这个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> -----------------------------------------------------</span><br><span class="line">       Welcome to XiaoQiang!</span><br><span class="line"> -----------------------------------------------------</span><br><span class="line">  $$$$$$\  $$$$$$$\  $$$$$$$$\      $$\      $$\        $$$$$$\  $$\   $$\</span><br><span class="line"> $$  __$$\ $$  __$$\ $$  _____|     $$ |     $$ |      $$  __$$\ $$ | $$  |</span><br><span class="line"> $$ /  $$ |$$ |  $$ |$$ |           $$ |     $$ |      $$ /  $$ |$$ |$$  /</span><br><span class="line"> $$$$$$$$ |$$$$$$$  |$$$$$\         $$ |     $$ |      $$ |  $$ |$$$$$  /</span><br><span class="line"> $$  __$$ |$$  __$$&lt; $$  __|        $$ |     $$ |      $$ |  $$ |$$  $$&lt;</span><br><span class="line"> $$ |  $$ |$$ |  $$ |$$ |           $$ |     $$ |      $$ |  $$ |$$ |\$$\</span><br><span class="line"> $$ |  $$ |$$ |  $$ |$$$$$$$$\       $$$$$$$$$  |       $$$$$$  |$$ | \$$\</span><br><span class="line"> \__|  \__|\__|  \__|\________|      \_________/        \______/ \__|  \__|</span><br><span class="line">root@XiaoQiang:~#</span><br></pre></td></tr></table></figure></p>
<p>不知道雷布斯同学看了后是什么反应，= =。</p>
<p>终于登陆到路由器了，然后下一步该干嘛呢 0.0</p>
<p>先看一下路由器的路由表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@XiaoQiang:~# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0.2</span><br><span class="line">192.168.31.0    0.0.0.0         255.255.255.0   U     0      0        0 br-lan</span><br><span class="line">###.###.##.#    0.0.0.0         255.255.255.0   U     0      0        0 wl2</span><br><span class="line">0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 eth0.2</span><br><span class="line">0.0.0.0         192.168.1.1     0.0.0.0         UG    50     0        0 eth0.2</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>个人外网的ip地址处于安全问题就先用#代替了</p>
</blockquote>
<p>小米路由器的内网网关是192.168.31.1，掩码是 255.255.255.0，个人主机的ip地址是192.168.31.233。对应的规则是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.31.0    0.0.0.0         255.255.255.0   U     0      0        0 br-lan</span><br></pre></td></tr></table></figure></p>
<p>好像并没有什么问题，发向192.168.31.0的子网的包会通过自己转发出去。</p>
<p>难道是路由器防火墙的问题？</p>
<h2 id="坑爹的路由器防火墙"><a href="#坑爹的路由器防火墙" class="headerlink" title="坑爹的路由器防火墙"></a>坑爹的路由器防火墙</h2><p>尝试下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/firewall stop</span><br></pre></td></tr></table></figure></p>
<p>关掉了路由器的防火墙，重新向本地ip用Ping命令测试，居然成功了！！！！！</p>
<p>OK，果然是这个坑爹的路由器防火墙把发向源ip和目的ip相同的包给拒了。</p>
<p>但是····QAQ，把防火墙关了之后，坑爹的网居然被断了，只能子网内自己发发包玩下，包发不出去了= =，坑爹的，实在是没精力去学习路由器防火墙规则了，先这样把，测试的时候先把路由器防火墙关了，不用的时候再打开= =，非常郁闷了。</p>
<p>不过花了三个晚上找到了问题还是很开心的。</p>
<p>把这个问题放在这边，希望大家不要再踩这个坑了，测试还是用两台主机去测试吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/03/01/UDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/01/UDP/" itemprop="url">UDP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-01T17:11:24+08:00">
                2018-03-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-03-01T17:13:15+08:00">
                2018-03-01
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unix-Network-Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Unix Network Programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>UDP是无连接不可靠的数据报协议，使用UDP编写的一些常见的应用程序有：DNS（域名系统），NFS（网络文件系统）和SNMP（简单网络管理协议）。</p>
<h2 id="UDP客户-服务器程序所有套接字函数"><a href="#UDP客户-服务器程序所有套接字函数" class="headerlink" title="UDP客户/服务器程序所有套接字函数"></a>UDP客户/服务器程序所有套接字函数</h2><p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/UDP%20socket%20function.JPG" alt="image"></p>
<h2 id="recvfrom-和-sendto-函数"><a href="#recvfrom-和-sendto-函数" class="headerlink" title="recvfrom 和 sendto 函数"></a>recvfrom 和 sendto 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, struct sockaddr* from, <span class="keyword">socklen_t</span>* addrlen);</span><br><span class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr *to, <span class="keyword">socklen_t</span> addrlen);</span><br></pre></td></tr></table></figure>
<p>前三个参数sockfd、buff和nbytes等同于read和write函数的三个参数：描述符、指向读入或写出缓冲区的指针和读写字节数。</p>
<p>sendto的to参数指向一个含有数据报接收者的协议地址的套接字地址结构，其大小由addrlen参数指定。recvfrom的from参数指向一个将由该函数在返回时填写数据报发送者的协议地址的套接字结构，而在该套接字地址结构中填写的字节数则放在addrlen参数所指向的整数中返回给调用者。</p>
<p>注意:sendto的最后一个参数是一个整数值，而recvfrom的最后一个参数是一个指向整数的指针。</p>
<p>则两个函数都把所读写数据的长度作为函数返回值。在recvfrom使用数据报协议的典型用途中，返回值就是所接收数据报中的用户数据量。</p>
<p>写一个长度为0的数据报是可行的。在UDP情况下，这会形成一个只包含IP首部和一个8字节UDP首部而没有数据的IP数据报。对于数据报协议，recvfrom返回0是可以接受的：它并不像TCP套接字上read返回0值那样表示对端已关闭连接。既然UDP是无连接的，因此也就没有诸如关闭一个UDP连接之类的事情。</p>
<p>对于一个UDP套接字，如果进程首次调用sendto时它没有绑定一个本地端口，那么内核就在此时为它选择一个临时端口。同TCP一样，客户也可以显示地调用bind，不过很少这样做。</p>
<h2 id="接收缓冲区"><a href="#接收缓冲区" class="headerlink" title="接收缓冲区"></a>接收缓冲区</h2><p>每个UDP套接字都有一个接受缓冲区，到达该套接字的每个数据报都进入这个套接字的接收缓冲区。当进程调用recvfrom时，接收缓冲区中的下一个数据报以FIFO的顺序返回给进程。</p>
<p>在进程能够取该套接字中任何已排好队的数据报之前，如果有多个数据报达到该套接字，那么相继到达的数据报仅仅加到该套接字的接收缓冲区中。然而这个缓冲区的大小是有限的。</p>
<h2 id="UDP-从客户端和服务端角度"><a href="#UDP-从客户端和服务端角度" class="headerlink" title="UDP 从客户端和服务端角度"></a>UDP 从客户端和服务端角度</h2><p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/UDP%20in%20clinet.JPG" alt="image"></p>
<p>客户端必须给sendto调用指定服务器地IP地址和端口号。一般来说，客户端地IP地址和端口号均由内核自动选择。</p>
<p>客户端地临时端口是在第一次调用sendto时一次性选定，不能改变；然而客户地IP地址却可以随客户端发送地每个UDP数据报而变动。</p>
<p>如果客户端捆绑了一个IP地址到其套接字上，但是内核决定外出数据报必须从另一个数据链路发出，这种情形下，IP数据报将包含一个不同于外出链路IP地址地源IP地址。</p>
<p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/UDP%20in%20server.JPG" alt="image"></p>
<p>UDP套接字目的IP地址只能通过为IPv4设置IP_RECVDSTADDR套接字选项（或为IPv6设置IPV6_PKTINFO套接字选项）然后调用recvmsg（而不是recvfrom）取得。</p>
<p>由于UDP是无连接地，因此目的IP地址可随发送到服务器地每个数据报而改变。UDP服务器也可接收目的服务器主机地某个广播地址或多播地址地数据报。</p>
<h2 id="UDP-connect函数"><a href="#UDP-connect函数" class="headerlink" title="UDP connect函数"></a>UDP connect函数</h2><p>对于一个UDP套接字，由它引发地异步错误并不返回给它，除非它已连接。</p>
<p>UDP调用connect，内核只是检查是否存在立即可知的错误，记录对端的IP地址和端口号，然后立即返回到调用进程。</p>
<p>对于已连接UDP套接字与默认的未连接UDP套接字相比，发生了三个变化：</p>
<ol>
<li>不能该输出操作指定目的IP地址和端口号。也就是说，我们不使用sendto，而改用write或send。写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址。（其实sendto也可以用，但是不能指定目的地址，snedto的第五个参数必须为空指针，第六个参数为0）。</li>
<li>不必使用recvfrom获悉数据报的发送者，而改用read、recv或recvmsg。在一个已连接UDP套接字上，由内核为输入操作返回的数据报只有那些来自connect所指定协议地址的数据报。目的地为这个已连接UDP套接字的本地协议地址，发源地却不是该套接字早先connect到的协议地址的数据报，不会投递到该套接字。这样就限制一个已连接UDP套接字能且仅能与一个对端交换数据报。</li>
<li>由已连接UDP套接字引发的异步错误会返回给他们所在的进程，而未连接UDP套接字不会接收任何异步错误。</li>
</ol>
<h3 id="给一个UDP套接字多次调用-connect"><a href="#给一个UDP套接字多次调用-connect" class="headerlink" title="给一个UDP套接字多次调用 connect"></a>给一个UDP套接字多次调用 connect</h3><ol>
<li>指定新的ip地址和端口号</li>
<li>断开套接字</li>
</ol>
<p>给一个已连接的UDP套接字指定新的对端不同于TCP套接字中connect的使用：对于TCP套接字，connect只能调用一次。</p>
<p>为了断开一个已连接UDP套接字，再次调用connect时把套接字地址结构的地址族改成员设置为AF_UNSPEC。这么做可能返回一个EAFNOSUPPORT错误。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>当应用进程在一个未连接的UDP套接字上调用sendto时，源自Berkeley的内核暂时连接该套接字，发送数据报，然后断开连接。通常涉及内核执行下列6个步骤：</p>
<ol>
<li>连接告戒之</li>
<li>输出第一个数据报</li>
<li>断开套接字连接</li>
<li>连接套接字</li>
<li>输出第二个数据报</li>
<li>断开套接字连接</li>
</ol>
<p>如果应用进程知道自己要给同一目的地址发送多个数据报时，显示连接套接字效率更高。调用connect后调用两次write设计内核执行如下步骤：</p>
<ol>
<li>连接套接字</li>
<li>输出第一个数据报</li>
<li>输出第二个数据报</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/02/23/IP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/23/IP/" itemprop="url">IP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-23T17:17:17+08:00">
                2018-02-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-02-23T17:23:27+08:00">
                2018-02-23
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unix-Network-Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Unix Network Programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="IPv4头部"><a href="#IPv4头部" class="headerlink" title="IPv4头部"></a>IPv4头部</h2><p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/IPv4%20header.jpg" alt="image"></p>
<h2 id="IPv6头部"><a href="#IPv6头部" class="headerlink" title="IPv6头部"></a>IPv6头部</h2><p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/IPv6%20header.jpg" alt="image"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/02/23/IO复用：select和poll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/23/IO复用：select和poll/" itemprop="url">IO复用：select和poll</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-23T17:17:07+08:00">
                2018-02-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-02-23T17:22:38+08:00">
                2018-02-23
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unix-Network-Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Unix Network Programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用I-O复用的经典场合"><a href="#使用I-O复用的经典场合" class="headerlink" title="使用I/O复用的经典场合"></a>使用I/O复用的经典场合</h2><ul>
<li>当客户处理多个描述符（通常是交互式输入和网络套接字）时，必须使用I/O复用。</li>
<li>当一个客户端同时处理多个套接字时可能的。</li>
<li>如果一个TCP服务器既要处理监听套接字，又要处理已连接套接字。</li>
<li>如果一个服务器既要处理TCP，又要处理UDP，一般就要使用I/O复用。</li>
<li>如果一个服务器要处理多个服务器或者多个协议，一般要使用I/O复用。</li>
</ul>
<h2 id="select-函数"><a href="#select-函数" class="headerlink" title="select 函数"></a>select 函数</h2><p>该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdpl, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>select函数修改由指针readset、writeset和exceptset所指向的描述符集，因而这三个参数都是值-结果参数。调用该函数时，我们所指定所关心的描述符的值，该函数返回时，结果将指示哪些描述符已就绪。该函数返回后，我们使用FD_ISSET宏来测试fd_set数据类型中的描述符。描述符集内任何与未就绪描述符对应的位返回时均清成0。每次重新调用select函数时，我们都得再次把所有描述符集内所关心的位置均置为1。</p>
<h2 id="描述符就绪条件"><a href="#描述符就绪条件" class="headerlink" title="描述符就绪条件"></a>描述符就绪条件</h2><h3 id="套接字准备好读"><a href="#套接字准备好读" class="headerlink" title="套接字准备好读"></a>套接字准备好读</h3><ol>
<li>该套接字接收缓冲区中的数据字节数大于等于套接字接收缓冲区低水位标记的当前大小。对这样的套接字执行读操作不会阻塞并将返回一个大于0的值。可以使用SO_RCVLOWAT套接字选项设置该套接字的低水位标记。对于TCP和UDP套接字，其默认值为1。</li>
<li>该连接的读半部关闭（也就是接收了FIN的TCP连接）。对于这样的套接字的读操作将不阻塞并返回0(也就是返回EOF)。</li>
<li>该套接字是一个监听套接字且已完成的连接数不为0。对这样的套接字的accept通常不会阻塞。</li>
<li>其上有一个套接字错误待处理。对这样的套接字的读操作将不阻塞并返回-1（也就是返回一个错误），同时把errno设置成确切的错误条件。这些待处理错误（pending error）也可以通过指定SO_ERROR套接字选项调用getsockopt获取并清除。</li>
</ol>
<h3 id="套接字准备好写"><a href="#套接字准备好写" class="headerlink" title="套接字准备好写"></a>套接字准备好写</h3><ol>
<li>该套接字发送缓冲区中的可用空间字节数大于等于套接字发送缓冲区低水位标记的当前大小，并且u后者该套接字已连接，或者该套接字不需要连接（如UDP套接字）。这意味着如果我们把这样的套接字设置为非阻塞，写操作将不阻塞并返回一个正值。可以使用SO_SNDLOWAT套接字选项来设置该套接字的低水位标记。对于TCP和UDP套接字而言，其默认值是2048。</li>
<li>该连接的写半部关闭，对这样的套接字的写操作将产生SIGPIPE信号。</li>
<li>使用非阻塞式connect的套接字已建立连接，或者connect已经以失败告终。</li>
<li>其上有一个套接字错误待处理。对这样的套接字的写操作将不阻塞并返回-1(也就是返回一个错误)，同时把errno设置成确切的错误条件。这些待处理的错误也可以通过指定的SO_ERROR套接字选项调用getsockopt获取并清除。</li>
</ol>
<p>当某个套接字发生错误时，它将由select标记为即可读又可写。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/02/23/TCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/23/TCP/" itemprop="url">TCP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-23T17:16:50+08:00">
                2018-02-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-02-23T17:24:27+08:00">
                2018-02-23
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unix-Network-Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Unix Network Programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="TCP-状态转换图"><a href="#TCP-状态转换图" class="headerlink" title="TCP 状态转换图"></a>TCP 状态转换图</h2><p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/TCP%20state.jpg" alt="image"></p>
<h2 id="TCP连接分组转换"><a href="#TCP连接分组转换" class="headerlink" title="TCP连接分组转换"></a>TCP连接分组转换</h2><p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/tcp%20connection%20example.jpg" alt="image"></p>
<h2 id="捎带（piggybacking）"><a href="#捎带（piggybacking）" class="headerlink" title="捎带（piggybacking）"></a>捎带（piggybacking）</h2><p>服务器对于客户端请求的确认可以伴随其应答发生，这种做法称为捎带（piggybacking），它通常在服务器处理请求并产生应答的时间少于200ms时发生。</p>
<h2 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h2><p>在TCP链接中，执行主动关闭的那端会有TIME_WAIT状态。改端点停留在这个状态的持续时间时<strong>最长分节生命期 maximum segment lifetime，MSL</strong>的两倍，有时称为2MSL。</p>
<p>任何TCP的实现都需要为MSL选择一个值。MSL时任何IP数据报能够在因特网中存活的最长时间。这个时间是有限的，因为每个数据报含有一个称为<strong>跳限 hop limit</strong>的8位字段，它的最大值是255。虽然跳限不是真正的时间限制，但是仍然假设：具有最大跳限的分组在网络中存活的时间不会超过MSL秒。</p>
<p>分组在网路中的迷途通常是路由异常的结果。某个路由器崩溃或某两个路由器之间的某个链路断开时，路由协议需要花费数秒钟到数分钟的时间才能稳定并找出另一条通路。并且在这段时间内有可能发生路由循环(路由器A把分组发送给路由器B，而B再把他们发送回A)。</p>
<p>假设迷途的分组是一个TCP分节，在迷途期间，发送端TCP超时并重传该分组，而重传的分组却通过某条候选路径到达最终目的地。不久之后路由器修复，之前迷途的分组也最终被送到目的地。这个原来的分组称为<strong>迷途的重组分组 lost duplicate</strong>或<strong>漫游的重组分组 wandering duplicate</strong>。</p>
<h3 id="TIME-WAIT状态存在的理由"><a href="#TIME-WAIT状态存在的理由" class="headerlink" title="TIME_WAIT状态存在的理由"></a>TIME_WAIT状态存在的理由</h3><ol>
<li><strong>可靠地实现TCP全双工连接的终止</strong></li>
<li><strong>允许老的重复分节在网络中消逝</strong></li>
</ol>
<p>对于理由1，在TCP关闭连接的4次握手中，如果最终的ACK丢失了，服务器将重新发送它的最后的那个FIN，因此客户端必须维护状态信息，以允许它重新发送最终那个ACK。如果客户端不维护状态信息，它将相应一个rst，该分节将被服务器解释成一个错误。如果TCP打算执行所有必要的工作以彻底终止某个连接上的两个方向的数据流，那么它必须正确处理连接终止序列4个分节中任何一个分节丢失的情况。</p>
<p>执行主动关闭的那一端是处于TIME_WAIT状态的那一端，因为可能不得不重传最终的ACK的就是那一端。</p>
<p>对于理由2：假设服务端和客户端分别在1500端口和21端口之间有一个TCP连接。关闭这个连接之后，在相同的IP地址和端口之间建立另一个连接。后一个连接称为前一个连接的<code>化身 incarnation</code>，因为他们的IP地址和端口号都相同。</p>
<p>TCP必须防止来自某个连接的老的重复分组在该连接已终止后再现，从而被误解为属于同一连接的某个新的化身。为做到这一点，TCP将不给处于<code>TIME_WAIT</code>状态的连接发起新的化身。<code>TIME_WAIT</code>的持续时间是MSL的2倍，足以让某个方向上的分组最多存活MSL秒被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃。通过这个规则可以保证没成功建立一个TCP连接时，来自该连接先前化身的重复分组都已在网络中消逝了。</p>
<h2 id="TCP输出"><a href="#TCP输出" class="headerlink" title="TCP输出"></a>TCP输出</h2><p>每一个TCP套接字都有一个发送缓冲区，可以使用<code>SO_SNDBUF</code>套接字选项来更改缓冲区的大小。当某个应用进程调用write时，内核从该应用进程的缓冲区复制所有数据写到套接字的发送缓冲区。</p>
<p>如果该套接字的发送缓冲区容不下应用进程的所有数据（或是应用进程的缓冲区大于套接字的发送缓冲区，或是套接字的发送缓冲区中已有其他数据），该应用进程将被投入睡眠。这里假设套接字是阻塞的（套接字默认设置是阻塞的）。内核将不从write系统调用返回，知道应用进程缓冲区中的所有数据都复制到套接字的发送缓冲区。</p>
<p>从写一个TCP套接字的write调用成功返回仅仅表示我们可以从重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已经接收到数据。</p>
<h2 id="PF-INET和AF-INET的区别"><a href="#PF-INET和AF-INET的区别" class="headerlink" title="PF_INET和AF_INET的区别"></a>PF_INET和AF_INET的区别</h2><p>AF: Address Family，表示地址族</p>
<p>PF: Protocol Family，表示协议族</p>
<p>在windows中的Winsock2.h中定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INET 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_INET AF_INET</span></span><br></pre></td></tr></table></figure></p>
<p>所以在windows中<code>AF_INET</code>与<code>PF_INET</code>完全一样。</p>
<p>而在Unix/Linux系统中，不同的版本这两者有微小的差别。对于BSD，是AF，对于POSIX，是PF。</p>
<p>理论上在建立socket时指定协议，应该用<code>PF_xxxx</code>，设置地址时应该用<code>AF_xxxx</code>。</p>
<p>当然<code>AF_INET</code>和<code>PF_INET</code>的值是相同的，混用也不会有太大问题。</p>
<h2 id="RST"><a href="#RST" class="headerlink" title="RST"></a>RST</h2><p>RST是TCP在发生错误时发送的一种TCP分节，产生RST的三个条件是：</p>
<ol>
<li>目的地为某端口的SYN到达，然而该端口上并没有正在监听的服务器</li>
<li>TCP想取消一个已有连接</li>
<li>TCP接收到一个根本不存在的连接上的分节</li>
</ol>
<h2 id="基于TCP客户-服务器程序的套接字函数"><a href="#基于TCP客户-服务器程序的套接字函数" class="headerlink" title="基于TCP客户/服务器程序的套接字函数"></a>基于TCP客户/服务器程序的套接字函数</h2><p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/TCP%20client_server%20socket%20function.JPG" alt="image"></p>
<h2 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect 函数"></a>connect 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>客户端在调用函数connect前不必非得调用connect函数，因为如果需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。</p>
<p>如果是TCP套接字，调用connect时会激发TCP的三次握手过程，而且仅在连接建立成功或出错时才返回。</p>
<p>出错有以下几种情况:</p>
<ol>
<li>若TCP客户端没有收到SYN分节的响应，则返回<code>ETIMEDOUT</code>错误。</li>
<li>若对客户的SYN的响应时RST，则表明该服务器主机在我们指定的端口上没有进程在等待与之连接。这是一种硬错误（hard error），客户一接收到RST就马上返回<code>ECONNECTREFUSED</code></li>
<li>若客户端发出的SYN在中间的某个路由器上引发了一个“destination unreachable”ICMP错误，则认为是一种软错误（soft error）。</li>
</ol>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果一个TCP客户端或者服务器未曾调用bind捆绑一个端口，当调用connect或者listen时，内核就要为相应的套接字选择一个临时端口。</li>
</ul>
<p>这个过程有一个例外：远程过程调用服务器（Remote Procedure Call，RPC）。他们通常由内核为他们的监听套接字选择一个临时端口，而该端口随后通过RPC端口映射器进行注册。客户在connect这个服务器之前，必须与端口映射器联系以获取他们的临时端口。</p>
<ul>
<li>进程可以把一个特地的IP地址捆绑到它的套接字上，不过这个IP地址必须属于其所在主机的网络接口之一。对于TCP客户，这就为在该套接字上发送的IP数据报指派了源IP地址。对于TCP服务器，这就限定该套接字只接收那些目的地为这个IP地址的客户连接。</li>
</ul>
<p>TCP客户通常不把IP地址捆绑到它的套接字上，当连接套接字时，内核将根据所用外出网络接口来选择源IP地址，而所用外出接口则取决于到达服务器所需的路径。如果TCP服务器没有把IP地址捆绑到它的套接字上，内核就把客户端发送的SYN的目的IP地址作为服务器的源IP地址。</p>
<p>如果指定端口号为0，那么内核就找bind被调用时选择一个临时端口。然而如果指定IP地址为通配地址，那么内核将等到套接字已连接（TCP）或已在套接字上发出数据报（UDP）时才选择一个本地IP地址。</p>
<p>如果想要得到内核所选择的临时端口值，必须调用函数getsockname来返回协议地址。</p>
<p>bind函数返回一个常见错误EADDRINUSE(“Adress already in use”，地址已使用)</p>
<h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span></span><br></pre></td></tr></table></figure>
<p>listen函数仅由TCP服务器调用，它完成两件事情：</p>
<ol>
<li>当socket函数创建一个套接字时，它被假定为一个主动套接字，也就是说，它是一个将调用connect发起连接的客户端套接字。listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。调用listen导致套接字从closed状态转换到LISTEN状态。</li>
<li>第二个参数规定了内核应该为相应套接字排队的最大连接个数。</li>
</ol>
<p>内核为任何一个给定的监听套接字维护两个队列：</p>
<ol>
<li>未完成连接队列（incomplete connection queue），每个这样的SYN分节对应其中一项：已由某个客户端发出并到达服务器，而服务器正在等待并完成相应的TCP三路握手过程。这些套接字处于SYN_RCVD状态。</li>
<li>已完成连接队列（complete connection queue），每个已完成三路握手的客户端对应其中一项，这些套接字处于ESTABLISHED状态。</li>
</ol>
<p>如果三路握手正常完成，该项就从未完成连接队列移到已完成队列的队尾。当进程调用accept时，已完成连接队列中的队头将返回给进程，如果该队列为空，那么进程将被投入睡眠，知道TCP在该队列中放入一项才唤醒它。</p>
<p>关于两个队列：</p>
<ol>
<li>listen函数的backlog参数曾被规定为这两个队列的总和的最大值。</li>
<li>源自Berkeley的实现给backlog增设了一个模糊因子（fudge factor）：把它乘以1.5得到未处理队列最大长度。</li>
<li>不要把backlog定义为0，如果不想让客户端连接到套接字上，可以关掉该监听套接字。</li>
<li>在三路握手正常完成的前提下（也就是说没有丢失分节，从而没有重传），未完成连接队列中的任何一项在其中的存留时间就是一个RTT，而RTT的值取决于特定的客户与服务器。</li>
<li>当一个客户SYN到达时，若这些队列是满的，TCP就忽略该分节，也就是不发送RST，这么做是因为：这种情况是暂时的，客户TCP将重发SYN。</li>
<li>在三路握手完成之后，但在服务器调用accept之前到达的数据应由服务器TCP排队，最大数据量为已连接套接字接收缓冲区大小。</li>
</ol>
<h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *cliaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span></span><br></pre></td></tr></table></figure>
<p>accept函数由TCP服务器调用，用于从已完成连接队列头返回下一个已完成连接。如果已完成连接队列为空，那么进程被投入睡眠（假设套接字为默认的阻塞方式）。</p>
<p>如果accept成功，那么其返回值是由内核自动生成的一个全新描述符，代表与说返回客户的TCP连接。 accept函数的第一个参数为监听套接字（listening socket）描述符（由socket创建，随后用作bind和listen的第一个参数的描述符），称它的返回值为已连接套接字（connected socket）。</p>
<p>一个服务器通常只创建一个监听套接字，它在该服务器的生命期内一直存在。内核为每个由服务器进程接收的客户连接创建一个已连接套接字（也就是说对于它的TCP三路握手过程已经完成）。当服务器完成对某个给定客户的服务时，相应的已连接套接字就被关闭。</p>
<h2 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>close将一个TCP套接字的默认行为是把该套接字标记成已关闭，然后立即返回到调用进程，该套接字不能再由调用进程使用。然而TCP尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接终止序列。</p>
<p>并发服务器中父进程关闭已连接套接字只是导致相应描述符的引用计数值减1。如果引用计数值仍大于0，这个close调用并不引发TCP的四分组连接终止序列。</p>
<p>如果确实想在某个TCP连接上发送FIN，那么可以改用shutdown函数以代替close。</p>
<p>如果父进程对每个accept返回的已连接套接字都不调用close，首先父进程最终将耗尽可用描述符，因为任何进程在任何时刻可拥有的打开着的描述符通常都是有限制的。更重要的是，没有一个客户端连接会被终止。当子进程关闭已连接套接字时，它的引用计数值将由2递减为1且保持为1，因为父进程永不关闭任何已连接的套接字。这将妨碍TCP连接终止序列的发生，导致连接一直打开。</p>
<h2 id="getsockname-和-getpeername函数"><a href="#getsockname-和-getpeername函数" class="headerlink" title="getsockname 和 getpeername函数"></a>getsockname 和 getpeername函数</h2><p>这两个函数或者返回与某个套接字关联的本地协议地址（getsockname），或者返回与某个套接字关联的外地协议地址（getpeername）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *localaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *peeraddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="wait-和-waitpid-函数"><a href="#wait-和-waitpid-函数" class="headerlink" title="wait 和 waitpid 函数"></a>wait 和 waitpid 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc);</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure>
<p>函数wait和waitpid均返回两个值：已终止子进程的进程ID号，以及通过statloc指针返回的子进程终止状态（一个整数）。</p>
<p>如果调用wait的进程没有已终止的子进程，不够有一个或多个子进程仍在执行，那么wait将阻塞到现有子进程第一个终止为止。</p>
<p>waitpid函数就等待哪个进程以及是否阻塞给了更多的控制。首先，pid参数允许我们指定想等待的进程ID，值-1表示等待第一个终止的子进程。其次，option允许指定附加选项，最常用的选项是WNOHANG，它告知内核在没有已终止的子进程时不要阻塞。</p>
<h2 id="shutdown函数"><a href="#shutdown函数" class="headerlink" title="shutdown函数"></a>shutdown函数</h2><p>终止网络连接的常用方法是调用close函数。不过close有两个限制，却可以使用shutdown函数来避免。</p>
<ol>
<li>close把描述符的引用计数减1，仅在该计数变成0时才关闭套接字。使用shutdown可以不管引用计数就激发TCP的正常连接终止序列。</li>
<li>close终止读和写两个方向的数据传送。既然TCP连接是全双工的，有时候需要告知对端我们已经完成了数据发送，即使对端仍有数据要发送给我们。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure>
<p>shutdown的行为依赖于howto参数的值：</p>
<ol>
<li>SHUT_RD 关闭连接的读这一半————套接字中不再有数据可接收，而且套接字接收缓冲区中的现有数据都被丢弃。进程不能再对这样的套接字调用任何读函数。对一个TCP套接字调用这样的shutdown函数后，由该套接字接收的来自对端的任何数据都被确认，然后丢弃。</li>
<li>SHUT_WR 关闭连接的写这一半————对于TCP套接字，则成为半关闭（half close）。当前留在套接字发送缓冲区中的数据将被发送掉，后跟TCP的正常的连接终止序列。不管套接字描述符的引用计数是否等于0，这样的写半部分关闭照样执行。进程不能在对这样的套接字调用任何写函数。</li>
<li>SHUT_RDWR 连接的读半部和写半部都关闭————这与调用shutdown两次等效：第一次调用指定SHUT_RD，第二次调用指定SHUT_WR。</li>
</ol>
<h2 id="网络编程时遇到的情况"><a href="#网络编程时遇到的情况" class="headerlink" title="网络编程时遇到的情况"></a>网络编程时遇到的情况</h2><ol>
<li>当fork子进程时，必须捕获SIGHLD信号。</li>
<li>当捕获信号时，必须处理被中断的系统调用。</li>
<li>SIGCHLD的信号处理函数必须正确编写，应使用waitpid函数以面留下僵死进程。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/02/23/网络知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/23/网络知识/" itemprop="url">网络知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-23T17:16:20+08:00">
                2018-02-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-02-23T17:25:14+08:00">
                2018-02-23
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unix-Network-Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Unix Network Programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="客户端端口号"><a href="#客户端端口号" class="headerlink" title="客户端端口号"></a>客户端端口号</h2><p>客户端通常使用短期存活的<strong>临时端口（ephemeral port）</strong>。这些端口号通常由传输层协议自动赋予客户端。客户通常不关心其临时端口的具体值，只需要确定该端口号在所在主机中是唯一的就行。传输协议代码要确保这种唯一性。</p>
<h2 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h2><p>maximum transmission unit, 最大传输单元。</p>
<p>许多网络有一个硬件规定的MTU。例如，以太网的MTU是1500字节。</p>
<p>在两个主机之间的路径最下的MTU称为<strong>路径MTU(path MTU)</strong>。两个主机相反方向上路径MTU可以不一致，因为在因特网中路由选择往往是不对称的，也就是说从A到B的路径和从B到A的路径可以不相同。</p>
<p>当一个IP数据报从某个接口送出时，如果它的大小超过相应链路的MTU，IPv4和IPv6都将执行<strong>分片(fragmentation)</strong>。这些片段在到达目的地之前通常不会被<strong>重组（reassembling）</strong>。IPv4主机对其产生的数据报执行分片，IPv4路由器对其转发的数据包执行分片。然而IPv6只有主机对其产生的数据报执行分片，IPv6路由器不对其转发的数据报执行分片。</p>
<p>IPv4和IPv6都定义了<strong>最小重组缓冲区大小（minimum reassembly buffer size）</strong>，它是IPv4或IPv6的任何实现都必须保证支持的最小数据报大小。其值对于IPv4是576字节，对于IPv6是1500字节。</p>
<p>TCP中有一个<strong>MSS（maximum segment size，最大分片大小）</strong>，用于向对端TCP通告对端在每个分节中能发送的最大TCP数据量。MSS的目的是告诉对端其重组缓冲区大小的实际值，从而避免试图分片。MSS经常设置成MTU减去IP和TCP首部固定长度。</p>
<p>在以太网中使用IPv4的MSS值为1460，使用IPv6的MSS值为</p>
<h2 id="PDU-协议数据单元-protocol-data-unit"><a href="#PDU-协议数据单元-protocol-data-unit" class="headerlink" title="PDU(协议数据单元 protocol data unit)"></a>PDU(协议数据单元 protocol data unit)</h2><p>计算机网络各层对等实体间交换的单位信息称为<strong>协议数据单元(PDU)</strong>，按照协议与服务之间的关系，除了最底层（物理层）外，每层的PDU通过紧邻下层提供给本层的服务接口，作为下层的<strong>服务数据单元</strong>(<strong>service data unit, SDU</strong>)传递给下层，并由下层完成本层的PDU交换。如果本层的PDU大小超过紧临下层的最大SDU限制，那么本层需要实现把SDU划分为若干个合适的片段让下层分开载送，再在相反的方向把这些碎片重组成PDU。</p>
<p>应用层实体(如客户或者服务器进程)间交换的PDU称为<strong>应用数据(application data)</strong>，其中在应用进程之间交换的时没有长度限制的单个双向字节流，在UDP应用进程之间交换的是其长度不超过UDP发送缓冲区大小的<strong>单个记录(record)</strong>，在SCTP应用进程之间交换的是没有总长度限制的单个或多个双向记录流。</p>
<p>传输层实体间交换的PDU称为<strong>消息(message)</strong>，其中TCP的PDU称为<strong>分节(segment)</strong>。消息或分节的长度是有限的。</p>
<p>在TCP传输中，发送端TCP把来自应用进程的字节流数据按顺序经分割后封装在各个分节中传送给接收端TCP，其中每个分节所封装的数据即可能是发送端应用进程单次输出操作的结果，也可能是连续数次输出操作的结果，而且每个分节所封装的单次输出操作的结果或者首尾两次输出操作的结果既可能是完整的，也可能是不完整的，具体取决于连接建立阶段由对端通告的<strong>最大分节大小(MSS, maximum segment size)</strong>，以及外出接口的<strong>最大传输单元(maximum transmission unit, MTU)</strong>。</p>
<p>UDP传输层相当简单，发送端UDP就把来自应用进程的单个记录整个封装在UDP消息中传送给接收端UDP。</p>
<p>SCTP引入了称为<strong>块</strong>(<strong>chunk</strong>)的数据单元，SCTP消息就由一个公共首部加上一个或多个块构成：公共首部类似UDP消息的首部，仅仅给出源目的端口号和整个SCTP消息的校验和；块既可以承载数据，也可以承载控制信息。发送端SCTP把来自应用进程的（一个或多个）记录流数据按照数据流内顺序和记录边界封装在各个DATA块中，并在DATA块首部记上各自的流ID。</p>
<p>一个记录通常对应一个DATA块，对于过长的记录，发送端SCTP既可以像UDP那样拒绝发送，也可以把他们拆分到多个DATA块中以便发送，接收端SCTP收取后把他们组合成单个记录上传。</p>
<p>网络成实体间交换的PDU称为<strong>IP数据报(IP datagram)</strong>，其长度有限：IPV4数据报最大65535字节，IPv6数据报最大65575字节。发送端IP把来自传输层的消息（或TCP分节）整个封装在IP数据报中传送。</p>
<p>链路层实体间交换的PDU称为<strong>帧（frame）</strong>，其长度取决于具体的接口。</p>
<p>IP数据报由IP首部和所承载的传输层数据构成。过长的IP数据报无法封装在单个帧中，需要首先对其SDU进行<strong>分片（fragementation）</strong>，再把分成对得各个<strong>片段（fragement）</strong>冠以新的IP首部封装到多个帧中。在一个IP数据包从源端传送到目的端的传送过程中，分片操作既可能发生在源端，也可能发生在途中。</p>
<p>T<strong>CP/IP协议族为提高效率会尽可能避免IP分片/重组操作</strong>：TCP根据MSS和MTU限定每个分节的大小以及SCTP根据MTU分片/重组过长记录都是这个目的（STCP的块捆绑这是为了避免IP分片/重组操作的前提下提高块传输效率）；另外，IPv6禁止在途中的分片操作（基于其路径MTU发现功能），IPv4也尽量避免这种操作。</p>
<p>不论是否分片，都由IP作为链路层的SDU传入链路层，并由链路层封装再帧中的数据称为<strong>分组（packet，俗称包）</strong>。一个分组既可能是一个完整的IP数据报，也可能是某个IP数据报的SDU的一个片段冠以新的IP首部的结果。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://uyouii.github.io/2018/02/23/socket-编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Uyouii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Uyouii's Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/23/socket-编程/" itemprop="url">socket 编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-23T17:16:07+08:00">
                2018-02-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-02-23T17:22:05+08:00">
                2018-02-23
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unix-Network-Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Unix Network Programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><p>标识每个端点的两个值（IP地址和端口号）通常称为一个套接字。</p>
<p>TCP无法仅仅通过查看端口号来分离外来的分节到不同的端点。它必须查看套接字对的所有4个元素才能确定由哪个端点接收某个到达的分节。</p>
<h2 id="不同套接字地址结构比较"><a href="#不同套接字地址结构比较" class="headerlink" title="不同套接字地址结构比较"></a>不同套接字地址结构比较</h2><p><img src="https://github.com/Uyouii/Uyouii.github.io/raw/master/images/different%20address%20struct.JPG" alt="image"></p>
<h2 id="getsockopt-和-setsockopt-函数"><a href="#getsockopt-和-setsockopt-函数" class="headerlink" title="getsockopt 和 setsockopt 函数"></a>getsockopt 和 setsockopt 函数</h2><p>这两个函数仅用于套接字<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span>* optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>optval是一个指向某个变量的指针，setsockopt从<code>*optval</code>中取得选项待设置的新值，getsockopt则把已获取的选项当前值存放到<code>*optval</code>中。</p>
<p>套接字选项粗分为两大基本类型：一是启用或者禁止某个特性的二元选项（称为标志选项），二是取得并返回我们可以设置或检查的特定值选项（称为值选项）。</p>
<p>当给这些标志选项调用getsockopt函数时，<code>*optval</code>是一个整数。<code>*optval</code>中返回的值为0表示相应选项被禁止，不为0表示相应选项被启用。</p>
<p>setsockopt函数需要一个不为0的<code>*optva</code>值来启用选项，一个为0的<code>*optval</code>值来禁止选项。</p>
<h2 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h2><h3 id="SO-KEEPALIVE-套接字选项"><a href="#SO-KEEPALIVE-套接字选项" class="headerlink" title="SO_KEEPALIVE 套接字选项"></a>SO_KEEPALIVE 套接字选项</h3><p>给一个TCP套接字设置保持存活（keep-alive）选项后，如果在2小时内在该套接字的任一方向上都没有数据交换，TCP就自动给对端发送一个保持存活探测分节(keep-alive probe)。这是一个对端必须响应的TCP分节。</p>
<p>发送该分节后：</p>
<ol>
<li>对端以期望的ACK响应。应用进程得不到通知（因为一切正常）。在又经过仍无动静的2小时后，TCP将发出另一个探测分节。</li>
<li>对端以rst响应，它告知本端TCP：对端已崩溃且已重新启动。该套接字的待处理错误被置为ECONNRESET，套接字本身则被关闭。</li>
<li>对端对保持存活探测分节没有任何响应。源自Berkeley的TCP将另外发送8个探测分节，两两相隔75秒，试图得到一个响应。TCP在发出第一个探测分节后11分15秒内若没有得到任何响应则放弃。</li>
</ol>
<p>如果根本没有对TCP的探测分节的响应，该套接字的待处理错误就被置为ETIMEOUT，套接字本身则被关闭，然而如果该套接字收到一个ICMP错误作为某个探测分节的响应，那就返回相应的错误，套接字本身也被关闭。</p>
<p>本选项的功能是检测对端主机是否崩溃或变得不可达。如果对端进程崩溃，它的TCP将跨连接发送一个FIN，这可以通过调用select很容易的检测到。同时也要认识到，即使对任何保持存活探测分节均无响应（第三种情况），我们也不能肯定对端主机已经崩溃，因而TCP可能会终止一个有效连接。</p>
<p>本选项一本由服务器调用，不过客户端也可以使用。服务器使用本选项是因为它们花大部分时间阻塞在等待穿越TCP的连接输入上，也就是说在等待客户端的请求。然而如果客户主机连接掉线、电源掉线或系统崩溃，服务器进程将永远不会知道，并将继续等待永远不会到达的输入。这种情况称为半开连接（half-open connection）。保持存活选项将检测出这些半开连接并终止他们。</p>
<h3 id="SO-RCVBUF-和-SO-SNDBUF-套接字选项"><a href="#SO-RCVBUF-和-SO-SNDBUF-套接字选项" class="headerlink" title="SO_RCVBUF 和 SO_SNDBUF 套接字选项"></a>SO_RCVBUF 和 SO_SNDBUF 套接字选项</h3><p>每个套接字都有一个发送缓冲区和一个接收缓冲区。</p>
<p>接收缓冲区被TCP、UDP和SCTP用来保存接收到的数据，知道由应用进程来读取。对于TCP来说，套接字接收缓冲区中可用空间的大小限定了TCP通告对端的窗口大小。TCP套接字接收缓冲区不可能溢出，因为不允许对端发出超过本端所通告窗口大小的数据。这就是TCP的流量控制，如果对端无视窗口大大小而发出了超过该窗口大小的数据，本端TCP将丢弃他们。UDP是没有流量控制的：较快的发送端可以很容易地淹没较慢的接收端，导致接收端的UDP丢弃数据报。事实上较快的发送端甚至可以淹没本机的网络接口，导致数据报被本机丢弃。</p>
<p>当设置TCP套接字接收缓冲区的大小时，函数调用的顺序很重要。这是因为TCP的窗口规模选项是在建立连接时用SYN分节与对端互换得到的。对于客户，这意味着SO_RCVBUF选项必须在调用connect之前设置；对于服务器，这意味着该选项必须在调用listen之前给监听套接字设置。给已连接套接字设置该选项对于可能存在的窗口规模选项没有任何影响，因为accept直到TCP的三路握手完成才会创建并返回已连接套接字。这就是必须给监听套接字设置本选项的原因。（套接字缓冲区的大小总是由新创建的已连接套接字从监听套接字继承而来）。</p>
<p>TCP套接字缓冲区的大小至少应该是相应连接的MSS值的四倍。这一点的依据是TCP快速恢复算法的工作机制。TCP发送端使用三个重复的确认来检测某个分节是否丢失。发现某个分节丢失后，接收端将给新收到的每个分节发送一个重复的确认，如果窗口大小不足以存放4个这样的分节，那就不可能连发三个重复的确认，从而无法激活快速恢复算法。</p>
<h3 id="TCP-NODELAY套接字选项"><a href="#TCP-NODELAY套接字选项" class="headerlink" title="TCP_NODELAY套接字选项"></a>TCP_NODELAY套接字选项</h3><p>开启TCP_NODELAY选项将禁止TCP的Nagle算法。</p>
<p>Nagle算法的目的在于减少广域网（WAN）上小分组的数目。该算法指出：如果某个给定连接上有待确认数据（outstanding dataa），那么原本应该作为用户写操作相应的在该连接上立即发送相应小分组的行为就不会发生，直到现有数据被确认为止。这里“小”的定义就是小于MSS的任何分组。TCP总是尽可能地发送最大大小的分组，Nagle算法的目的在于防止一个连接在任何时刻有多个小分组待确认。</p>
<p>Nalge算法常常与另一个TCP算法联合使用：ACK延滞算法（delayed ACK algorithm）。该算法使得TCP在收到数据后不立即发送ACK，而是等待一小段时间(典型值为50~200ms)，然后才发送ACK。TCP期待在这一小段时间内自身有数据发送回对端，被延滞的ACK就可以由这些数据捎带，从而省掉一个TCP分节。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Uyouii" />
          <p class="site-author-name" itemprop="name">Uyouii</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Uyouii" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Uyouii</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
